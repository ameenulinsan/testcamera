var CABLES;
(() => {
    "use strict";
    var __webpack_modules__ = {
            122: () => {
                let GLOB_EXP = /(?:^|[^\\])\*/,
                    NOT_LINE_ENDING = /[^\r\n]/g;
                const Preprocessor = function(t, e, i) {
                    this.source = "" + t, this.baseDir = "string" == typeof e ? e : ".", this.includes = "object" == typeof e ? e : {}, this.preserveLineNumbers = "boolean" == typeof i && i, this.isNode = !("undefined" != typeof window && window.window), this.errorSourceAhead = 50, this.defines = []
                };
                Preprocessor.EXPR = /([ ]*)\/\/[ ]+#(include_once|include|ifn?def|if|endif|else|elif|put|define)/g, Preprocessor.ALL = /([^\r\n]*)\r?(?:\n|$)/, Preprocessor.INCLUDE = /(include_once|include)[ ]+"([^"\\]*(\\.[^"\\]*)*)"[ ]*\r?(?:\n|$)/g, Preprocessor.IF = /(ifdef|ifndef|if)[ ]*([^\r\n]+)\r?\n/g, Preprocessor.ENDIF = /(endif|else|elif)([ ]+[^\r\n]+)?\r?(?:\n|$)/g, Preprocessor.PUT = /put[ ]+([^\n]+)[ ]*/g, Preprocessor.DEFINE = /define[ ]+([^\n\r]+)\r?(?:\n|$)/g, Preprocessor.VAR = /define[ ]+var[ ]+([a-zA-Z_][a-zA-Z0-9_]*)[ ]*=[ ]*(.+)/g, Preprocessor.BOOLVAR = /define[ ]+([a-zA-Z_][a-zA-Z0-9_]*)[ ]*/g, Preprocessor.FUNCTION = /define[ ]+function[ ]+([a-zA-Z_][a-zA-Z0-9_]*)[ ]*(.+)/g, Preprocessor.stripSlashes = function(t) {
                    return (t + "").replace(/\\(.?)/g, (function(t, e) {
                        switch (e) {
                            case "\\":
                                return "\\";
                            case "0":
                                return "\0";
                            case "":
                                return "";
                            default:
                                return e
                        }
                    }))
                }, Preprocessor.addSlashes = function(t) {
                    return (t + "").replace(/([\\"'])/g, "\\$1").replace(/\0/g, "\\0")
                }, Preprocessor.indent = function(t, e) {
                    let i = t.split("\n");
                    for (let t = 0; t < i.length; t++) i[t] = e + i[t];
                    return i.join("\n")
                }, Preprocessor.nlToStr = function(t) {
                    return "[" + t.replace(/\r/g, "").replace(/\n/g, "\\n") + "]"
                }, Preprocessor.evaluate = function(defines, expr) {
                    let evalFunction = function() {
                        for (let key in defines) defines.hasOwnProperty(key) && ("var" === defines[key].type ? eval("var " + key + " = " + defines[key].value + ";") : eval("function " + key + defines[key].value));
                        return eval(expr)
                    };
                    return evalFunction()
                }, Preprocessor.prototype.process = function(t, e) {
                    t = t || {}, (e = "function" == typeof e ? e : function() {})("Defines: " + JSON.stringify(t));
                    let i, s, r, n, o, a, h = [],
                        l = !1;
                    for (; null !== (i = Preprocessor.EXPR.exec(this.source));) {
                        e(i[2] + " @ " + i.index + "-" + Preprocessor.EXPR.lastIndex);
                        let g = i[1];
                        if (l && h.length > 0 && "endif" !== i[2] && "else" !== i[2] && "elif" !== i[2]) {
                            if (a = h.pop(), e("  pop (" + h.length + "): " + JSON.stringify(a)), Preprocessor.ALL.lastIndex = i.index, null === (s = Preprocessor.ALL.exec(this.source))) throw new Error("Illegal #" + i[2] + ": " + this.source.substring(i.index, i.index + this.errorSourceAhead) + "...");
                            h.push(o = {
                                include: a.include,
                                index: a.index,
                                lastIndex: Preprocessor.ALL.lastIndex
                            }), e("  push (" + h.length + "): " + JSON.stringify(o))
                        } else switch (i[2]) {
                            case "ifdef":
                            case "ifndef":
                            case "if":
                                if (Preprocessor.IF.lastIndex = i.index, null === (s = Preprocessor.IF.exec(this.source))) throw new Error("Illegal #" + i[2] + ": " + this.source.substring(i.index, i.index + this.errorSourceAhead) + "...");
                                e("  test: " + s[2]), e("  defines  " + JSON.stringify(t)), n = "ifdef" === s[1] ? void 0 !== t[s[2]] : "ifndef" === s[1] ? void 0 === t[s[2]] : Preprocessor.evaluate(t, s[2]), l = !n, e("  value: " + n + ", isSkip: " + l), h.push(o = {
                                    include: n,
                                    index: i.index,
                                    lastIndex: Preprocessor.IF.lastIndex
                                }), e("  push (" + h.length + "): " + JSON.stringify(o));
                                break;
                            case "endif":
                            case "else":
                            case "elif":
                                if (Preprocessor.ENDIF.lastIndex = i.index, null === (s = Preprocessor.ENDIF.exec(this.source))) throw new Error("Illegal #" + i[2] + ': "' + this.source.substring(i.index, i.index + this.errorSourceAhead) + "...");
                                if (0 === h.length) throw new Error("Unexpected #" + s[1] + ': "' + this.source.substring(i.index, i.index + this.errorSourceAhead) + "...");
                                a = h.pop(), e("  pop (" + h.length + "): " + JSON.stringify(a)), n = this.preserveLineNumbers ? this.source.substring(a.index, a.lastIndex).replace(NOT_LINE_ENDING, "") + this.source.substring(a.lastIndex, i.index) + this.source.substring(i.index, Preprocessor.ENDIF.lastIndex).replace(NOT_LINE_ENDING, "") : this.source.substring(a.lastIndex, i.index), a.include ? (e("  incl: " + Preprocessor.nlToStr(n) + ", 0-" + a.index + " + " + n.length + " bytes + " + Preprocessor.ENDIF.lastIndex + "-" + this.source.length), this.source = this.source.substring(0, a.index) + n + this.source.substring(Preprocessor.ENDIF.lastIndex)) : this.preserveLineNumbers ? (e("  excl(\\n): " + Preprocessor.nlToStr(n) + ", 0-" + a.index + " + " + Preprocessor.ENDIF.lastIndex + "-" + this.source.length), n = n.replace(NOT_LINE_ENDING, ""), this.source = this.source.substring(0, a.index) + n + this.source.substring(Preprocessor.ENDIF.lastIndex)) : (e("  excl: " + Preprocessor.nlToStr(n) + ", 0-" + a.index + " + " + Preprocessor.ENDIF.lastIndex + "-" + this.source.length), n = "", this.source = this.source.substring(0, a.index) + this.source.substring(Preprocessor.ENDIF.lastIndex)), "" === this.source && e("  result empty"), l = !1, Preprocessor.EXPR.lastIndex = a.index + n.length, e("  continue at " + Preprocessor.EXPR.lastIndex), "else" !== s[1] && "elif" !== s[1] || (n = "else" === s[1] ? !a.include : Preprocessor.evaluate(t, s[2]), l = !n, e("  isSkip: " + l), h.push(o = {
                                    include: n,
                                    index: Preprocessor.EXPR.lastIndex,
                                    lastIndex: Preprocessor.EXPR.lastIndex
                                }), e("  push (" + h.length + "): " + JSON.stringify(o)));
                                break;
                            case "define":
                                if (Preprocessor.DEFINE.lastIndex = i.index, Preprocessor.VAR.lastIndex = i.index, Preprocessor.FUNCTION.lastIndex = i.index, Preprocessor.BOOLVAR.lastIndex = i.index, null === (s = Preprocessor.DEFINE.exec(this.source))) throw new Error("Illegal #" + i[2] + ": " + this.source.substring(i.index, i.index + this.errorSourceAhead) + "...");
                                var c, u, _;
                                if (e('  def: "' + s[1] + '"'), null !== (r = Preprocessor.VAR.exec(this.source))) _ = "var", c = r[1], u = r[2], e(" match3(var): " + JSON.stringify(r));
                                else if (null !== (r = Preprocessor.FUNCTION.exec(this.source))) _ = "function", c = r[1], u = r[2], e(" match3(function): " + JSON.stringify(r));
                                else {
                                    if (null === (r = Preprocessor.BOOLVAR.exec(this.source))) throw new Error("Illegal #" + i[2] + ": " + this.source.substring(i.index, i.index + this.errorSourceAhead) + "...");
                                    _ = "var", c = r[1], u = !0, e(" match3(boolvar): " + JSON.stringify(r))
                                }
                                e("  type: " + _), e("  identifier: " + c), e("  value: " + u), t[c] = {
                                    type: _,
                                    value: u
                                }, e("  defines  " + JSON.stringify(t));
                                var p = "";
                                this.preserveLineNumbers && (p = this.source.substring(i.index, Preprocessor.DEFINE.lastIndex).replace(NOT_LINE_ENDING, "")), this.source = this.source.substring(0, i.index) + g + p + this.source.substring(Preprocessor.DEFINE.lastIndex), Preprocessor.EXPR.lastIndex = i.index, e("  continue at " + Preprocessor.EXPR.lastIndex)
                        }
                    }
                    return h.length > 0 && e("Still on stack (" + h.length + "): " + JSON.stringify(h.pop())), this.source
                };
                var __WEBPACK_DEFAULT_EXPORT__ = Preprocessor
            }
        },
        __webpack_module_cache__ = {};

    function __webpack_require__(t) {
        var e = __webpack_module_cache__[t];
        if (void 0 !== e) return e.exports;
        var i = __webpack_module_cache__[t] = {
            exports: {}
        };
        return __webpack_modules__[t](i, i.exports, __webpack_require__), i.exports
    }
    __webpack_require__.d = (t, e) => {
        for (var i in e) __webpack_require__.o(e, i) && !__webpack_require__.o(t, i) && Object.defineProperty(t, i, {
            enumerable: !0,
            get: e[i]
        })
    }, __webpack_require__.o = (t, e) => Object.prototype.hasOwnProperty.call(t, e), __webpack_require__.r = t => {
        "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(t, Symbol.toStringTag, {
            value: "Module"
        }), Object.defineProperty(t, "__esModule", {
            value: !0
        })
    };
    var __webpack_exports__ = {};
    (() => {
        __webpack_require__.d(__webpack_exports__, {
            default: () => Wt
        });
        var t = {};
        __webpack_require__.r(t), __webpack_require__.d(t, {
            UTILS: () => l,
            ajax: () => N,
            ajaxSync: () => F,
            basename: () => R,
            cacheBust: () => I,
            clamp: () => v,
            copyArray: () => S,
            generateUUID: () => m,
            getShortOpName: () => c,
            jsonp: () => O,
            keyCodeToName: () => w,
            map: () => y,
            prefixedHash: () => E,
            request: () => C,
            shortId: () => g,
            shuffleArray: () => u,
            simpleId: () => A,
            smoothStep: () => b,
            smootherStep: () => x,
            uuid: () => f
        });
        var e = {};
        __webpack_require__.r(e), __webpack_require__.d(e, {
            b64decTypedArray: () => V,
            b64encTypesArray: () => D,
            base64Chars: () => U,
            base64lookup: () => k
        });
        var i = {};
        __webpack_require__.r(i), __webpack_require__.d(i, {
            ANIM: () => j,
            Anim: () => Y
        });
        var s = {};
        __webpack_require__.r(s), __webpack_require__.d(s, {
            PatchConnectionReceiver: () => Vt,
            PatchConnectionSender: () => Gt,
            PatchConnectorBroadcastChannel: () => Ht
        });
        class r {
            constructor(t) {
                this._logs = [], this.initiator = t
            }
            stack(t) {
                console.info("[" + this.initiator + "] ", t), console.log((new Error).stack)
            }
            groupCollapsed(t) {
                console.groupCollapsed("[" + this.initiator + "] " + t)
            }
            table(t) {
                console.table(t)
            }
            groupEnd() {
                console.groupEnd()
            }
            error(t) {
                console.error("[" + this.initiator + "]", ...arguments), window.gui && window.gui.emitEvent("coreLogEvent", this.initiator, "error", arguments)
            }
            info(t) {
                console.error("[" + this.initiator + "]", ...arguments), window.gui && window.gui.emitEvent("coreLogEvent", this.initiator, "info", arguments)
            }
            warn(t) {
                console.warn("[" + this.initiator + "]", ...arguments), window.gui && window.gui.emitEvent("coreLogEvent", this.initiator, "warn", arguments)
            }
            verbose() {
                (CABLES.UI && CABLES.UI.logFilter.shouldPrint(this.initiator, ...arguments) || !CABLES.logSilent) && console.log("[" + this.initiator + "]", ...arguments), window.gui && window.gui.emitEvent("coreLogEvent", this.initiator, "verbose", arguments)
            }
            log(t) {
                (CABLES.UI && CABLES.UI.logFilter.shouldPrint(this.initiator, ...arguments) || !CABLES.logSilent) && console.log("[" + this.initiator + "]", ...arguments), window.gui && window.gui.emitEvent("coreLogEvent", this.initiator, "log", arguments)
            }
            userInteraction(t) {}
        }
        const n = {
                EASINGS: ["linear", "absolute", "smoothstep", "smootherstep", "Cubic In", "Cubic Out", "Cubic In Out", "Expo In", "Expo Out", "Expo In Out", "Sin In", "Sin Out", "Sin In Out", "Quart In", "Quart Out", "Quart In Out", "Quint In", "Quint Out", "Quint In Out", "Back In", "Back Out", "Back In Out", "Elastic In", "Elastic Out", "Bounce In", "Bounce Out"],
                EASING_LINEAR: 0,
                EASING_ABSOLUTE: 1,
                EASING_SMOOTHSTEP: 2,
                EASING_SMOOTHERSTEP: 3,
                EASING_CUBICSPLINE: 4,
                EASING_CUBIC_IN: 5,
                EASING_CUBIC_OUT: 6,
                EASING_CUBIC_INOUT: 7,
                EASING_EXPO_IN: 8,
                EASING_EXPO_OUT: 9,
                EASING_EXPO_INOUT: 10,
                EASING_SIN_IN: 11,
                EASING_SIN_OUT: 12,
                EASING_SIN_INOUT: 13,
                EASING_BACK_IN: 14,
                EASING_BACK_OUT: 15,
                EASING_BACK_INOUT: 16,
                EASING_ELASTIC_IN: 17,
                EASING_ELASTIC_OUT: 18,
                EASING_BOUNCE_IN: 19,
                EASING_BOUNCE_OUT: 21,
                EASING_QUART_IN: 22,
                EASING_QUART_OUT: 23,
                EASING_QUART_INOUT: 24,
                EASING_QUINT_IN: 25,
                EASING_QUINT_OUT: 26,
                EASING_QUINT_INOUT: 27
            },
            o = {
                OP_PORT_TYPE_VALUE: 0,
                OP_PORT_TYPE_FUNCTION: 1,
                OP_PORT_TYPE_TRIGGER: 1,
                OP_PORT_TYPE_OBJECT: 2,
                OP_PORT_TYPE_TEXTURE: 2,
                OP_PORT_TYPE_ARRAY: 3,
                OP_PORT_TYPE_DYNAMIC: 4,
                OP_PORT_TYPE_STRING: 5,
                OP_VERSION_PREFIX: "_v"
            },
            a = {
                PORT_DIR_IN: 0,
                PORT_DIR_OUT: 1
            },
            h = {
                PACO_CLEAR: 0,
                PACO_VALUECHANGE: 1,
                PACO_OP_DELETE: 2,
                PACO_UNLINK: 3,
                PACO_LINK: 4,
                PACO_LOAD: 5,
                PACO_OP_CREATE: 6,
                PACO_OP_ENABLE: 7,
                PACO_OP_DISABLE: 8,
                PACO_UIATTRIBS: 9,
                PACO_VARIABLES: 10,
                PACO_TRIGGERS: 11,
                PACO_PORT_SETVARIABLE: 12,
                PACO_PORT_SETANIMATED: 13,
                PACO_PORT_ANIM_UPDATED: 14,
                PACO_DESERIALIZE: 15
            },
            l = {
                float32Concat: function(t, e) {
                    t instanceof Float32Array || (t = new Float32Array(t)), e instanceof Float32Array || (e = new Float32Array(e));
                    const i = new Float32Array(t.length + e.length);
                    return i.set(t), i.set(e, t.length), i
                }
            },
            c = function(t) {
                let e = t.split(".")[t.split(".").length - 1];
                if (e.indexOf(o.OP_VERSION_PREFIX) > 0) {
                    const t = e.split(o.OP_VERSION_PREFIX)[1];
                    e = e.substring(0, e.length - (o.OP_VERSION_PREFIX + t).length)
                }
                return e
            },
            u = function(t) {
                for (let e = t.length - 1; e > 0; e--) {
                    const i = Math.floor(Math.seededRandom() * (e + 1)),
                        s = t[e];
                    t[e] = t[i], t[i] = s
                }
                return t
            },
            _ = {},
            p = function() {
                let t = Math.random().toString(36).substr(2, 9);
                return _.hasOwnProperty(t) && (t = p()), _[t] = !0, t
            },
            g = p,
            d = function() {
                let t = (new Date).getTime();
                return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, (e => {
                    const i = (t + 16 * Math.random()) % 16 | 0;
                    return t = Math.floor(t / 16), ("x" == e ? i : 3 & i | 8).toString(16)
                }))
            },
            f = d,
            m = d,
            E = function(t, e = "id") {
                let i = 0;
                if (Array.prototype.reduce) i = t.split("").reduce(((t, e) => (t = (t << 5) - t + e.charCodeAt(0)) & t), 0);
                else if (t.length > 0)
                    for (let e = 0; e < t.length; e++) i = (i << 5) - i + t.charCodeAt(e), i &= i;
                return e + "" + i
            };
        let T = 0;
        const A = function() {
                return T++, T
            },
            b = function(t) {
                const e = Math.max(0, Math.min(1, (t - 0) / 1));
                return e * e * (3 - 2 * e)
            },
            x = function(t) {
                const e = Math.max(0, Math.min(1, (t - 0) / 1));
                return e * e * e * (e * (6 * e - 15) + 10)
            },
            v = function(t, e, i) {
                return Math.min(Math.max(t, e), i)
            },
            y = function(t, e, i, s, r, n) {
                if (t >= i) return r;
                if (t <= e) return s;
                let o = !1;
                const a = Math.min(e, i),
                    h = Math.max(e, i);
                a != e && (o = !0);
                let l = !1;
                const c = Math.min(s, r),
                    u = Math.max(s, r);
                c != s && (l = !0);
                let _ = 0,
                    p = 0;
                return _ = o ? (h - t) * (u - c) / (h - a) : (t - a) * (u - c) / (h - a), p = l ? u - _ : _ + c, n ? 1 == n ? s + (t = Math.max(0, Math.min(1, (p - s) / (r - s)))) * t * (3 - 2 * t) * (r - s) : 2 == n ? s + (t = Math.max(0, Math.min(1, (p - s) / (r - s)))) * t * t * (t * (6 * t - 15) + 10) * (r - s) : p : p
            };
        Math.randomSeed = 1, Math.seededRandom = function(t, e) {
            return 0 === Math.randomSeed && (Math.randomSeed = 999 * Math.random()), t = t || 1, e = e || 0, Math.randomSeed = (9301 * Math.randomSeed + 49297) % 233280, e + Math.randomSeed / 233280 * (t - e)
        }, l.arrayWriteToEnd = function(t, e) {
            for (let e = 1; e < t.length; e++) t[e - 1] = t[e];
            t[t.length - 1] = e
        }, l.isNumeric = function(t) {
            return !isNaN(parseFloat(t)) && isFinite(t)
        }, l.isArray = function(t) {
            return "[object Array]" === Object.prototype.toString.call(t)
        }, String.prototype.endl = function() {
            return this + "\n"
        }, String.prototype.startsWith = function(t) {
            return 0 === this.indexOf(t)
        }, String.prototype.endsWith = String.prototype.endsWith || function(t) {
            return this.match(t + "$") == t
        };
        const I = function(t) {
                return t.indexOf("?") > -1 ? t += "&" : t += "?", t + "cb=" + CABLES.uuid()
            },
            S = function(t, e) {
                if (!t) return null;
                (e = e || []).length = t.length;
                for (let i = 0; i < t.length; i++) e[i] = t[i];
                return e
            },
            R = function(t) {
                let e = "";
                if (!t) return "";
                const i = (t + "").split("/");
                if (i.length > 0) {
                    let t = i[i.length - 1].split("?");
                    e = t[0], t = e.split("."), e = t[0]
                }
                return e
            };
        let P = null;
        const O = function(t, e) {
                P = P || 0, P++;
                const i = P;
                CABLES["jsonpFunc" + i] = function(t) {
                    e(!1, t)
                };
                let s = "?";
                t.indexOf(s) > -1 && (s = "&");
                const r = document.createElement("script");
                r.setAttribute("src", t + s + "callback=CABLES.jsonpFunc" + i), document.body.appendChild(r)
            },
            F = function(t, e, i, s, r) {
                C({
                    url: t,
                    cb: e,
                    method: i,
                    data: s,
                    contenttype: r,
                    sync: !0
                })
            },
            N = function(t, e, i, s, r, n, o = {}) {
                C({
                    url: t,
                    cb: e,
                    method: i,
                    data: s,
                    contenttype: r,
                    sync: !1,
                    jsonP: n,
                    headers: o
                })
            },
            C = function(t) {
                let e;
                t.hasOwnProperty("asynch") || (t.asynch = !0);
                try {
                    e = new XMLHttpRequest
                } catch (t) {}
                e.onreadystatechange = function() {
                    4 == e.readyState && t.cb && (200 == e.status || 0 == e.status ? t.cb(!1, e.responseText, e) : t.cb(!0, e.responseText, e))
                }, e.addEventListener("progress", (t => {}));
                try {
                    e.open(t.method ? t.method.toUpperCase() : "GET", t.url, !t.sync)
                } catch (i) {
                    t.cb && t.cb(!0, i.msg, e)
                }
                if ("object" == typeof t.headers) {
                    const i = Object.keys(t.headers);
                    for (let s = 0; s < i.length; s++) {
                        const r = i[s],
                            n = t.headers[r];
                        e.setRequestHeader(r, n)
                    }
                }
                try {
                    t.post || t.data ? (e.setRequestHeader("Content-type", t.contenttype ? t.contenttype : "application/x-www-form-urlencoded"), e.send(t.data || t.post)) : e.send()
                } catch (i) {
                    t.cb && t.cb(!0, i.msg, e)
                }
            },
            w = function(t) {
                if (!t && 0 !== t) return "Unidentified";
                const e = {
                    8: "Backspace",
                    9: "Tab",
                    12: "Clear",
                    13: "Enter",
                    16: "Shift",
                    17: "Control",
                    18: "Alt",
                    19: "Pause",
                    20: "CapsLock",
                    27: "Escape",
                    32: "Space",
                    33: "PageUp",
                    34: "PageDown",
                    35: "End",
                    36: "Home",
                    37: "ArrowLeft",
                    38: "ArrowUp",
                    39: "ArrowRight",
                    40: "ArrowDown",
                    45: "Insert",
                    46: "Delete",
                    112: "F1",
                    113: "F2",
                    114: "F3",
                    115: "F4",
                    116: "F5",
                    117: "F6",
                    118: "F7",
                    119: "F8",
                    120: "F9",
                    121: "F10",
                    122: "F11",
                    123: "F12",
                    144: "NumLock",
                    145: "ScrollLock",
                    224: "Meta"
                };
                return e[t] ? e[t] : String.fromCharCode(t)
            };
        window.performance = window.performance || {
            offset: Date.now(),
            now: function() {
                return Date.now() - this.offset
            }
        };
        const M = function(t, e) {
            if (!t) throw new Error("no cgl");
            this._log = new r("cgl_texture"), this._cgl = t, this.tex = this._cgl.gl.createTexture(), this.id = CABLES.uuid(), this.width = 0, this.height = 0, this.loading = !1, this.flip = !0, this.flipped = !1, this.shadowMap = !1, this.deleted = !1, this.image = null, this.anisotropic = 0, this.filter = M.FILTER_NEAREST, this.wrap = M.WRAP_CLAMP_TO_EDGE, this.texTarget = this._cgl.gl.TEXTURE_2D, e && e.type && (this.texTarget = e.type), this.textureType = M.TYPE_DEFAULT, this.unpackAlpha = !0, this._fromData = !0, this.name = "unknown", this.pixelFormat = M.PFORMATSTR_RGBA8UB, e ? (this.name = e.name || this.name, e.isDepthTexture && (this.textureType = M.TYPE_DEPTH), !0 === e.isFloatingPointTexture && (this.textureType = M.TYPE_FLOAT), "textureType" in e && (this.textureType = e.textureType), "filter" in e && (this.filter = e.filter), "wrap" in e && (this.wrap = e.wrap), "unpackAlpha" in e && (this.unpackAlpha = e.unpackAlpha), "flip" in e && (this.flip = e.flip), "shadowMap" in e && (this.shadowMap = e.shadowMap), "anisotropic" in e && (this.anisotropic = e.anisotropic)) : e = {}, e.pixelFormat ? this.pixelFormat = e.pixelFormat : (e.isFloatingPointTexture || (this.pixelFormat = M.PFORMATSTR_RGBA8UB), e.isFloatingPointTexture && (this.pixelFormat = M.PFORMATSTR_RGBA32F)), this._cgl.glUseHalfFloatTex && this.pixelFormat == M.PFORMATSTR_RGBA32F && (this.pixelFormat = M.PFORMATSTR_RGBA16F), e.width || (e.width = 8), e.height || (e.height = 8), this._cgl.profileData.profileTextureNew++, this._cgl.profileData.addHeavyEvent("texture created", this.name, e.width + "x" + e.height), this.setSize(e.width, e.height), this.getInfoOneLine()
        };
        M.prototype.isFloatingPoint = function() {
            return this.textureType == M.TYPE_FLOAT
        }, M.prototype.compareSettings = function(t) {
            return !!t && t.width == this.width && t.height == this.height && t.filter == this.filter && t.wrap == this.wrap && t.textureType == this.textureType && t.unpackAlpha == this.unpackAlpha && t.anisotropic == this.anisotropic && t.shadowMap == this.shadowMap && t.texTarget == this.texTarget && t.flip == this.flip
        }, M.prototype.clone = function() {
            const t = new M(this._cgl, {
                name: this.name,
                filter: this.filter,
                wrap: this.wrap,
                textureType: this.textureType,
                pixelFormat: this.pixelFormat,
                unpackAlpha: this.unpackAlpha,
                flip: this.flip,
                width: this.width,
                height: this.height
            });
            return this._cgl.profileData.addHeavyEvent("texture created", this.name, this.width + "x" + this.height), this.compareSettings(t) || (this._log.error("Cloned texture settings do not compare!"), this._log.error(this), this._log.error(t)), t
        }, M.prototype.setSize = function(t, e) {
            if (this._cgl.aborted) return;
            if ((t != t || t <= 0 || !t) && (t = 8), (e != e || e <= 0 || !e) && (e = 8), (t > this._cgl.maxTexSize || e > this._cgl.maxTexSize) && this._log.error("texture size too big! " + t + "x" + e + " / max: " + this._cgl.maxTexSize), t = Math.min(t, this._cgl.maxTexSize), e = Math.min(e, this._cgl.maxTexSize), t = Math.floor(t), e = Math.floor(e), this.width == t && this.height == e) return;
            this.width = t, this.height = e, this.deleted = !1, this.shortInfoString = this.getInfoOneLine(), this._cgl.gl.bindTexture(this.texTarget, this.tex), this._cgl.profileData.profileTextureResize++;
            let i = this._cgl.gl.UNSIGNED_BYTE,
                s = this._cgl.gl.RGBA,
                r = this._cgl.gl.RGBA;
            if (this.textureType == M.TYPE_FLOAT)
                if (1 == this._cgl.glVersion)
                    if (this._cgl.glUseHalfFloatTex) {
                        const i = this._cgl.enableExtension("OES_texture_half_float");
                        if (this._cgl.enableExtension("EXT_color_buffer_half_float"), !i) throw new Error("no half float texture extension");
                        this._cgl.gl.texImage2D(this.texTarget, 0, this._cgl.gl.RGBA, t, e, 0, this._cgl.gl.RGBA, i.HALF_FLOAT_OES, null)
                    } else this._cgl.enableExtension("OES_texture_float"), this._cgl.gl.texImage2D(this.texTarget, 0, this._cgl.gl.RGBA, t, e, 0, this._cgl.gl.RGBA, this._cgl.gl.FLOAT, null);
            else this.pixelFormat == M.PFORMATSTR_RGBA32F && (s = this._cgl.gl.RGBA32F, i = this._cgl.gl.FLOAT), this.pixelFormat == M.PFORMATSTR_RGBA16F && (s = this._cgl.gl.RGBA16F, i = this._cgl.gl.FLOAT), this.pixelFormat == M.PFORMATSTR_R11FG11FB10F && (s = this._cgl.gl.R11F_G11F_B10F, i = this._cgl.gl.FLOAT, r = this._cgl.gl.RGB), i === this._cgl.gl.FLOAT && (this._cgl.gl.getExtension("EXT_color_buffer_float"), this._cgl.gl.getExtension("OES_texture_float_linear"));
            else this.textureType == M.TYPE_DEPTH ? 1 == this._cgl.glVersion ? (s = this._cgl.gl.DEPTH_COMPONENT, i = this._cgl.gl.UNSIGNED_SHORT, r = this._cgl.gl.DEPTH_COMPONENT) : (s = this._cgl.gl.DEPTH_COMPONENT32F, i = this._cgl.gl.FLOAT, r = this._cgl.gl.DEPTH_COMPONENT) : (i = this._cgl.gl.UNSIGNED_BYTE, s = this._cgl.gl.RGBA, r = this._cgl.gl.RGBA);
            this._cgl.gl.texImage2D(this.texTarget, 0, s, t, e, 0, r, i, null), this._setFilter(), this.updateMipMap(), this._cgl.gl.bindTexture(this.texTarget, null)
        }, M.prototype.initFromData = function(t, e, i, s, r) {
            if (this.filter = s, this.wrap = r, null == s && (this.filter = M.FILTER_LINEAR), null == r && (this.wrap = M.WRAP_CLAMP_TO_EDGE), this.width = e, this.height = i, this._fromData = !0, this.deleted = !1, this.height > this._cgl.maxTexSize || this.width > this._cgl.maxTexSize) {
                const t = CGL.Texture.getTempTexture(this._cgl);
                return this.width = t.width, this.height = t.height, this.tex = t.tex, void this._log.error("[cgl_texture] texture size to big!!!", this.width, this.height, this._cgl.maxTexSize)
            }
            this.flip && this._cgl.gl.pixelStorei(this._cgl.gl.UNPACK_FLIP_Y_WEBGL, this.flip), this._cgl.gl.bindTexture(this.texTarget, this.tex), this.textureType == M.TYPE_FLOAT ? this._cgl.gl.texImage2D(this.texTarget, 0, this._cgl.gl.RGBA32F, e, i, 0, this._cgl.gl.RGBA, this._cgl.gl.FLOAT, t) : this._cgl.gl.texImage2D(this.texTarget, 0, this._cgl.gl.RGBA, e, i, 0, this._cgl.gl.RGBA, this._cgl.gl.UNSIGNED_BYTE, t), this._setFilter(), this.updateMipMap(), this.flip && this._cgl.gl.pixelStorei(this._cgl.gl.UNPACK_FLIP_Y_WEBGL, !1), this._cgl.gl.bindTexture(this.texTarget, null)
        }, M.prototype.updateMipMap = function() {
            2 != this._cgl.glVersion && !this.isPowerOfTwo() || this.filter != M.FILTER_MIPMAP || (this._cgl.gl.generateMipmap(this.texTarget), this._cgl.profileData.profileGenMipMap++)
        }, M.prototype.initTexture = function(t, e) {
            if (this._cgl.printError("before initTexture"), this._cgl.checkFrameStarted("texture inittexture"), this._fromData = !1, this._cgl.gl.pixelStorei(this._cgl.gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, this.unpackAlpha), t.width && (this.width = t.width), t.height && (this.height = t.height), e && (this.filter = e), t.height > this._cgl.maxTexSize || t.width > this._cgl.maxTexSize) {
                const e = CGL.Texture.getTempTexture(this._cgl);
                return this.width = e.width, this.height = e.height, this.tex = e.tex, void this._log.error("[cgl_texture] texture size to big!!!", t.width, t.height, this._cgl.maxTexSize)
            }
            this._cgl.gl.bindTexture(this.texTarget, this.tex), this.deleted = !1, this.flipped = !this.flip, this.flipped && this._cgl.gl.pixelStorei(this._cgl.gl.UNPACK_FLIP_Y_WEBGL, this.flipped), this._cgl.gl.texImage2D(this.texTarget, 0, this._cgl.gl.RGBA, this._cgl.gl.RGBA, this._cgl.gl.UNSIGNED_BYTE, t), this._setFilter(), this.updateMipMap(), this._cgl.gl.bindTexture(this.texTarget, null), this._cgl.gl.pixelStorei(this._cgl.gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, !1), this.flipped && this._cgl.gl.pixelStorei(this._cgl.gl.UNPACK_FLIP_Y_WEBGL, !1), this.getInfoOneLine(), this._cgl.printError("initTexture")
        }, M.prototype.delete = function() {
            this.loading || (this.deleted = !0, this.width = 0, this.height = 0, this._cgl.profileData.profileTextureDelete++, this._cgl.gl.deleteTexture(this.tex), this.image = null, this.tex = null)
        }, M.prototype.isPowerOfTwo = function() {
            return M.isPowerOfTwo(this.width) && M.isPowerOfTwo(this.height)
        }, M.prototype.printInfo = function() {
            console.log(this.getInfo())
        }, M.prototype.getInfoReadable = function() {
            const t = this.getInfo();
            let e = "";
            t.name = t.name.substr(0, t.name.indexOf("?rnd="));
            for (const i in t) e += "* " + i + ":  **" + t[i] + "**\n";
            return e
        }, M.prototype.getInfoOneLine = function() {
            let t = this.width + "x" + this.height;
            return t += " ", t += this.pixelFormat, this.filter === CGL.Texture.FILTER_NEAREST && (t += " nearest"), this.filter === CGL.Texture.FILTER_LINEAR && (t += " linear"), this.filter === CGL.Texture.FILTER_MIPMAP && (t += " mipmap"), this.wrap === CGL.Texture.WRAP_CLAMP_TO_EDGE && (t += " clamp"), this.wrap === CGL.Texture.WRAP_REPEAT && (t += " repeat"), this.wrap === CGL.Texture.WRAP_MIRRORED_REPEAT && (t += " repeatmir"), this.shortInfoString = t, t
        }, M.prototype.getInfoOneLineShort = function() {
            let t = this.width + "x" + this.height;
            return t += " ", t += this.pixelFormat, this.shortInfoString = t, t
        }, M.prototype.getInfo = function() {
            return M.getTexInfo(this)
        }, M.prototype._setFilter = function() {
            if (this._cgl.printError("before _setFilter"), this._fromData || this._cgl.gl.pixelStorei(this._cgl.gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, this.unpackAlpha), this.shadowMap && (this._cgl.gl.texParameteri(this._cgl.gl.TEXTURE_2D, this._cgl.gl.TEXTURE_COMPARE_MODE, this._cgl.gl.COMPARE_REF_TO_TEXTURE), this._cgl.gl.texParameteri(this._cgl.gl.TEXTURE_2D, this._cgl.gl.TEXTURE_COMPARE_FUNC, this._cgl.gl.LEQUAL)), this.textureType == M.TYPE_FLOAT && this.filter == M.FILTER_MIPMAP && (this.filter = M.FILTER_LINEAR, this._log.stack("texture: HDR and mipmap filtering at the same time is not possible")), 1 != this._cgl.glVersion || this.isPowerOfTwo()) {
                if (this.wrap == M.WRAP_CLAMP_TO_EDGE ? (this._cgl.gl.texParameteri(this.texTarget, this._cgl.gl.TEXTURE_WRAP_S, this._cgl.gl.CLAMP_TO_EDGE), this._cgl.gl.texParameteri(this.texTarget, this._cgl.gl.TEXTURE_WRAP_T, this._cgl.gl.CLAMP_TO_EDGE)) : this.wrap == M.WRAP_REPEAT ? (this._cgl.gl.texParameteri(this.texTarget, this._cgl.gl.TEXTURE_WRAP_S, this._cgl.gl.REPEAT), this._cgl.gl.texParameteri(this.texTarget, this._cgl.gl.TEXTURE_WRAP_T, this._cgl.gl.REPEAT)) : this.wrap == M.WRAP_MIRRORED_REPEAT && (this._cgl.gl.texParameteri(this.texTarget, this._cgl.gl.TEXTURE_WRAP_S, this._cgl.gl.MIRRORED_REPEAT), this._cgl.gl.texParameteri(this.texTarget, this._cgl.gl.TEXTURE_WRAP_T, this._cgl.gl.MIRRORED_REPEAT)), this.filter == M.FILTER_NEAREST) this._cgl.gl.texParameteri(this.texTarget, this._cgl.gl.TEXTURE_MAG_FILTER, this._cgl.gl.NEAREST), this._cgl.gl.texParameteri(this.texTarget, this._cgl.gl.TEXTURE_MIN_FILTER, this._cgl.gl.NEAREST);
                else if (this.filter == M.FILTER_LINEAR) this._cgl.gl.texParameteri(this.texTarget, this._cgl.gl.TEXTURE_MIN_FILTER, this._cgl.gl.LINEAR), this._cgl.gl.texParameteri(this.texTarget, this._cgl.gl.TEXTURE_MAG_FILTER, this._cgl.gl.LINEAR);
                else {
                    if (this.filter != M.FILTER_MIPMAP) throw this._log.log("unknown texture filter!", this.filter), new Error("unknown texture filter!" + this.filter);
                    this._cgl.gl.texParameteri(this.texTarget, this._cgl.gl.TEXTURE_MAG_FILTER, this._cgl.gl.LINEAR), this._cgl.gl.texParameteri(this.texTarget, this._cgl.gl.TEXTURE_MIN_FILTER, this._cgl.gl.LINEAR_MIPMAP_LINEAR)
                }
                if (this.anisotropic) {
                    const t = this._cgl.enableExtension("EXT_texture_filter_anisotropic");
                    if (t) {
                        const e = this._cgl.gl.getParameter(t.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
                        this._cgl.gl.texParameterf(this._cgl.gl.TEXTURE_2D, t.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(e, this.anisotropic))
                    }
                }
            } else this._cgl.gl.texParameteri(this.texTarget, this._cgl.gl.TEXTURE_MAG_FILTER, this._cgl.gl.NEAREST), this._cgl.gl.texParameteri(this.texTarget, this._cgl.gl.TEXTURE_MIN_FILTER, this._cgl.gl.NEAREST), this._cgl.gl.texParameteri(this.texTarget, this._cgl.gl.TEXTURE_WRAP_S, this._cgl.gl.CLAMP_TO_EDGE), this._cgl.gl.texParameteri(this.texTarget, this._cgl.gl.TEXTURE_WRAP_T, this._cgl.gl.CLAMP_TO_EDGE), this.filter = M.FILTER_NEAREST, this.wrap = M.WRAP_CLAMP_TO_EDGE;
            this.getInfoOneLine(), this._cgl.printError("_setFilter")
        }, M.load = function(t, e, i, s) {
            if (!e) return i({
                error: !0
            });
            let r = null;
            t.patch.loading.existByName(e) || (r = t.patch.loading.start("texture", e));
            const n = new M(t);
            return n.name = e, t.patch.isEditorMode() && gui.jobs().start({
                id: "loadtexture" + r,
                title: "loading texture " + CABLES.basename(e)
            }), n.image = new Image, n.image.crossOrigin = "anonymous", n.loading = !0, s && s.hasOwnProperty("filter") && (n.filter = s.filter), s && s.hasOwnProperty("flip") && (n.flip = s.flip), s && s.hasOwnProperty("wrap") && (n.wrap = s.wrap), s && s.hasOwnProperty("anisotropic") && (n.anisotropic = s.anisotropic), s && s.hasOwnProperty("unpackAlpha") && (n.unpackAlpha = s.unpackAlpha), n.image.onabort = n.image.onerror = s => {
                console.warn("[cgl.texture.load] error loading texture", e, s), n.loading = !1, r && t.patch.loading.finished(r), i && i({
                    error: !0
                }, n), t.patch.isEditorMode() && gui.jobs().finish("loadtexture" + r)
            }, n.image.onload = function(e) {
                t.addNextFrameOnceCallback((() => {
                    n.initTexture(n.image), r && t.patch.loading.finished(r), n.loading = !1, t.patch.isEditorMode() && gui.jobs().finish("loadtexture" + r), i && i(null, n)
                }))
            }, n.image.src = e, n
        }, M.getTempTexture = function(t) {
            return t || console.error("[getTempTexture] no cgl!"), t.tempTexture || (t.tempTexture = M.getTemporaryTexture(t, 256, M.FILTER_LINEAR, M.REPEAT)), t.tempTexture
        }, M.getErrorTexture = function(t) {
            return t || console.error("[getTempTexture] no cgl!"), t.errorTexture || (t.errorTexture = M.getTemporaryTexture(t, 256, M.FILTER_LINEAR, M.REPEAT, 1, .2, .2)), t.errorTexture
        }, M.getEmptyTexture = function(t, e) {
            if (e) return M.getEmptyTextureFloat(t);
            if (t || console.error("[getEmptyTexture] no cgl!"), t.tempTextureEmpty) return t.tempTextureEmpty;
            t.tempTextureEmpty = new M(t, {
                name: "emptyTexture"
            });
            const i = new Uint8Array(256).fill(0);
            for (let t = 0; t < 256; t += 4) i[t + 3] = 0;
            return t.tempTextureEmpty.initFromData(i, 8, 8, M.FILTER_NEAREST, M.WRAP_REPEAT), t.tempTextureEmpty
        }, M.getEmptyTextureFloat = function(t) {
            if (t || console.error("[getEmptyTextureFloat] no cgl!"), t.tempTextureEmptyFloat) return t.tempTextureEmptyFloat;
            t.tempTextureEmptyFloat = new M(t, {
                name: "emptyTexture",
                isFloatingPointTexture: !0
            });
            const e = new Float32Array(256).fill(1);
            for (let t = 0; t < 256; t += 4) e[t + 3] = 0;
            return t.tempTextureEmptyFloat.initFromData(e, 8, 8, M.FILTER_NEAREST, M.WRAP_REPEAT), t.tempTextureEmptyFloat
        }, M.getRandomTexture = function(t) {
            if (t || console.error("[getRandomTexture] no cgl!"), t.randomTexture) return t.randomTexture;
            const e = new Uint8Array(262144);
            for (let t = 0; t < 65536; t++) e[4 * t + 0] = 255 * Math.random(), e[4 * t + 1] = 255 * Math.random(), e[4 * t + 2] = 255 * Math.random(), e[4 * t + 3] = 255;
            return t.randomTexture = new M(t), t.randomTexture.initFromData(e, 256, 256, M.FILTER_NEAREST, M.WRAP_REPEAT), t.randomTexture
        }, M.getRandomFloatTexture = function(t) {
            if (t || console.error("[getRandomTexture] no cgl!"), t.getRandomFloatTexture) return t.getRandomFloatTexture;
            const e = new Float32Array(262144);
            for (let t = 0; t < 65536; t++) e[4 * t + 0] = 2 * (Math.random() - .5), e[4 * t + 1] = 2 * (Math.random() - .5), e[4 * t + 2] = 2 * (Math.random() - .5), e[4 * t + 3] = 1;
            return t.getRandomFloatTexture = new M(t, {
                isFloatingPointTexture: !0
            }), t.getRandomFloatTexture.initFromData(e, 256, 256, M.FILTER_NEAREST, M.WRAP_REPEAT), t.getRandomFloatTexture
        }, M.getBlackTexture = function(t) {
            if (t || this._log.error("[getBlackTexture] no cgl!"), t.blackTexture) return t.blackTexture;
            const e = new Uint8Array(256);
            for (let t = 0; t < 64; t++) e[4 * t + 0] = e[4 * t + 1] = e[4 * t + 2] = 0, e[4 * t + 3] = 255;
            return t.blackTexture = new M(t), t.blackTexture.initFromData(e, 8, 8, M.FILTER_NEAREST, M.WRAP_REPEAT), t.blackTexture
        }, M.getEmptyCubemapTexture = function(t) {
            const e = [t.gl.TEXTURE_CUBE_MAP_POSITIVE_X, t.gl.TEXTURE_CUBE_MAP_NEGATIVE_X, t.gl.TEXTURE_CUBE_MAP_POSITIVE_Y, t.gl.TEXTURE_CUBE_MAP_NEGATIVE_Y, t.gl.TEXTURE_CUBE_MAP_POSITIVE_Z, t.gl.TEXTURE_CUBE_MAP_NEGATIVE_Z],
                i = t.gl.createTexture(),
                s = t.gl.TEXTURE_CUBE_MAP,
                r = M.FILTER_NEAREST,
                n = M.WRAP_CLAMP_TO_EDGE;
            t.profileData.profileTextureNew++, t.gl.bindTexture(s, i), t.profileData.profileTextureResize++;
            for (let i = 0; i < 6; i += 1) {
                const r = new Uint8Array(256);
                t.gl.texImage2D(e[i], 0, t.gl.RGBA, 8, 8, 0, t.gl.RGBA, t.gl.UNSIGNED_BYTE, r), t.gl.texParameteri(s, t.gl.TEXTURE_MAG_FILTER, t.gl.NEAREST), t.gl.texParameteri(s, t.gl.TEXTURE_MIN_FILTER, t.gl.NEAREST), t.gl.texParameteri(s, t.gl.TEXTURE_WRAP_S, t.gl.CLAMP_TO_EDGE), t.gl.texParameteri(s, t.gl.TEXTURE_WRAP_T, t.gl.CLAMP_TO_EDGE)
            }
            return t.gl.bindTexture(s, null), {
                id: CABLES.uuid(),
                tex: i,
                cubemap: i,
                width: 8,
                height: 8,
                filter: r,
                wrap: n,
                unpackAlpha: !0,
                flip: !0,
                _fromData: !0,
                name: "emptyCubemapTexture",
                anisotropic: 0
            }
        }, M.getTempGradientTexture = function(t) {
            if (t || console.error("[getTempGradientTexture] no cgl!"), t.tempTextureGradient) return t.tempTextureGradient;
            const e = new M(t),
                i = 256,
                s = new Uint8Array(262144);
            for (let t = 0; t < i; t++)
                for (let e = 0; e < i; e++) s[4 * (e + t * i) + 0] = s[4 * (e + t * i) + 1] = s[4 * (e + t * i) + 2] = 255 - t, s[4 * (e + t * i) + 3] = 255;
            return e.initFromData(s, i, i, M.FILTER_NEAREST, M.WRAP_REPEAT), t.tempTextureGradient = e, e
        }, M.getTemporaryTexture = function(t, e, i, s, r, n, o) {
            void 0 === r && (r = 1), void 0 === n && (n = 1), void 0 === o && (o = 1);
            const a = new M(t),
                h = [];
            for (let t = 0; t < e; t++)
                for (let i = 0; i < e; i++)(i + t) % 64 < 32 ? (h.push((200 + t / e * 25 + i / e * 25) * r), h.push((200 + t / e * 25 + i / e * 25) * n), h.push((200 + t / e * 25 + i / e * 25) * o)) : (h.push((40 + t / e * 25 + i / e * 25) * r), h.push((40 + t / e * 25 + i / e * 25) * n), h.push((40 + t / e * 25 + i / e * 25) * o)), h.push(255);
            const l = new Uint8Array(h);
            return a.initFromData(l, e, e, i, s), a
        }, M.createFromImage = function(t, e, i) {
            const s = new M(t, i = i || {});
            return s.flip = !1, s.image = e, s.width = e.width, s.height = e.height, i.hasOwnProperty("wrap") && (s.wrap = i.wrap), s.initTexture(e, i.filter), s
        }, M.fromImage = function(t, e, i, s) {
            console.error("deprecated texture from image...");
            const r = new M(t);
            return r.flip = !1, i && (r.filter = i), s && (r.wrap = s), r.image = e, r.initTexture(e), r
        }, M.isPowerOfTwo = function(t) {
            return 1 == t || 2 == t || 4 == t || 8 == t || 16 == t || 32 == t || 64 == t || 128 == t || 256 == t || 512 == t || 1024 == t || 2048 == t || 4096 == t || 8192 == t || 16384 == t
        }, M.getTexInfo = function(t) {
            const e = {};
            e.name = t.name, e["power of two"] = M.isPowerOfTwo(), e.size = t.width + " x " + t.height;
            let i = t.texTarget;
            return t.texTarget == t._cgl.gl.TEXTURE_2D && (i = "TEXTURE_2D"), e.target = i, e.unpackAlpha = t.unpackAlpha, t.cubemap && (e.cubemap = !0), t.textureType == M.TYPE_FLOAT && (e.textureType = "TYPE_FLOAT"), t.textureType == M.TYPE_HALF_FLOAT ? e.textureType = "TYPE_HALF_FLOAT" : t.textureType == M.TYPE_DEPTH ? e.textureType = "TYPE_DEPTH" : t.textureType == M.TYPE_DEFAULT ? e.textureType = "TYPE_DEFAULT" : e.textureType = "UNKNOWN " + this.textureType, e.pixelFormat = this.pixelFormat, t.wrap == M.WRAP_CLAMP_TO_EDGE ? e.wrap = "CLAMP_TO_EDGE" : t.wrap == M.WRAP_REPEAT ? e.wrap = "WRAP_REPEAT" : t.wrap == M.WRAP_MIRRORED_REPEAT ? e.wrap = "WRAP_MIRRORED_REPEAT" : e.wrap = "UNKNOWN", t.filter == M.FILTER_NEAREST ? e.filter = "FILTER_NEAREST" : t.filter == M.FILTER_LINEAR ? e.filter = "FILTER_LINEAR" : t.filter == M.FILTER_MIPMAP ? e.filter = "FILTER_MIPMAP" : e.filter = "UNKNOWN", e
        }, M.FILTER_NEAREST = 0, M.FILTER_LINEAR = 1, M.FILTER_MIPMAP = 2, M.WRAP_REPEAT = 0, M.WRAP_MIRRORED_REPEAT = 1, M.WRAP_CLAMP_TO_EDGE = 2, M.TYPE_DEFAULT = 0, M.TYPE_DEPTH = 1, M.TYPE_FLOAT = 2, M.PFORMATSTR_RGBA8UB = "RGBA 8bit ubyte", M.PFORMATSTR_RGBA16F = "RGBA 16bit float", M.PFORMATSTR_R11FG11FB10F = "RGB 11/11/10bit float", M.PFORMATSTR_RGBA32F = "RGBA 32bit float", M.PIXELFORMATS = [M.PFORMATSTR_RGBA8UB, M.PFORMATSTR_R11FG11FB10F, M.PFORMATSTR_RGBA16F, M.PFORMATSTR_RGBA32F], M.isPixelFormatFloat = t => t == M.PFORMATSTR_RGBA32F || t == M.PFORMATSTR_R11FG11FB10F || t == M.PFORMATSTR_RGBA16F;
        const B = function(t, e, i, s) {
            this._log = new r("cgl_framebuffer2"), this.Framebuffer2DrawTargetsDefault = null, this.Framebuffer2BlittingFramebuffer = null, this.Framebuffer2FinalFramebuffer = null, this._cgl = t, this._cgl.printError("before framebuffer2 constructor"), this._width = 0, this._height = 0, this.valid = !0, this._depthRenderbuffer = null, this._frameBuffer = null, this._textureFrameBuffer = null, this._colorRenderbuffers = [], this._drawTargetArray = [], this._disposed = !1, this.Framebuffer2BlittingFramebuffer || (this.Framebuffer2BlittingFramebuffer = t.gl.createFramebuffer()), this.Framebuffer2FinalFramebuffer || (this.Framebuffer2FinalFramebuffer = t.gl.createFramebuffer()), this.Framebuffer2DrawTargetsDefault || (this.Framebuffer2DrawTargetsDefault = [t.gl.COLOR_ATTACHMENT0]), this._options = s || {
                isFloatingPointTexture: !1
            }, this.name = this._options.name || "unknown", this._cgl.profileData.addHeavyEvent("framebuffer create", this.name), this._options.hasOwnProperty("numRenderBuffers") || (this._options.numRenderBuffers = 1), this._options.hasOwnProperty("depth") || (this._options.depth = !0), this._options.hasOwnProperty("clear") || (this._options.clear = !0), this._options.hasOwnProperty("multisampling") || (this._options.multisampling = !1, this._options.multisamplingSamples = 0), this._options.multisamplingSamples && (this._cgl.glSlowRenderer && (this._options.multisamplingSamples = 0), this._cgl.gl.MAX_SAMPLES ? this._options.multisamplingSamples = Math.min(this._cgl.maxSamples, this._options.multisamplingSamples) : this._options.multisamplingSamples = 0), this._options.hasOwnProperty("filter") || (this._options.filter = M.FILTER_LINEAR), this._options.hasOwnProperty("wrap") || (this._options.wrap = M.WRAP_REPEAT), this._numRenderBuffers = this._options.numRenderBuffers, this._colorTextures = [], s.pixelFormat || (s.isFloatingPointTexture || (this._options.pixelFormat = M.PFORMATSTR_RGBA8UB), s.isFloatingPointTexture && (this._options.pixelFormat = M.PFORMATSTR_RGBA32F));
            for (let e = 0; e < this._numRenderBuffers; e++) this._colorTextures[e] = new M(t, {
                name: "fb2 " + this.name + " " + e,
                isFloatingPointTexture: this._options.isFloatingPointTexture,
                pixelFormat: this._options.pixelFormat,
                filter: this._options.filter,
                wrap: this._options.wrap
            });
            let n = M.FILTER_NEAREST;
            this._options.shadowMap && (n = M.FILTER_LINEAR);
            const o = 512;
            this._options.depth && (this._textureDepth = new M(t, {
                name: "fb2 depth " + this.name,
                isDepthTexture: !0,
                filter: n,
                shadowMap: this._options.shadowMap || !1,
                width: e || o,
                height: i || o
            })), t.aborted || (this.setSize(e || o, i || o), this._cgl.printError("framebuffer2 constructor"))
        };
        B.prototype.getWidth = function() {
            return this._width
        }, B.prototype.getHeight = function() {
            return this._height
        }, B.prototype.getGlFrameBuffer = function() {
            return this._frameBuffer
        }, B.prototype.getDepthRenderBuffer = function() {
            return this._depthRenderbuffer
        }, B.prototype.getTextureColor = function() {
            return this._colorTextures[0]
        }, B.prototype.getTextureColorNum = function(t) {
            return this._colorTextures[t]
        }, B.prototype.getTextureDepth = function() {
            return this._textureDepth
        }, B.prototype.setFilter = function(t) {
            for (let e = 0; e < this._numRenderBuffers; e++) this._colorTextures[e].filter = t, this._colorTextures[e].setSize(this._width, this._height)
        }, B.prototype.delete = B.prototype.dispose = function() {
            this._disposed = !0;
            let t = 0;
            for (t = 0; t < this._numRenderBuffers; t++) this._colorTextures[t].delete();
            for (this._textureDepth && this._textureDepth.delete(), t = 0; t < this._numRenderBuffers; t++) this._cgl.gl.deleteRenderbuffer(this._colorRenderbuffers[t]);
            this._cgl.gl.deleteRenderbuffer(this._depthRenderbuffer), this._cgl.gl.deleteFramebuffer(this._frameBuffer), this._cgl.gl.deleteFramebuffer(this._textureFrameBuffer)
        }, B.prototype.setSize = function(t, e) {
            if (this._disposed) return this._log.warn("disposed framebuffer setsize...");
            this._cgl.profileData.addHeavyEvent("framebuffer resize", this.name);
            let i = 0;
            if (this._width = Math.floor(t), this._height = Math.floor(e), this._width = Math.min(this._width, this._cgl.maxTexSize), this._height = Math.min(this._height, this._cgl.maxTexSize), this._cgl.profileData.profileFrameBuffercreate++, this._frameBuffer) {
                for (i = 0; i < this._numRenderBuffers; i++) this._cgl.gl.deleteRenderbuffer(this._colorRenderbuffers[i]);
                this._cgl.gl.deleteRenderbuffer(this._depthRenderbuffer), this._cgl.gl.deleteFramebuffer(this._frameBuffer), this._cgl.gl.deleteFramebuffer(this._textureFrameBuffer)
            }
            this._frameBuffer = this._cgl.gl.createFramebuffer(), this._textureFrameBuffer = this._cgl.gl.createFramebuffer();
            const s = this._options.depth;
            for (i = 0; i < this._numRenderBuffers; i++) this._colorTextures[i].setSize(this._width, this._height);
            for (i = 0; i < this._numRenderBuffers; i++) {
                const t = this._cgl.gl.createRenderbuffer();
                this._cgl.gl.bindFramebuffer(this._cgl.gl.FRAMEBUFFER, this._frameBuffer), this._cgl.gl.bindRenderbuffer(this._cgl.gl.RENDERBUFFER, t);
                let e = this._cgl.gl.RGBA8;
                this._options.isFloatingPointTexture && (this._cgl.glUseHalfFloatTex && console.log("forcing half float..."), this._options.pixelFormat == M.PFORMATSTR_RGBA16HF || this._cgl.glUseHalfFloatTex ? (this._cgl.enableExtension("EXT_color_buffer_half_float"), this._cgl.enableExtension("EXT_color_buffer_half_float_linear") || (this._options.filter = M.FILTER_NEAREST, this.setFilter(this._options.filter)), e = this._cgl.gl.RGBA16F) : this._options.pixelFormat == M.PFORMATSTR_RGBA32F ? (this._cgl.enableExtension("EXT_color_buffer_float"), this._cgl.enableExtension("EXT_color_buffer_float_linear") || (console.log("no linear pixelformat,using nearest"), this._options.filter = M.FILTER_NEAREST, this.setFilter(this._options.filter)), e = this._cgl.gl.RGBA32F) : this._options.pixelFormat == M.PFORMATSTR_R11FG11FB10F && (this._cgl.enableExtension("EXT_color_buffer_float"), this._cgl.enableExtension("OES_texture_float_linear") || (console.log("no linear pixelformat,switching to nearest"), this._options.filter = M.FILTER_NEAREST, this.setFilter(this._options.filter)), e = this._cgl.gl.R11F_G11F_B10F)), this._options.multisampling && this._options.multisamplingSamples ? this._cgl.gl.renderbufferStorageMultisample(this._cgl.gl.RENDERBUFFER, this._options.multisamplingSamples, e, this._width, this._height) : this._cgl.gl.renderbufferStorage(this._cgl.gl.RENDERBUFFER, e, this._width, this._height), this._cgl.gl.framebufferRenderbuffer(this._cgl.gl.FRAMEBUFFER, this._cgl.gl.COLOR_ATTACHMENT0 + i, this._cgl.gl.RENDERBUFFER, t), this._colorRenderbuffers[i] = t
            }
            for (this._cgl.gl.bindFramebuffer(this._cgl.gl.FRAMEBUFFER, this._textureFrameBuffer), i = 0; i < this._numRenderBuffers; i++) this._cgl.gl.framebufferTexture2D(this._cgl.gl.FRAMEBUFFER, this._cgl.gl.COLOR_ATTACHMENT0 + i, this._cgl.gl.TEXTURE_2D, this._colorTextures[i].tex, 0);
            this._options.depth && this._cgl.gl.framebufferTexture2D(this._cgl.gl.FRAMEBUFFER, this._cgl.gl.DEPTH_ATTACHMENT, this._cgl.gl.TEXTURE_2D, this._textureDepth.tex, 0), this._cgl.gl.bindFramebuffer(this._cgl.gl.FRAMEBUFFER, this._frameBuffer);
            let r = this._cgl.gl.DEPTH_COMPONENT32F;
            for (this._cgl.glSlowRenderer && (r = this._cgl.gl.DEPTH_COMPONENT16), s && (this._textureDepth.setSize(this._width, this._height), this._depthRenderbuffer = this._cgl.gl.createRenderbuffer(), this._cgl.gl.bindRenderbuffer(this._cgl.gl.RENDERBUFFER, this._depthRenderbuffer), this._options.isFloatingPointTexture, this._options.multisampling ? this._cgl.gl.renderbufferStorageMultisample(this._cgl.gl.RENDERBUFFER, this._options.multisamplingSamples, r, this._width, this._height) : this._cgl.gl.renderbufferStorage(this._cgl.gl.RENDERBUFFER, r, this._width, this._height), this._cgl.gl.framebufferRenderbuffer(this._cgl.gl.FRAMEBUFFER, this._cgl.gl.DEPTH_ATTACHMENT, this._cgl.gl.RENDERBUFFER, this._depthRenderbuffer)), this._drawTargetArray.length = 0, i = 0; i < this._numRenderBuffers; i++) this._drawTargetArray.push(this._cgl.gl.COLOR_ATTACHMENT0 + i);
            this._cgl.gl.isFramebuffer(this._textureFrameBuffer) || this._log.warn("invalid framebuffer");
            const n = this._cgl.gl.checkFramebufferStatus(this._cgl.gl.FRAMEBUFFER);
            if (n != this._cgl.gl.FRAMEBUFFER_COMPLETE) switch (this._log.error("framebuffer incomplete: " + this.name, this), n) {
                case this._cgl.gl.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:
                    throw this._log.warn("FRAMEBUFFER_INCOMPLETE_ATTACHMENT...", this), new Error("Incomplete framebuffer: FRAMEBUFFER_INCOMPLETE_ATTACHMENT");
                case this._cgl.gl.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:
                    throw this._log.warn("FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT"), new Error("Incomplete framebuffer: FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT");
                case this._cgl.gl.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:
                    throw this._log.warn("FRAMEBUFFER_INCOMPLETE_DIMENSIONS"), new Error("Incomplete framebuffer: FRAMEBUFFER_INCOMPLETE_DIMENSIONS");
                case this._cgl.gl.FRAMEBUFFER_UNSUPPORTED:
                    throw this._log.warn("FRAMEBUFFER_UNSUPPORTED"), new Error("Incomplete framebuffer: FRAMEBUFFER_UNSUPPORTED");
                default:
                    throw this.valid = !1, this._log.warn("incomplete framebuffer", n, this._frameBuffer), this._cgl.printError(), this._cgl.exitError("Framebuffer incomplete..."), this._frameBuffer = null, new Error("Incomplete framebuffer: " + n)
            }
            this._cgl.gl.bindFramebuffer(this._cgl.gl.FRAMEBUFFER, null), this._cgl.gl.bindRenderbuffer(this._cgl.gl.RENDERBUFFER, null)
        }, B.prototype.renderStart = function() {
            if (this._disposed) return this._log.warn("disposed framebuffer renderStart...");
            this._cgl.checkFrameStarted("fb2 renderstart"), this._cgl.pushModelMatrix(), this._cgl.gl.bindFramebuffer(this._cgl.gl.FRAMEBUFFER, this._frameBuffer), this._cgl.pushGlFrameBuffer(this._frameBuffer), this._cgl.pushFrameBuffer(this), this._cgl.pushPMatrix(), this._cgl.pushViewPort(0, 0, this._width, this._height), this._cgl.gl.drawBuffers(this._drawTargetArray), this._options.clear && (this._cgl.gl.clearColor(0, 0, 0, 0), this._cgl.gl.clear(this._cgl.gl.COLOR_BUFFER_BIT | this._cgl.gl.DEPTH_BUFFER_BIT))
        }, B.prototype.clear = function() {
            this._numRenderBuffers <= 1 ? (this._cgl.gl.bindFramebuffer(this._cgl.gl.READ_FRAMEBUFFER, this._frameBuffer), this._cgl.gl.bindFramebuffer(this._cgl.gl.DRAW_FRAMEBUFFER, this._textureFrameBuffer)) : this._cgl.gl.bindFramebuffer(this._cgl.gl.FRAMEBUFFER, this._frameBuffer), this._cgl.gl.drawBuffers(this._drawTargetArray);
            for (let t = 0; t < this._numRenderBuffers; t++) this._cgl.gl.framebufferTexture2D(this._cgl.gl.FRAMEBUFFER, this._cgl.gl.COLOR_ATTACHMENT0 + t, this._cgl.gl.TEXTURE_2D, this._colorTextures[t].tex, 0), this._cgl.gl.clearBufferfv(this._cgl.gl.COLOR, t, [0, 0, 0, 0]);
            this._cgl.gl.bindFramebuffer(this._cgl.gl.FRAMEBUFFER, null)
        }, B.prototype.renderEnd = function() {
            if (this._disposed) return this._log.warn("disposed framebuffer renderEnd...");
            if (this._cgl.popPMatrix(), this._cgl.profileData.profileFramebuffer++, this._numRenderBuffers <= 1) this._cgl.gl.bindFramebuffer(this._cgl.gl.READ_FRAMEBUFFER, this._frameBuffer), this._cgl.gl.bindFramebuffer(this._cgl.gl.DRAW_FRAMEBUFFER, this._textureFrameBuffer), this._cgl.gl.clearBufferfv(this._cgl.gl.COLOR, 0, [0, 0, 0, 1]), this._cgl.gl.blitFramebuffer(0, 0, this._width, this._height, 0, 0, this._width, this._height, this._cgl.gl.COLOR_BUFFER_BIT | this._cgl.gl.DEPTH_BUFFER_BIT, this._cgl.gl.NEAREST);
            else {
                this._cgl.gl.bindFramebuffer(this._cgl.gl.FRAMEBUFFER, this.Framebuffer2BlittingFramebuffer), this._cgl.gl.framebufferRenderbuffer(this._cgl.gl.FRAMEBUFFER, this._cgl.gl.DEPTH_ATTACHMENT, this._cgl.gl.RENDERBUFFER, this._depthRenderbuffer), this._cgl.gl.bindFramebuffer(this._cgl.gl.FRAMEBUFFER, this.Framebuffer2FinalFramebuffer), this._cgl.gl.framebufferTexture2D(this._cgl.gl.FRAMEBUFFER, this._cgl.gl.DEPTH_ATTACHMENT, this._cgl.gl.TEXTURE_2D, this._textureDepth.tex, 0);
                for (let t = 0; t < this._numRenderBuffers; t++) {
                    this._cgl.gl.bindFramebuffer(this._cgl.gl.FRAMEBUFFER, this.Framebuffer2BlittingFramebuffer), this._cgl.gl.framebufferRenderbuffer(this._cgl.gl.FRAMEBUFFER, this._cgl.gl.COLOR_ATTACHMENT0, this._cgl.gl.RENDERBUFFER, this._colorRenderbuffers[t]), this._cgl.gl.bindFramebuffer(this._cgl.gl.FRAMEBUFFER, this.Framebuffer2FinalFramebuffer), this._cgl.gl.framebufferTexture2D(this._cgl.gl.FRAMEBUFFER, this._cgl.gl.COLOR_ATTACHMENT0, this._cgl.gl.TEXTURE_2D, this._colorTextures[t].tex, 0), this._cgl.gl.bindFramebuffer(this._cgl.gl.FRAMEBUFFER, null), this._cgl.gl.bindFramebuffer(this._cgl.gl.READ_FRAMEBUFFER, this.Framebuffer2BlittingFramebuffer), this._cgl.gl.bindFramebuffer(this._cgl.gl.DRAW_FRAMEBUFFER, this.Framebuffer2FinalFramebuffer);
                    let e = this._cgl.gl.COLOR_BUFFER_BIT;
                    0 == t && (e |= this._cgl.gl.DEPTH_BUFFER_BIT), this._cgl.gl.blitFramebuffer(0, 0, this._width, this._height, 0, 0, this._width, this._height, e, this._cgl.gl.NEAREST)
                }
            }
            if (this._cgl.gl.bindFramebuffer(this._cgl.gl.FRAMEBUFFER, this._cgl.popGlFrameBuffer()), this._cgl.popFrameBuffer(), this._cgl.popModelMatrix(), this._cgl.popViewPort(), this._colorTextures[0].filter == M.FILTER_MIPMAP)
                for (let t = 0; t < this._numRenderBuffers; t++) this._cgl.gl.bindTexture(this._cgl.gl.TEXTURE_2D, this._colorTextures[t].tex), this._colorTextures[t].updateMipMap(), this._cgl.gl.bindTexture(this._cgl.gl.TEXTURE_2D, null)
        };
        const U = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
            L = new Uint8Array(256);
        for (let t = 0; t < U.length; t++) L[U.charCodeAt(t)] = t;
        const k = L,
            D = function(t) {
                t.buffer && (t = t.buffer);
                let e, i = new Uint8Array(t),
                    s = i.length,
                    r = "";
                for (e = 0; e < s; e += 3) r += U[i[e] >> 2], r += U[(3 & i[e]) << 4 | i[e + 1] >> 4], r += U[(15 & i[e + 1]) << 2 | i[e + 2] >> 6], r += U[63 & i[e + 2]];
                return s % 3 == 2 ? r = r.substring(0, r.length - 1) + "=" : s % 3 == 1 && (r = r.substring(0, r.length - 2) + "=="), r
            },
            V = function(t) {
                let e, i, s, r, n, o = .75 * t.length,
                    a = t.length,
                    h = 0;
                "=" === t[t.length - 1] && (o--, "=" === t[t.length - 2] && o--);
                let l = new ArrayBuffer(o),
                    c = new Uint8Array(l);
                for (e = 0; e < a; e += 4) i = k[t.charCodeAt(e)], s = k[t.charCodeAt(e + 1)], r = k[t.charCodeAt(e + 2)], n = k[t.charCodeAt(e + 3)], c[h++] = i << 2 | s >> 4, c[h++] = (15 & s) << 4 | r >> 2, c[h++] = (3 & r) << 6 | 63 & n;
                return l
            };
        class G {
            constructor(t) {
                this._init(), this._first = !0, this._wireMesh = null, t && this.apply(t)
            }
            _init() {
                this._max = [-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE], this._min = [Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE], this._center = [0, 0, 0], this._size = [0, 0, 0], this._maxAxis = 0, this._first = !0
            }
            get maxAxis() {
                return this._maxAxis || 1
            }
            get size() {
                return this._size
            }
            get center() {
                return this._center
            }
            get x() {
                return this._center[0]
            }
            get y() {
                return this._center[1]
            }
            get z() {
                return this._center[2]
            }
            get minX() {
                return this._min[0]
            }
            get minY() {
                return this._min[1]
            }
            get minZ() {
                return this._min[2]
            }
            get maxX() {
                return this._max[0]
            }
            get maxY() {
                return this._max[1]
            }
            get maxZ() {
                return this._max[2]
            }
            apply(t, e) {
                if (t) {
                    if (t instanceof G) {
                        const e = t;
                        this.applyPos(e.maxX, e.maxY, e.maxZ), this.applyPos(e.minX, e.minY, e.minZ)
                    } else
                        for (let e = 0; e < t.vertices.length; e += 3) this.applyPos(t.vertices[e], t.vertices[e + 1], t.vertices[e + 2]);
                    this.calcCenterSize()
                }
            }
            copy() {
                return new G(this)
            }
            get changed() {
                return !(this._max[0] == -Number.MAX_VALUE && this._max[1] == -Number.MAX_VALUE && this._max[2] == -Number.MAX_VALUE)
            }
            applyPos(t, e, i) {
                if (t != Number.MAX_VALUE && t != -Number.MAX_VALUE && e != Number.MAX_VALUE && e != -Number.MAX_VALUE && i != Number.MAX_VALUE && i != -Number.MAX_VALUE && CABLES.UTILS.isNumeric(t) && CABLES.UTILS.isNumeric(e) && CABLES.UTILS.isNumeric(i)) {
                    if (this._first) return this._max[0] = t, this._max[1] = e, this._max[2] = i, this._min[0] = t, this._min[1] = e, this._min[2] = i, void(this._first = !1);
                    this._max[0] = Math.max(this._max[0], t), this._max[1] = Math.max(this._max[1], e), this._max[2] = Math.max(this._max[2], i), this._min[0] = Math.min(this._min[0], t), this._min[1] = Math.min(this._min[1], e), this._min[2] = Math.min(this._min[2], i)
                }
            }
            calcCenterSize() {
                this._first || (this._size[0] = this._max[0] - this._min[0], this._size[1] = this._max[1] - this._min[1], this._size[2] = this._max[2] - this._min[2], this._center[0] = (this._min[0] + this._max[0]) / 2, this._center[1] = (this._min[1] + this._max[1]) / 2, this._center[2] = (this._min[2] + this._max[2]) / 2, this._maxAxis = Math.max(this._size[2], Math.max(this._size[0], this._size[1])))
            }
            mulMat4(t) {
                this._first && (this._max[0] = 0, this._max[1] = 0, this._max[2] = 0, this._min[0] = 0, this._min[1] = 0, this._min[2] = 0, this._first = !1), vec3.transformMat4(this._max, this._max, t), vec3.transformMat4(this._min, this._min, t), this.calcCenterSize()
            }
            render(t, e) {
                this._wireMesh || (this._wireMesh = new CGL.WireCube(t)), t.pushModelMatrix(), mat4.translate(t.mMatrix, t.mMatrix, this._center), this._wireMesh.render(t, this._size[0] / 2, this._size[1] / 2, this._size[2] / 2), t.popModelMatrix()
            }
        }
        const H = function(t) {
            this.name = t || "unknown", this._log = new r("cgl_geometry"), this.faceVertCount = 3, this.glPrimitive = null, this._attributes = {}, this._vertices = [], this.verticesIndices = [], this.isGeometry = !0, this.morphTargets = [], Object.defineProperty(this, "vertices", {
                get() {
                    return this._vertices
                },
                set(t) {
                    this.setVertices(t)
                }
            }), Object.defineProperty(this, "texCoords", {
                get() {
                    const t = this.getAttribute("texCoords");
                    return t ? t.data : []
                },
                set(t) {
                    this.setAttribute("texCoords", t, 2)
                }
            }), Object.defineProperty(this, "vertexNormals", {
                get() {
                    const t = this.getAttribute("vertexNormals");
                    return t ? t.data : []
                },
                set(t) {
                    this.setAttribute("vertexNormals", t, 3)
                }
            }), Object.defineProperty(this, "tangents", {
                get() {
                    const t = this.getAttribute("tangents");
                    return t ? t.data : []
                },
                set(t) {
                    this.setAttribute("tangents", t, 3)
                }
            }), Object.defineProperty(this, "biTangents", {
                get() {
                    const t = this.getAttribute("biTangents");
                    return t ? t.data : []
                },
                set(t) {
                    this.setAttribute("biTangents", t, 3)
                }
            }), Object.defineProperty(this, "vertexColors", {
                get() {
                    const t = this.getAttribute("vertexColors");
                    return t ? t.data : []
                },
                set(t) {
                    this.setAttribute("vertexColors", t, 4)
                }
            })
        };
        H.prototype.clear = function() {
            this._vertices = new Float32Array([]), this.verticesIndices = [], this.texCoords = new Float32Array([]), this.vertexNormals = new Float32Array([]), this.tangents = [], this.biTangents = [], this._attributes = {}
        }, H.prototype.getAttributes = function() {
            return this._attributes
        }, H.prototype.getAttribute = function(t) {
            for (const e in this._attributes)
                if (this._attributes[e].name == t) return this._attributes[e];
            return null
        }, H.prototype.setAttribute = function(t, e, i) {
            let s = "";
            (!i || i > 4) && (console.log("itemsize wrong?", i, t), this._log.stack("itemsize"), i = 3), 1 == i ? s = "float" : 2 == i ? s = "vec2" : 3 == i ? s = "vec3" : 4 == i && (s = "vec4");
            const r = {
                name: t,
                data: e,
                itemSize: i,
                type: s
            };
            this._attributes[t] = r
        }, H.prototype.copyAttribute = function(t, e) {
            const i = this.getAttribute(t);
            e.setAttribute(t, new Float32Array(i.data), i.itemSize)
        }, H.prototype.setVertices = function(t) {
            t instanceof Float32Array ? this._vertices = t : this._vertices = new Float32Array(t)
        }, H.prototype.setTexCoords = function(t) {
            t instanceof Float32Array ? this.texCoords = t : this.texCoords = new Float32Array(t)
        }, H.prototype.calcNormals = function(t) {
            const e = {
                smooth: t
            };
            this.calculateNormals(e)
        }, H.prototype.flipNormals = function(t, e, i) {
            let s = vec3.create();
            null == t && (t = 1), null == e && (e = 1), null == i && (i = 1);
            for (let r = 0; r < this.vertexNormals.length; r += 3) vec3.set(s, this.vertexNormals[r + 0], this.vertexNormals[r + 1], this.vertexNormals[r + 2]), s[0] *= -t, s[1] *= -e, s[2] *= -i, vec3.normalize(s, s), this.vertexNormals[r + 0] = s[0], this.vertexNormals[r + 1] = s[1], this.vertexNormals[r + 2] = s[2]
        }, H.prototype.getNumTriangles = function() {
            return this.verticesIndices && this.verticesIndices.length ? this.verticesIndices.length / 3 : this.vertices.length / 3
        }, H.prototype.flipVertDir = function() {
            const t = [];
            t.length = this.verticesIndices.length;
            for (let e = 0; e < this.verticesIndices.length; e += 3) t[e] = this.verticesIndices[e + 2], t[e + 1] = this.verticesIndices[e + 1], t[e + 2] = this.verticesIndices[e];
            this.verticesIndices = t
        }, H.prototype.setPointVertices = function(t) {
            if (t.length % 3 == 0) {
                t instanceof Float32Array ? this.vertices = t : this.vertices = new Float32Array(t), this.texCoords instanceof Float32Array || (this.texCoords = new Float32Array(t.length / 3 * 2)), this.verticesIndices.length = t.length / 3;
                for (let e = 0; e < t.length / 3; e++) this.verticesIndices[e] = e, this.texCoords[2 * e] = 0, this.texCoords[2 * e + 1] = 0
            } else this._log.error("SetPointVertices: Array must be multiple of three.")
        }, H.prototype.merge = function(t) {
            if (!t) return;
            if (this.isIndexed() != t.isIndexed() && (this.isIndexed() && this.unIndex(!1, !0), t.isIndexed())) {
                const e = t.copy();
                e.unIndex(!1, !0), t = e
            }
            const e = this.verticesIndices.length,
                i = this._vertices.length / 3;
            this.verticesIndices.length = this.verticesIndices.length + t.verticesIndices.length;
            for (let s = 0; s < t.verticesIndices.length; s++) this.verticesIndices[e + s] = t.verticesIndices[s] + i;
            this.vertices = l.float32Concat(this._vertices, t.vertices), this.texCoords = l.float32Concat(this.texCoords, t.texCoords), this.vertexNormals = l.float32Concat(this.vertexNormals, t.vertexNormals), this.tangents = l.float32Concat(this.tangents, t.tangents), this.biTangents = l.float32Concat(this.biTangents, t.biTangents)
        }, H.prototype.copy = function() {
            const t = new H(this.name + " copy");
            if (t.faceVertCount = this.faceVertCount, t.glPrimitive = this.glPrimitive, t.setVertices(this._vertices.slice(0)), this.verticesIndices) {
                t.verticesIndices.length = this.verticesIndices.length;
                for (let e = 0; e < this.verticesIndices.length; e++) t.verticesIndices[e] = this.verticesIndices[e]
            }
            for (let e in this._attributes) this.copyAttribute(e, t);
            t.morphTargets.length = this.morphTargets.length;
            for (let e = 0; e < this.morphTargets.length; e++) t.morphTargets[e] = this.morphTargets[e];
            return t
        }, H.prototype.calculateNormals = function(t) {
            !1 === (t = t || {}).smooth && this.unIndex();
            const e = vec3.create(),
                i = vec3.create(),
                s = vec3.create();

            function r(r) {
                return vec3.subtract(e, r[0], r[1]), vec3.subtract(i, r[0], r[2]), vec3.cross(s, e, i), vec3.normalize(s, s), t && t.forceZUp && s[2] < 0 && (s[0] *= -1, s[1] *= -1, s[2] *= -1), s
            }
            this.getVertexVec = function(t) {
                const e = [0, 0, 0];
                return e[0] = this.vertices[3 * t + 0], e[1] = this.vertices[3 * t + 1], e[2] = this.vertices[3 * t + 2], e
            }, this.vertexNormals instanceof Float32Array && this.vertexNormals.length == this.vertices.length || (this.vertexNormals = new Float32Array(this.vertices.length));
            for (let t = 0; t < this.vertices.length; t++) this.vertexNormals[t] = 0;
            if (this.isIndexed()) {
                const t = [];
                t.length = Math.floor(this.verticesIndices.length / 3);
                for (let e = 0; e < this.verticesIndices.length; e += 3) {
                    const i = [this.getVertexVec(this.verticesIndices[e + 0]), this.getVertexVec(this.verticesIndices[e + 1]), this.getVertexVec(this.verticesIndices[e + 2])];
                    t[e / 3] = r(i), this.vertexNormals[3 * this.verticesIndices[e + 0] + 0] += t[e / 3][0], this.vertexNormals[3 * this.verticesIndices[e + 0] + 1] += t[e / 3][1], this.vertexNormals[3 * this.verticesIndices[e + 0] + 2] += t[e / 3][2], this.vertexNormals[3 * this.verticesIndices[e + 1] + 0] += t[e / 3][0], this.vertexNormals[3 * this.verticesIndices[e + 1] + 1] += t[e / 3][1], this.vertexNormals[3 * this.verticesIndices[e + 1] + 2] += t[e / 3][2], this.vertexNormals[3 * this.verticesIndices[e + 2] + 0] += t[e / 3][0], this.vertexNormals[3 * this.verticesIndices[e + 2] + 1] += t[e / 3][1], this.vertexNormals[3 * this.verticesIndices[e + 2] + 2] += t[e / 3][2]
                }
                for (let t = 0; t < this.verticesIndices.length; t += 3)
                    for (let e = 0; e < 3; e++) {
                        const i = [this.vertexNormals[3 * this.verticesIndices[t + e] + 0], this.vertexNormals[3 * this.verticesIndices[t + e] + 1], this.vertexNormals[3 * this.verticesIndices[t + e] + 2]];
                        vec3.normalize(i, i), this.vertexNormals[3 * this.verticesIndices[t + e] + 0] = i[0], this.vertexNormals[3 * this.verticesIndices[t + e] + 1] = i[1], this.vertexNormals[3 * this.verticesIndices[t + e] + 2] = i[2]
                    }
            } else {
                const t = [];
                for (let e = 0; e < this.vertices.length; e += 9) {
                    const i = r([
                        [this.vertices[e + 0], this.vertices[e + 1], this.vertices[e + 2]],
                        [this.vertices[e + 3], this.vertices[e + 4], this.vertices[e + 5]],
                        [this.vertices[e + 6], this.vertices[e + 7], this.vertices[e + 8]]
                    ]);
                    t.push(i[0], i[1], i[2], i[0], i[1], i[2], i[0], i[1], i[2])
                }
                this.vertexNormals = t
            }
        }, H.prototype.calcTangentsBitangents = function() {
            if (!this.vertices.length) return;
            if (!this.vertexNormals.length) return;
            if (!this.texCoords.length) {
                const t = this.vertices.length / 3 * 2;
                this.texCoords = new Float32Array(t);
                for (let e = 0; e < t; e += 1) this.texCoords[e] = 0
            }
            if (!this.verticesIndices || !this.verticesIndices.length) return;
            if (this.verticesIndices.length % 3 != 0) return void this._log.error("Vertex indices mismatch!");
            const t = this.verticesIndices.length / 3,
                e = this.vertices.length / 3;
            this.tangents = new Float32Array(this.vertexNormals.length), this.biTangents = new Float32Array(this.vertexNormals.length);
            const i = [];
            i.length = 2 * e;
            const s = vec3.create(),
                r = vec3.create(),
                n = vec3.create(),
                o = vec2.create(),
                a = vec2.create(),
                h = vec2.create(),
                l = vec3.create(),
                c = vec3.create();
            for (let u = 0; u < t; u += 1) {
                const t = this.verticesIndices[3 * u],
                    _ = this.verticesIndices[3 * u + 1],
                    p = this.verticesIndices[3 * u + 2];
                vec3.set(s, this.vertices[3 * t], this.vertices[3 * t + 1], this.vertices[3 * t + 2]), vec3.set(r, this.vertices[3 * _], this.vertices[3 * _ + 1], this.vertices[3 * _ + 2]), vec3.set(n, this.vertices[3 * p], this.vertices[3 * p + 1], this.vertices[3 * p + 2]), vec2.set(o, this.texCoords[2 * t], this.texCoords[2 * t + 1]), vec2.set(a, this.texCoords[2 * _], this.texCoords[2 * _ + 1]), vec2.set(h, this.texCoords[2 * p], this.texCoords[2 * p + 1]);
                const g = r[0] - s[0],
                    d = n[0] - s[0],
                    f = r[1] - s[1],
                    m = n[1] - s[1],
                    E = r[2] - s[2],
                    T = n[2] - s[2],
                    A = a[0] - o[0],
                    b = h[0] - o[0],
                    x = a[1] - o[1],
                    v = h[1] - o[1],
                    y = 1 / (A * v - b * x);
                vec3.set(l, (v * g - x * d) * y, (v * f - x * m) * y, (v * E - x * T) * y), vec3.set(c, (A * d - b * g) * y, (A * m - b * f) * y, (A * T - b * E) * y), i[t] = l, i[_] = l, i[p] = l, i[t + e] = c, i[_ + e] = c, i[p + e] = c
            }
            const u = vec3.create(),
                _ = vec3.create(),
                p = vec3.create(),
                g = vec3.create(),
                d = vec3.create(),
                f = vec3.create(),
                m = vec3.create(),
                E = vec3.create();
            for (let t = 0; t < e; t += 1) {
                if (!i[t]) continue;
                vec3.set(u, this.vertexNormals[3 * t], this.vertexNormals[3 * t + 1], this.vertexNormals[3 * t + 2]), vec3.set(_, i[t][0], i[t][1], i[t][2]);
                const s = vec3.dot(u, _);
                vec3.scale(d, u, s), vec3.subtract(f, _, d), vec3.normalize(E, f), vec3.cross(m, u, _), vec3.dot(m, i[t + e]);
                const r = 1;
                vec3.scale(p, E, 1 / r), vec3.cross(g, u, p), this.tangents[3 * t + 0] = p[0], this.tangents[3 * t + 1] = p[1], this.tangents[3 * t + 2] = p[2], this.biTangents[3 * t + 0] = g[0], this.biTangents[3 * t + 1] = g[1], this.biTangents[3 * t + 2] = g[2]
            }
        }, H.prototype.isIndexed = function() {
            return 0 == this._vertices.length || 0 != this.verticesIndices.length
        }, H.prototype.unIndex = function(t, e) {
            const i = [],
                s = [];
            let r = 0;
            for (let t in this._attributes) {
                const e = this._attributes[t];
                let i = [];
                for (let t = 0; t < this.verticesIndices.length; t += 3)
                    for (let s = 0; s < 3; s++) 3 == e.itemSize ? i.push(e.data[3 * this.verticesIndices[t + s] + 0], e.data[3 * this.verticesIndices[t + s] + 1], e.data[3 * this.verticesIndices[t + s] + 2]) : 4 == e.itemSize ? i.push(e.data[4 * this.verticesIndices[t + s] + 0], e.data[4 * this.verticesIndices[t + s] + 1], e.data[4 * this.verticesIndices[t + s] + 2], e.data[4 * this.verticesIndices[t + s] + 3]) : 2 == e.itemSize ? i.push(e.data[2 * this.verticesIndices[t + s] + 0], e.data[2 * this.verticesIndices[t + s] + 1]) : 1 == e.itemSize ? i.push(e.data[this.verticesIndices[t + s]]) : console.log("unknown attr", e);
                this.setAttribute(e.name, i, e.itemSize)
            }
            for (let t = 0; t < this.verticesIndices.length; t += 3) i.push(this.vertices[3 * this.verticesIndices[t + 0] + 0], this.vertices[3 * this.verticesIndices[t + 0] + 1], this.vertices[3 * this.verticesIndices[t + 0] + 2]), s.push(r), r++, i.push(this.vertices[3 * this.verticesIndices[t + 1] + 0], this.vertices[3 * this.verticesIndices[t + 1] + 1], this.vertices[3 * this.verticesIndices[t + 1] + 2]), s.push(r), r++, i.push(this.vertices[3 * this.verticesIndices[t + 2] + 0], this.vertices[3 * this.verticesIndices[t + 2] + 1], this.vertices[3 * this.verticesIndices[t + 2] + 2]), s.push(r), r++;
            this.vertices = i, this.verticesIndices = [], t && (this.verticesIndices = s), e || this.calculateNormals()
        }, H.prototype.calcBarycentric = function() {
            let t = [];
            t.length = this.vertices.length;
            for (let e = 0; e < this.vertices.length; e++) t[e] = 0;
            let e = 0;
            for (let i = 0; i < this.vertices.length; i += 3) t[i + e] = 1, e++, 3 == e && (e = 0);
            this.setAttribute("attrBarycentric", t, 3)
        }, H.prototype.getBounds = function() {
            return new G(this)
        }, H.prototype.center = function(t, e, i) {
            void 0 === t && (t = !0, e = !0, i = !0);
            let s = 0;
            const r = this.getBounds(),
                n = [r.minX + (r.maxX - r.minX) / 2, r.minY + (r.maxY - r.minY) / 2, r.minZ + (r.maxZ - r.minZ) / 2];
            for (s = 0; s < this.vertices.length; s += 3) this.vertices[s + 0] == this.vertices[s + 0] && (t && (this.vertices[s + 0] -= n[0]), e && (this.vertices[s + 1] -= n[1]), i && (this.vertices[s + 2] -= n[2]));
            return n
        }, H.prototype.mapTexCoords2d = function() {
            const t = this.getBounds(),
                e = this.vertices.length / 3;
            this.texCoords = new Float32Array(2 * e);
            for (let i = 0; i < e; i++) {
                const e = this.vertices[3 * i + 0],
                    s = this.vertices[3 * i + 1];
                this.texCoords[2 * i + 0] = e / (t.maxX - t.minX) + .5, this.texCoords[2 * i + 1] = 1 - s / (t.maxY - t.minY) + .5
            }
        }, H.prototype.getInfoOneLine = function() {
            let t = "";
            return 3 == this.faceVertCount && this.verticesIndices ? t += this.verticesIndices.length / 3 : t += 0, t += " tris ", this.vertices ? t += this.vertices.length / 3 : t += 0, t += " verts", t
        }, H.prototype.getInfo = function() {
            const t = {};
            return 3 == this.faceVertCount && this.verticesIndices ? t.numFaces = this.verticesIndices.length / 3 : t.numFaces = 0, this.verticesIndices && this.verticesIndices.length && (t.indices = this.verticesIndices.length), this.vertices ? t.numVerts = this.vertices.length / 3 : t.numVerts = 0, this.vertexNormals ? t.numNormals = this.vertexNormals.length / 3 : t.numNormals = 0, this.texCoords ? t.numTexCoords = this.texCoords.length / 2 : t.numTexCoords = 0, this.tangents ? t.numTangents = this.tangents.length / 3 : t.numTangents = 0, this.biTangents ? t.numBiTangents = this.biTangents.length / 3 : t.numBiTangents = 0, this.biTangents ? t.numBiTangents = this.biTangents.length / 3 : t.numBiTangents = 0, this.vertexColors ? t.numVertexColors = this.vertexColors.length / 4 : t.numVertexColors = 0, this.getAttributes() ? t.numAttribs = Object.keys(this.getAttributes()).length : t.numAttribs = 0, t.isIndexed = this.isIndexed(), t
        }, H.buildFromFaces = function(t, e, i) {
            const s = [],
                r = [];
            for (let e = 0; e < t.length; e += 3) {
                const n = t[e + 0],
                    o = t[e + 1],
                    a = t[e + 2],
                    h = [-1, -1, -1];
                if (i)
                    for (let t = 0; t < s.length; t += 3) s[t + 0] == n[0] && s[t + 1] == n[1] && s[t + 2] == n[2] && (h[0] = t / 3), s[t + 0] == o[0] && s[t + 1] == o[1] && s[t + 2] == o[2] && (h[1] = t / 3), s[t + 0] == a[0] && s[t + 1] == a[1] && s[t + 2] == a[2] && (h[2] = t / 3); - 1 == h[0] && (s.push(n[0], n[1], n[2]), h[0] = (s.length - 1) / 3), -1 == h[1] && (s.push(o[0], o[1], o[2]), h[1] = (s.length - 1) / 3), -1 == h[2] && (s.push(a[0], a[1], a[2]), h[2] = (s.length - 1) / 3), r.push(parseInt(h[0], 10)), r.push(parseInt(h[1], 10)), r.push(parseInt(h[2], 10))
            }
            const n = new H(e);
            return n.name = e, n.vertices = s, n.verticesIndices = r, n
        }, H.json2geom = function(t) {
            const e = new H("jsonMeshGeom");
            if (e.verticesIndices = [], e.vertices = t.vertices || [], e.vertexNormals = t.normals || [], e.vertexColors = t.colors || [], e.tangents = t.tangents || [], e.biTangents = t.bitangents || [], t.texturecoords && e.setTexCoords(t.texturecoords[0]), t.vertices_b64 && (e.vertices = new Float32Array(V(t.vertices_b64))), t.normals_b64 && (e.vertexNormals = new Float32Array(V(t.normals_b64))), t.tangents_b64 && (e.tangents = new Float32Array(V(t.tangents_b64))), t.bitangents_b64 && (e.biTangents = new Float32Array(V(t.bitangents_b64))), t.texturecoords_b64 && e.setTexCoords(new Float32Array(V(t.texturecoords_b64[0]))), t.faces_b64) e.verticesIndices = new Uint32Array(V(t.faces_b64));
            else {
                e.verticesIndices.length = 3 * t.faces.length;
                for (let i = 0; i < t.faces.length; i++) e.verticesIndices[3 * i] = t.faces[i][0], e.verticesIndices[3 * i + 1] = t.faces[i][1], e.verticesIndices[3 * i + 2] = t.faces[i][2]
            }
            return e
        };
        const z = function() {
                this._log = new r("eventtaget"), this._eventCallbacks = {}, this._logName = "", this._logEvents = !1, this._listeners = {}, CABLES.eventTargetProfile = CABLES.eventTargetProfile || {}, this.addEventListener = this.on = function(t, e, i) {
                    const s = {
                        id: (i || "") + CABLES.simpleId(),
                        name: t,
                        cb: e
                    };
                    return this._eventCallbacks[t] ? this._eventCallbacks[t].push(s) : this._eventCallbacks[t] = [s], this._listeners[s.id] = s, s.id
                }, this.hasEventListener = function(t, e) {
                    return t && !e ? !!this._listeners[t] : (this._log.warn("old eventtarget function haseventlistener!"), t && e && this._eventCallbacks[t] ? -1 != this._eventCallbacks[t].indexOf(e) : void 0)
                }, this.removeEventListener = this.off = function(t, e) {
                    if (null == t) return;
                    if (!e) {
                        const e = this._listeners[t];
                        if (!e) return void console.log("could not find event...");
                        let i = !0;
                        for (; i;) {
                            i = !1;
                            let s = -1;
                            for (let r = 0; r < this._eventCallbacks[e.name].length; r++) 0 === this._eventCallbacks[e.name][r].id.indexOf(t) && (i = !0, s = r); - 1 !== s && (this._eventCallbacks[e.name].splice(s, 1), delete this._listeners[t])
                        }
                        return
                    }
                    this._log.stack(" old function signature: removeEventListener! use listener id");
                    let i = null;
                    for (let s = 0; s < this._eventCallbacks[t].length; s++) this._eventCallbacks[t][s].cb == e && (i = s);
                    null !== i ? delete this._eventCallbacks[i] : this._log.warn("removeEventListener not found " + t)
                }, this.logEvents = function(t, e) {
                    this._logEvents = t, this._logName = e
                }, this.emitEvent = function(t, e, i, s, r, n, o) {
                    if (this._logEvents && console.log("[event] ", this._logName, t, this._eventCallbacks), this._eventCallbacks[t]) {
                        const a = [];
                        for (let e = 0; e < this._eventCallbacks[t].length; e++) a[t] || (a[t] = []), a[t].push(this._eventCallbacks[t][e]);
                        if (a[t])
                            for (let h = 0; h < a[t].length; h++)
                                if (a[t][h]) {
                                    const l = this.constructor.name + " " + t;
                                    CABLES.eventTargetProfile[l] = CABLES.eventTargetProfile[l] || {
                                        name: this.constructor.name,
                                        event: t,
                                        count: 0
                                    }, CABLES.eventTargetProfile[l].active = this._eventCallbacks[t].length, CABLES.eventTargetProfile[l].count++, a[t][h].cb(e, i, s, r, n, o)
                                }
                    } else this._logEvents && console.log("[event] has no event callback", t, this._eventCallbacks)
                }
            },
            W = function(t) {
                this.time = 0, this.value = 0, this.ui = null, this.onChange = null, this._easing = 0, this.bezTangIn = 0, this.bezTangOut = 0, this.cb = null, this.cbTriggered = !1, this.setEasing(n.EASING_LINEAR), this.set(t)
            };
        W.cubicSpline = function(t, e, i) {
            let s = t * t,
                r = s * t;
            return (2 * r - 3 * s + 1) * e.value + (r - 2 * s + t) * e.bezTangOut + (-2 * r + 3 * s) * i.value + (r - s) * i.bezTangIn
        }, W.easeCubicSpline = function(t, e) {
            return W.cubicSpline(t, this, e)
        }, W.linear = function(t, e, i) {
            return parseFloat(e.value) + parseFloat(i.value - e.value) * t
        }, W.easeLinear = function(t, e) {
            return W.linear(t, this, e)
        }, W.easeAbsolute = function(t, e) {
            return this.value
        }, W.easeExpoIn = function(t, e) {
            return t = function(t) {
                return Math.pow(2, 10 * (t - 1))
            }(t), W.linear(t, this, e)
        }, W.easeExpoOut = function(t, e) {
            return t = function(t) {
                return 1 - Math.pow(2, -10 * t)
            }(t), W.linear(t, this, e)
        }, W.easeExpoInOut = function(t, e) {
            return t = function(t) {
                return (t *= 2) < 1 ? t = .5 * Math.pow(2, 10 * (t - 1)) : (t--, t = .5 * (2 - Math.pow(2, -10 * t))), t
            }(t), W.linear(t, this, e)
        }, W.easeSinIn = function(t, e) {
            return t = -1 * Math.cos(t * Math.PI / 2) + 1, W.linear(t, this, e)
        }, W.easeSinOut = function(t, e) {
            return t = Math.sin(t * Math.PI / 2), W.linear(t, this, e)
        }, W.easeSinInOut = function(t, e) {
            return t = -.5 * (Math.cos(Math.PI * t) - 1), W.linear(t, this, e)
        }, W.easeCubicIn = function(t, e) {
            return t = function(t) {
                return t * (t * t)
            }(t), W.linear(t, this, e)
        }, W.easeInQuint = function(t, e) {
            return W.linear(t *= t * t * t * t, this, e)
        }, W.easeOutQuint = function(t, e) {
            return t = (t -= 1) * t * t * t * t + 1, W.linear(t, this, e)
        }, W.easeInOutQuint = function(t, e) {
            return (t /= .5) < 1 ? t *= .5 * t * t * t * t : t = .5 * ((t -= 2) * t * t * t * t + 2), W.linear(t, this, e)
        }, W.easeInQuart = function(t, e) {
            return W.linear(t *= t * t * t, this, e)
        }, W.easeOutQuart = function(t, e) {
            return t = -1 * ((t -= 1) * t * t * t - 1), W.linear(t, this, e)
        }, W.easeInOutQuart = function(t, e) {
            return (t /= .5) < 1 ? t *= .5 * t * t * t : t = -.5 * ((t -= 2) * t * t * t - 2), W.linear(t, this, e)
        }, W.bounce = function(t) {
            return (t /= 1) < 1 / 2.75 ? t *= 7.5625 * t : t = t < 2 / 2.75 ? 7.5625 * (t -= 1.5 / 2.75) * t + .75 : t < 2.5 / 2.75 ? 7.5625 * (t -= 2.25 / 2.75) * t + .9375 : 7.5625 * (t -= 2.625 / 2.75) * t + .984375, t
        }, W.easeInBounce = function(t, e) {
            return W.linear(W.bounce(t), this, e)
        }, W.easeOutBounce = function(t, e) {
            return W.linear(W.bounce(t), this, e)
        }, W.easeInElastic = function(t, e) {
            let i = 1.70158,
                s = 0,
                r = 1;
            return 0 === t ? t = 0 : 1 == (t /= 1) ? t = 1 : (s || (s = .3), r < Math.abs(1) ? (r = 1, i = s / 4) : i = s / (2 * Math.PI) * Math.asin(1 / r), t = -r * Math.pow(2, 10 * (t -= 1)) * Math.sin((1 * t - i) * (2 * Math.PI) / s) + 0), W.linear(t, this, e)
        }, W.easeOutElastic = function(t, e) {
            let i = 1.70158,
                s = 0,
                r = 1;
            return 0 === t ? t = 0 : 1 == (t /= 1) ? t = 1 : (s || (s = .3), r < Math.abs(1) ? (r = 1, i = s / 4) : i = s / (2 * Math.PI) * Math.asin(1 / r), t = r * Math.pow(2, -10 * t) * Math.sin((1 * t - i) * (2 * Math.PI) / s) + 1 + 0), W.linear(t, this, e)
        }, W.easeInBack = function(t, e) {
            const i = 1.70158;
            return W.linear(t = t * t * ((i + 1) * t - i), this, e)
        }, W.easeOutBack = function(t, e) {
            const i = 1.70158;
            return t = (t = t / 1 - 1) * t * ((i + 1) * t + i) + 1, W.linear(t, this, e)
        }, W.easeInOutBack = function(t, e) {
            let i = 1.70158;
            return t = (t /= .5) < 1 ? t * t * ((1 + (i *= 1.525)) * t - i) * .5 : .5 * ((t -= 2) * t * ((1 + (i *= 1.525)) * t + i) + 2), W.linear(t, this, e)
        }, W.easeCubicOut = function(t, e) {
            return t = function(t) {
                return --t * t * t + 1
            }(t), W.linear(t, this, e)
        }, W.easeCubicInOut = function(t, e) {
            return t = function(t) {
                return (t *= 2) < 1 ? t *= .5 * t * t : t = .5 * ((t -= 2) * t * t + 2), t
            }(t), W.linear(t, this, e)
        }, W.easeSmoothStep = function(t, e) {
            const i = Math.max(0, Math.min(1, t));
            return W.linear(t = i * i * (3 - 2 * i), this, e)
        }, W.easeSmootherStep = function(t, e) {
            const i = Math.max(0, Math.min(1, (t - 0) / 1));
            return W.linear(t = i * i * i * (i * (6 * i - 15) + 10), this, e)
        }, W.prototype.setEasing = function(t) {
            this._easing = t, this._easing == n.EASING_LINEAR ? this.ease = W.easeLinear : this._easing == n.EASING_ABSOLUTE ? this.ease = W.easeAbsolute : this._easing == n.EASING_SMOOTHSTEP ? this.ease = W.easeSmoothStep : this._easing == n.EASING_SMOOTHERSTEP ? this.ease = W.easeSmootherStep : this._easing == n.EASING_CUBIC_IN ? this.ease = W.easeCubicIn : this._easing == n.EASING_CUBIC_OUT ? this.ease = W.easeCubicOut : this._easing == n.EASING_CUBIC_INOUT ? this.ease = W.easeCubicInOut : this._easing == n.EASING_EXPO_IN ? this.ease = W.easeExpoIn : this._easing == n.EASING_EXPO_OUT ? this.ease = W.easeExpoOut : this._easing == n.EASING_EXPO_INOUT ? this.ease = W.easeExpoInOut : this._easing == n.EASING_SIN_IN ? this.ease = W.easeSinIn : this._easing == n.EASING_SIN_OUT ? this.ease = W.easeSinOut : this._easing == n.EASING_SIN_INOUT ? this.ease = W.easeSinInOut : this._easing == n.EASING_BACK_OUT ? this.ease = W.easeOutBack : this._easing == n.EASING_BACK_IN ? this.ease = W.easeInBack : this._easing == n.EASING_BACK_INOUT ? this.ease = W.easeInOutBack : this._easing == n.EASING_ELASTIC_IN ? this.ease = W.easeInElastic : this._easing == n.EASING_ELASTIC_OUT ? this.ease = W.easeOutElastic : this._easing == n.EASING_ELASTIC_INOUT ? this.ease = W.easeElasticInOut : this._easing == n.EASING_BOUNCE_IN ? this.ease = W.easeInBounce : this._easing == n.EASING_BOUNCE_OUT ? this.ease = W.easeOutBounce : this._easing == n.EASING_QUART_OUT ? this.ease = W.easeOutQuart : this._easing == n.EASING_QUART_IN ? this.ease = W.easeInQuart : this._easing == n.EASING_QUART_INOUT ? this.ease = W.easeInOutQuart : this._easing == n.EASING_QUINT_OUT ? this.ease = W.easeOutQuint : this._easing == n.EASING_QUINT_IN ? this.ease = W.easeInQuint : this._easing == n.EASING_QUINT_INOUT ? this.ease = W.easeInOutQuint : this._easing == n.EASING_CUBICSPLINE ? this.ease = W.easeCubicSpline : (this._easing = n.EASING_LINEAR, this.ease = W.easeLinear)
        }, W.prototype.trigger = function() {
            this.cb(), this.cbTriggered = !0
        }, W.prototype.setValue = function(t) {
            this.value = t, null !== this.onChange && this.onChange()
        }, W.prototype.set = function(t) {
            t && (t.e && this.setEasing(t.e), t.cb && (this.cb = t.cb, this.cbTriggered = !1), t.b, t.hasOwnProperty("t") && (this.time = t.t), t.hasOwnProperty("time") && (this.time = t.time), t.hasOwnProperty("v") ? this.value = t.v : t.hasOwnProperty("value") && (this.value = t.value)), null !== this.onChange && this.onChange()
        }, W.prototype.getSerialized = function() {
            const t = {};
            return t.t = this.time, t.v = this.value, t.e = this._easing, t
        }, W.prototype.getEasing = function() {
            return this._easing
        };
        const Y = function(t) {
            z.apply(this), t = t || {}, this.keys = [], this.onChange = null, this.stayInTimeline = !1, this.loop = !1, this._log = new r("Anim"), this._lastKeyIndex = 0, this._cachedIndex = 0, this.name = t.name || null, this.defaultEasing = t.defaultEasing || n.EASING_LINEAR, this.onLooped = null, this._timesLooped = 0, this._needsSort = !1
        };
        Y.prototype.forceChangeCallback = function() {
            null !== this.onChange && this.onChange(), this.emitEvent("onChange", this)
        }, Y.prototype.getLoop = function() {
            return this.loop
        }, Y.prototype.setLoop = function(t) {
            this.loop = t, this.emitEvent("onChange", this)
        }, Y.prototype.hasEnded = function(t) {
            return 0 === this.keys.length || this.keys[this._lastKeyIndex].time <= t
        }, Y.prototype.isRising = function(t) {
            if (this.hasEnded(t)) return !1;
            const e = this.getKeyIndex(t);
            return this.keys[e].value < this.keys[e + 1].value
        }, Y.prototype.clearBefore = function(t) {
            const e = this.getValue(t),
                i = this.getKeyIndex(t);
            this.setValue(t, e), i > 1 && this.keys.splice(0, i), this._updateLastIndex()
        }, Y.prototype.clear = function(t) {
            let e = 0;
            t && (e = this.getValue(t)), this.keys.length = 0, this._updateLastIndex(), t && this.setValue(t, e), null !== this.onChange && this.onChange(), this.emitEvent("onChange", this)
        }, Y.prototype.sortKeys = function() {
            this.keys.sort(((t, e) => parseFloat(t.time) - parseFloat(e.time))), this._updateLastIndex(), this._needsSort = !1
        }, Y.prototype.getLength = function() {
            return 0 === this.keys.length ? 0 : this.keys[this.keys.length - 1].time
        }, Y.prototype.getKeyIndex = function(t) {
            let e = 0,
                i = 0;
            this._cachedIndex && this.keys.length > this._cachedIndex && t >= this.keys[this._cachedIndex].time && (i = this._cachedIndex);
            for (let s = i; s < this.keys.length; s++)
                if (t >= this.keys[s].time && (e = s), this.keys[s].time > t) return 0 != t && (this._cachedIndex = e), e;
            return e
        }, Y.prototype.setValue = function(t, e, i) {
            let s = null;
            if (0 == this.keys.length || t <= this.keys[this.keys.length - 1].time)
                for (let r = 0; r < this.keys.length; r++)
                    if (this.keys[r].time == t) {
                        s = this.keys[r], this.keys[r].setValue(e), this.keys[r].cb = i;
                        break
                    } return s || (s = new W({
                time: t,
                value: e,
                e: this.defaultEasing,
                cb: i
            }), this.keys.push(s), this._updateLastIndex()), this.onChange && this.onChange(), this.emitEvent("onChange", this), this._needsSort = !0, s
        }, Y.prototype.setKeyEasing = function(t, e) {
            this.keys[t] && (this.keys[t].setEasing(e), this.emitEvent("onChange", this))
        }, Y.prototype.getSerialized = function() {
            const t = {
                keys: []
            };
            t.loop = this.loop;
            for (let e = 0; e < this.keys.length; e++) t.keys.push(this.keys[e].getSerialized());
            return t
        }, Y.prototype.getKey = function(t) {
            const e = this.getKeyIndex(t);
            return this.keys[e]
        }, Y.prototype.getNextKey = function(t) {
            let e = this.getKeyIndex(t) + 1;
            return e >= this.keys.length && (e = this.keys.length - 1), this.keys[e]
        }, Y.prototype.isFinished = function(t) {
            return this.keys.length <= 0 || t > this.keys[this.keys.length - 1].time
        }, Y.prototype.isStarted = function(t) {
            return !(this.keys.length <= 0) && t >= this.keys[0].time
        }, Y.prototype.getValue = function(t) {
            if (0 === this.keys.length) return 0;
            if (this._needsSort && this.sortKeys(), !this.loop && t > this.keys[this._lastKeyIndex].time) return this.keys[this._lastKeyIndex].value;
            if (t < this.keys[0].time) return this.keys[0].value;
            this.loop && t > this.keys[this._lastKeyIndex].time && (t / this.keys[this._lastKeyIndex].time > this._timesLooped && (this._timesLooped++, this.onLooped && this.onLooped()), t = (t - this.keys[0].time) % (this.keys[this._lastKeyIndex].time - this.keys[0].time), t += this.keys[0].time);
            const e = this.getKeyIndex(t);
            if (e >= this._lastKeyIndex) return this.keys[this._lastKeyIndex].cb && !this.keys[this._lastKeyIndex].cbTriggered && this.keys[this._lastKeyIndex].trigger(), this.keys[this._lastKeyIndex].value;
            const i = e + 1,
                s = this.keys[e],
                r = this.keys[i];
            if (s.cb && !s.cbTriggered && s.trigger(), !r) return -1;
            const n = (t - s.time) / (r.time - s.time);
            return s.ease || this.log._warn("has no ease", s, r), s.ease(n, r)
        }, Y.prototype._updateLastIndex = function() {
            this._lastKeyIndex = this.keys.length - 1
        }, Y.prototype.addKey = function(t) {
            void 0 === t.time ? this.log.warn("key time undefined, ignoring!") : (this.keys.push(t), null !== this.onChange && this.onChange(), this.emitEvent("onChange", this)), this._updateLastIndex()
        }, Y.prototype.easingFromString = function(t) {
            return "linear" == t ? n.EASING_LINEAR : "absolute" == t ? n.EASING_ABSOLUTE : "smoothstep" == t ? n.EASING_SMOOTHSTEP : "smootherstep" == t ? n.EASING_SMOOTHERSTEP : "Cubic In" == t ? n.EASING_CUBIC_IN : "Cubic Out" == t ? n.EASING_CUBIC_OUT : "Cubic In Out" == t ? n.EASING_CUBIC_INOUT : "Expo In" == t ? n.EASING_EXPO_IN : "Expo Out" == t ? n.EASING_EXPO_OUT : "Expo In Out" == t ? n.EASING_EXPO_INOUT : "Sin In" == t ? n.EASING_SIN_IN : "Sin Out" == t ? n.EASING_SIN_OUT : "Sin In Out" == t ? n.EASING_SIN_INOUT : "Back In" == t ? n.EASING_BACK_IN : "Back Out" == t ? n.EASING_BACK_OUT : "Back In Out" == t ? n.EASING_BACK_INOUT : "Elastic In" == t ? n.EASING_ELASTIC_IN : "Elastic Out" == t ? n.EASING_ELASTIC_OUT : "Bounce In" == t ? n.EASING_BOUNCE_IN : "Bounce Out" == t ? n.EASING_BOUNCE_OUT : "Quart Out" == t ? n.EASING_QUART_OUT : "Quart In" == t ? n.EASING_QUART_IN : "Quart In Out" == t ? n.EASING_QUART_INOUT : "Quint Out" == t ? n.EASING_QUINT_OUT : "Quint In" == t ? n.EASING_QUINT_IN : "Quint In Out" == t ? n.EASING_QUINT_INOUT : void 0
        }, Y.prototype.createPort = function(t, e, i) {
            const s = t.inDropDown(e, n.EASINGS);
            return s.set("linear"), s.defaultValue = "linear", s.onChange = function() {
                this.defaultEasing = this.easingFromString(s.get()), i && i()
            }.bind(this), s
        }, Y.slerpQuaternion = function(t, e, i, s, r, n) {
            Y.slerpQuaternion.q1 || (Y.slerpQuaternion.q1 = quat.create(), Y.slerpQuaternion.q2 = quat.create());
            const o = i.getKeyIndex(t);
            let a = o + 1;
            if (a >= i.keys.length && (a = i.keys.length - 1), o == a) quat.set(e, i.keys[o].value, s.keys[o].value, r.keys[o].value, n.keys[o].value);
            else {
                const h = i.keys[o].time,
                    l = (t - h) / (i.keys[a].time - h);
                quat.set(Y.slerpQuaternion.q1, i.keys[o].value, s.keys[o].value, r.keys[o].value, n.keys[o].value), quat.set(Y.slerpQuaternion.q2, i.keys[a].value, s.keys[a].value, r.keys[a].value, n.keys[a].value), quat.slerp(e, Y.slerpQuaternion.q1, Y.slerpQuaternion.q2, l)
            }
            return e
        };
        const j = {
                Key: W
            },
            X = function(t, e, i, s) {
                z.apply(this), this.data = {}, this._log = new r("core_port"), this.direction = a.PORT_DIR_IN, this.id = String(CABLES.simpleId()), this._op = t, this.links = [], this.value = 0, this.name = e, this.type = i || o.OP_PORT_TYPE_VALUE, this.uiAttribs = s || {}, this.anim = null, this._oldAnimVal = -5711, this.defaultValue = null, this._uiActiveState = !0, this.ignoreValueSerialize = !1, this.onLinkChanged = null, this.crashed = !1, this._valueBeforeLink = null, this._lastAnimFrame = -1, this._animated = !1, this.onValueChanged = null, this.onTriggered = null, this.onUiActiveStateChange = null, this.changeAlways = !1, this.forceRefChange = !1, this._warnedDeprecated = !1, this._useVariableName = null, this.activityCounter = 0, this.apf = 0, this.activityCounterStartFrame = 0, this._tempLastUiValue = null, Object.defineProperty(this, "title", {
                    get() {
                        return this.uiAttribs.title || this.name
                    }
                }), Object.defineProperty(this, "parent", {
                    get() {
                        return this._log.stack("use port.op, not .parent"), this._op
                    }
                }), Object.defineProperty(this, "op", {
                    get() {
                        return this._op
                    }
                }), Object.defineProperty(this, "val", {
                    get() {
                        return this._log.warn("val getter deprecated!", this), this._log.stack("val getter deprecated"), this._warnedDeprecated = !0, this.get()
                    },
                    set(t) {
                        this._log.warn("val setter deprecated!", this), this._log.stack("val setter deprecated"), this.setValue(t), this._warnedDeprecated = !0
                    }
                })
            };
        X.prototype.copyLinkedUiAttrib = function(t, e) {
            if (!CABLES.UI) return;
            if (!this.isLinked()) return;
            const i = {};
            i[t] = this.links[0].getOtherPort(this).getUiAttrib(t), e.setUiAttribs(i)
        }, X.prototype.getValueForDisplay = function() {
            let t = this.value;
            return "string" == typeof this.value || this.value instanceof String ? (this.uiAttribs && "boolnum" == this.uiAttribs.display && (t += " - ", this.value ? t += "true" : t += "false"), t = t.replace(/[\u00A0-\u9999<>\&]/g, (function(t) {
                return "&#" + t.charCodeAt(0) + ";"
            })), t.length > 100 && (t = t.substring(0, 100))) : t = this.value, t
        }, X.prototype.onAnimToggle = function() {}, X.prototype._onAnimToggle = function() {
            this.onAnimToggle()
        }, X.prototype.remove = function() {
            this.removeLinks(), this._op.removePort(this)
        }, X.prototype.setUiAttribs = function(t) {
            let e = !1;
            this.uiAttribs || (this.uiAttribs = {});
            for (const i in t) this.uiAttribs[i] != t[i] && (e = !0), this.uiAttribs[i] = t[i], "group" == i && this.indexPort && this.indexPort.setUiAttribs({
                group: t[i]
            });
            t.hasOwnProperty("expose") && this._op.patch.emitEvent("subpatchExpose", this._op.uiAttribs.subPatch), e && this.emitEvent("onUiAttrChange", t, this)
        }, X.prototype.getUiAttribs = function() {
            return this.uiAttribs
        }, X.prototype.getUiAttrib = function(t) {
            return this.uiAttribs && this.uiAttribs.hasOwnProperty(t) ? this.uiAttribs[t] : null
        }, X.prototype.get = function() {
            return this._animated && this._lastAnimFrame != this._op.patch.getFrameNum() && (this._lastAnimFrame = this._op.patch.getFrameNum(), this.value = this.anim.getValue(this._op.patch.timer.getTime()), this._oldAnimVal = this.value, this.forceChange()), this.value
        }, X.prototype.setRef = function(t) {
            this.forceRefChange = !0, this.set(t)
        }, X.prototype.set = X.prototype.setValue = function(t) {
            if (void 0 === t && (t = null), this._op.enabled && !this.crashed && (t !== this.value || this.changeAlways || this.type == o.OP_PORT_TYPE_TEXTURE || this.type == o.OP_PORT_TYPE_ARRAY)) {
                if (this._animated) this.anim.setValue(this._op.patch.timer.getTime(), t);
                else {
                    try {
                        this.value = t, this.forceChange()
                    } catch (t) {
                        this.crashed = !0, this.setValue = function(t) {}, this.onTriggered = function() {}, this._log.error("onvaluechanged exception cought", t), this._log.error(t.stack), this._log.warn("exception in: " + this._op.name), this._op.patch.isEditorMode() && gui.showOpCrash(this._op), this._op.patch.emitEvent("exception", t, this._op), this._op.onError && this._op.onError(t)
                    }
                    this._op && this._op.patch && this._op.patch.isEditorMode() && this.type == o.OP_PORT_TYPE_TEXTURE && gui.texturePreview().updateTexturePort(this)
                }
                if (this.direction == a.PORT_DIR_OUT)
                    for (let t = 0; t < this.links.length; ++t) this.links[t].setValue()
            }
        }, X.prototype.updateAnim = function() {
            this._animated && (this.value = this.get(), (this._oldAnimVal != this.value || this.changeAlways) && (this._oldAnimVal = this.value, this.forceChange()), this._oldAnimVal = this.value)
        }, X.args = function(t) {
            return (t + "").replace(/[/][/].*$/gm, "").replace(/\s+/g, "").replace(/[/][*][^/*]*[*][/]/g, "").split("){", 1)[0].replace(/^[^(]*[(]/, "").replace(/=[^,]+/g, "").split(",").filter(Boolean)
        }, X.prototype.forceChange = function() {
            this.onValueChanged || this.onChange, this._activity(), this.emitEvent("change", this.value, this), this.onChange ? this.onChange(this, this.value) : this.onValueChanged && this.onValueChanged(this, this.value)
        }, X.prototype.getTypeString = function() {
            return this.type == o.OP_PORT_TYPE_VALUE ? "Number" : this.type == o.OP_PORT_TYPE_FUNCTION ? "Trigger" : this.type == o.OP_PORT_TYPE_OBJECT ? "Object" : this.type == o.OP_PORT_TYPE_DYNAMIC ? "Dynamic" : this.type == o.OP_PORT_TYPE_ARRAY ? "Array" : this.type == o.OP_PORT_TYPE_STRING ? "String" : "Unknown"
        }, X.prototype.deSerializeSettings = function(t) {
            if (t && (t.animated && this.setAnimated(t.animated), t.useVariable && this.setVariableName(t.useVariable), t.title && this.setUiAttribs({
                    title: t.title
                }), t.expose && this.setUiAttribs({
                    expose: !0
                }), t.anim)) {
                this.anim || (this.anim = new Y({
                    name: "port " + this.name
                })), this._op._hasAnimPort = !0, this.anim.addEventListener("onChange", (() => {
                    this._op.patch.emitEvent("portAnimUpdated", this._op, this, this.anim)
                })), t.anim.loop && (this.anim.loop = t.anim.loop);
                for (const e in t.anim.keys) this.anim.keys.push(new j.Key(t.anim.keys[e]));
                this.anim.sortKeys()
            }
        }, X.prototype.getSerialized = function() {
            const t = {};
            if (t.name = this.getName(), this.ignoreValueSerialize || 0 !== this.links.length || this.type == o.OP_PORT_TYPE_OBJECT && this.value && this.value.tex || (t.value = this.value), this._useVariableName && (t.useVariable = this._useVariableName), this._animated && (t.animated = !0), this.anim && (t.anim = this.anim.getSerialized()), "file" == this.uiAttribs.display && (t.display = this.uiAttribs.display), this.uiAttribs.expose && (t.expose = !0), this.uiAttribs.title && (t.title = this.uiAttribs.title), this.direction == a.PORT_DIR_OUT && this.links.length > 0) {
                t.links = [];
                for (const e in this.links) !this.links[e].ignoreInSerialize && this.links[e].portIn && this.links[e].portOut && t.links.push(this.links[e].getSerialized())
            }
            if (this.direction == a.PORT_DIR_IN && this.links.length > 0)
                for (const e in this.links) this.links[e].portIn && this.links[e].portOut && this.links[e].getOtherPort(this).op.isInBlueprint2() && !this.op.isInBlueprint2() && (t.links = t.links || [], t.links.push(this.links[e].getSerialized()));
            return t
        }, X.prototype.shouldLink = function() {
            return !0
        }, X.prototype.removeLinks = function() {
            let t = 0;
            for (; this.links.length > 0;) {
                if (t++, t > 5e3) {
                    this._log.warn("could not delete links... / infinite loop"), this.links.length = 0;
                    break
                }
                this.links[0].remove()
            }
        }, X.prototype.removeLink = function(t) {
            for (const e in this.links) this.links[e] == t && this.links.splice(e, 1);
            this.direction == a.PORT_DIR_IN && (this.type == o.OP_PORT_TYPE_VALUE ? this.setValue(this._valueBeforeLink || 0) : this.setValue(this._valueBeforeLink || null)), CABLES.UI && this._op.checkLinkTimeWarnings && this._op.checkLinkTimeWarnings(), this.onLinkChanged && this.onLinkChanged(), this.emitEvent("onLinkChanged"), this._op.emitEvent("onLinkChanged")
        }, X.prototype.getName = function() {
            return this.name
        }, X.prototype.addLink = function(t) {
            this._valueBeforeLink = this.value, this.links.push(t), CABLES.UI && this._op.checkLinkTimeWarnings && this._op.checkLinkTimeWarnings(), this.onLinkChanged && this.onLinkChanged(), this.emitEvent("onLinkChanged"), this._op.emitEvent("onLinkChanged")
        }, X.prototype.getLinkTo = function(t) {
            for (const e in this.links)
                if (this.links[e].portIn == t || this.links[e].portOut == t) return this.links[e]
        }, X.prototype.removeLinkTo = function(t) {
            for (const e in this.links)
                if (this.links[e].portIn == t || this.links[e].portOut == t) return this.links[e].remove(), CABLES.UI && this._op.checkLinkTimeWarnings && this._op.checkLinkTimeWarnings(), this.onLinkChanged && this.onLinkChanged(), void this.emitEvent("onLinkChanged")
        }, X.prototype.isLinkedTo = function(t) {
            for (const e in this.links)
                if (this.links[e].portIn == t || this.links[e].portOut == t) return !0;
            return !1
        }, X.prototype._activity = function() {
            this.activityCounter++
        }, X.prototype.trigger = function() {
            const t = this.links.length;
            if (this._activity(), 0 === t) return;
            if (!this._op.enabled) return;
            let e = null;
            try {
                for (let i = 0; i < t; ++i) this.links[i].portIn && (e = this.links[i].portIn, e.op.patch.pushTriggerStack(e), e._onTriggered(), e.op.patch.popTriggerStack()), this.links[i] && this.links[i].activity()
            } catch (t) {
                this._op.enabled = !1, this._op.patch.isEditorMode() && (this._op.patch.emitEvent("exception", t, e.op), this._op.patch.emitEvent("opcrash", e), e.op.onError && e.op.onError(t)), this._log.warn("exception!"), this._log.error("ontriggered exception caught", t), this._log.error(t.stack), this._log.warn("exception in: " + e.op.name)
            }
        }, X.prototype.call = function() {
            this._log.warn("call deprecated - use trigger() "), this.trigger()
        }, X.prototype.execute = function() {
            this._log.warn("### execute port: " + this.getName(), this.goals.length)
        }, X.prototype.setVariableName = function(t) {
            this._useVariableName = t, this._op.patch.on("variableRename", ((t, e) => {
                t == this._useVariableName && (this._useVariableName = e)
            }))
        }, X.prototype.getVariableName = function() {
            return this._useVariableName
        }, X.prototype.setVariable = function(t) {
            this.setAnimated(!1);
            const e = {
                useVariable: !1
            };
            this._variableIn && this._varChangeListenerId && (this._variableIn.off(this._varChangeListenerId), this._variableIn = null), t ? (this._variableIn = this._op.patch.getVar(t), this._variableIn ? (this.type == o.OP_PORT_TYPE_OBJECT ? this._varChangeListenerId = this._variableIn.on("change", (() => {
                this.set(null), this.set(this._variableIn.getValue())
            })) : this._varChangeListenerId = this._variableIn.on("change", this.set.bind(this)), this.set(this._variableIn.getValue())) : this._log.warn("PORT VAR NOT FOUND!!!", t), this._useVariableName = t, e.useVariable = !0, e.variableName = this._useVariableName) : (e.variableName = this._useVariableName = null, e.useVariable = !1), this.setUiAttribs(e), this._op.patch.emitEvent("portSetVariable", this._op, this, t)
        }, X.prototype._handleNoTriggerOpAnimUpdates = function(t) {
            let e = !1;
            for (let t = 0; t < this._op.portsIn.length; t++)
                if (this._op.portsIn.type == o.OP_PORT_TYPE_FUNCTION) {
                    e = !0;
                    break
                } e || (t ? this._notriggerAnimUpdate = this._op.patch.on("onRenderFrame", (() => {
                this.updateAnim()
            })) : this._op.patch.removeEventListener(this._notriggerAnimUpdate))
        }, X.prototype.setAnimated = function(t) {
            this._animated != t && (this._animated = t, this._op._hasAnimPort = !0, this._animated && !this.anim && (this.anim = new Y({
                name: "port " + this.name
            }), this.anim.addEventListener("onChange", (() => {
                this._op.patch.emitEvent("portAnimUpdated", this._op, this, this.anim)
            }))), this._onAnimToggle()), this._handleNoTriggerOpAnimUpdates(t), t || (this.anim = null), this.setUiAttribs({
                isAnimated: this._animated
            })
        }, X.prototype.toggleAnim = function() {
            this._animated = !this._animated, this._animated && !this.anim && (this.anim = new Y({
                name: "port " + this.name
            }), this.anim.addEventListener("onChange", (() => {
                this._op.patch.emitEvent("portAnimUpdated", this._op, this, this.anim)
            }))), this.setAnimated(this._animated), this._onAnimToggle(), this.setUiAttribs({
                isAnimated: this._animated
            })
        }, X.prototype.getType = function() {
            return this.type
        }, X.prototype.isLinked = function() {
            return this.links.length > 0 || this._animated || null != this._useVariableName
        }, X.prototype.isBoundToVar = function() {
            const t = null != this._useVariableName;
            return this.uiAttribs.boundToVar = t, t
        }, X.prototype.isAnimated = function() {
            return this._animated
        }, X.prototype.isHidden = function() {
            return this.uiAttribs.hidePort
        }, X.prototype._onTriggered = function(t) {
            this._activity(), this._op.updateAnims(), this._op.enabled && this.onTriggered && this.onTriggered(t)
        }, X.prototype._onSetProfiling = function(t) {
            this._op.patch.profiler.add("port", this), this.setValue(t), this._op.patch.profiler.add("port", null)
        }, X.prototype._onTriggeredProfiling = function() {
            this._op.enabled && this.onTriggered && (this._op.patch.profiler.add("port", this), this.onTriggered(), this._op.patch.profiler.add("port", null))
        }, X.prototype.onValueChange = function(t) {
            this.onChange = t
        }, X.prototype.getUiActiveState = function() {
            return this._uiActiveState
        }, X.prototype.setUiActiveState = function(t) {
            this._uiActiveState = t, this.onUiActiveStateChange && this.onUiActiveStateChange()
        }, X.prototype.hidePort = function() {
            this._log.warn("op.hideport() is deprecated, do not use it!")
        }, X.portTypeNumberToString = function(t) {
            return t == o.OP_PORT_TYPE_VALUE ? "value" : t == o.OP_PORT_TYPE_FUNCTION ? "function" : t == o.OP_PORT_TYPE_OBJECT ? "object" : t == o.OP_PORT_TYPE_ARRAY ? "array" : t == o.OP_PORT_TYPE_STRING ? "string" : t == o.OP_PORT_TYPE_DYNAMIC ? "dynamic" : "unknown"
        };
        const q = class {
            constructor(t, e, i, s, n, o, a, h, l, c) {
                if (this._log = new r("cg_uniform"), this._type = e, this._name = i, this._shader = t, this._value = 1e-5, this._oldValue = null, this._port = null, this._structName = l, this._structUniformName = h, this._propertyName = c, this._shader._addUniform(this), this.needsUpdate = !0, this.shaderType = null, this.comment = null, "f" == e) this.set = this.setValue = this.setValueF.bind(this), this.updateValue = this.updateValueF.bind(this);
                else if ("f[]" == e) this.set = this.setValue = this.setValueArrayF.bind(this), this.updateValue = this.updateValueArrayF.bind(this);
                else if ("2f[]" == e) this.set = this.setValue = this.setValueArray2F.bind(this), this.updateValue = this.updateValueArray2F.bind(this);
                else if ("3f[]" == e) this.set = this.setValue = this.setValueArray3F.bind(this), this.updateValue = this.updateValueArray3F.bind(this);
                else if ("4f[]" == e) this.set = this.setValue = this.setValueArray4F.bind(this), this.updateValue = this.updateValueArray4F.bind(this);
                else if ("i" == e) this.set = this.setValue = this.setValueI.bind(this), this.updateValue = this.updateValueI.bind(this);
                else if ("2i" == e) this.set = this.setValue = this.setValue2I.bind(this), this.updateValue = this.updateValue2I.bind(this);
                else if ("3i" == e) this.set = this.setValue = this.setValue3I.bind(this), this.updateValue = this.updateValue3I.bind(this);
                else if ("4i" == e) this.set = this.setValue = this.setValue4I.bind(this), this.updateValue = this.updateValue4I.bind(this);
                else if ("b" == e) this.set = this.setValue = this.setValueBool.bind(this), this.updateValue = this.updateValueBool.bind(this);
                else if ("4f" == e) this.set = this.setValue = this.setValue4F.bind(this), this.updateValue = this.updateValue4F.bind(this);
                else if ("3f" == e) this.set = this.setValue = this.setValue3F.bind(this), this.updateValue = this.updateValue3F.bind(this);
                else if ("2f" == e) this.set = this.setValue = this.setValue2F.bind(this), this.updateValue = this.updateValue2F.bind(this);
                else if ("t" == e) this.set = this.setValue = this.setValueT.bind(this), this.updateValue = this.updateValueT.bind(this);
                else if ("tc" == e) this.set = this.setValue = this.setValueT.bind(this), this.updateValue = this.updateValueT.bind(this);
                else if ("t[]" == e) this.set = this.setValue = this.setValueArrayT.bind(this), this.updateValue = this.updateValueArrayT.bind(this);
                else {
                    if ("m4" != e && "m4[]" != e) throw new Error("Unknown uniform type");
                    this.set = this.setValue = this.setValueM4.bind(this), this.updateValue = this.updateValueM4.bind(this)
                }
                "object" == typeof s && s instanceof X ? (this._port = s, this._value = this._port.get(), n && o && a ? (n instanceof X && o instanceof X && a instanceof X || this._log.error("[cgl_uniform] mixed port/value parameter for vec4 ", this._name), this._value = [0, 0, 0, 0], this._port2 = n, this._port3 = o, this._port4 = a, this._port.on("change", this.updateFromPort4f.bind(this)), this._port2.on("change", this.updateFromPort4f.bind(this)), this._port3.on("change", this.updateFromPort4f.bind(this)), this._port4.on("change", this.updateFromPort4f.bind(this)), this.updateFromPort4f()) : n && o ? (n instanceof X && o instanceof X || this._log.error("[cgl_uniform] mixed port/value parameter for vec4 ", this._name), this._value = [0, 0, 0], this._port2 = n, this._port3 = o, this._port.on("change", this.updateFromPort3f.bind(this)), this._port2.on("change", this.updateFromPort3f.bind(this)), this._port3.on("change", this.updateFromPort3f.bind(this)), this.updateFromPort3f()) : n ? (n instanceof X || this._log.error("[cgl_uniform] mixed port/value parameter for vec4 ", this._name), this._value = [0, 0], this._port2 = n, this._port.on("change", this.updateFromPort2f.bind(this)), this._port2.on("change", this.updateFromPort2f.bind(this)), this.updateFromPort2f()) : this._port.on("change", this.updateFromPort.bind(this))) : this._value = s, this.setValue(this._value), this.needsUpdate = !0
            }
            getType() {
                return this._type
            }
            getName() {
                return this._name
            }
            getValue() {
                return this._value
            }
            getShaderType() {
                return this.shaderType
            }
            isStructMember() {
                return !!this._structName
            }
            updateFromPort4f() {
                this._value[0] = this._port.get(), this._value[1] = this._port2.get(), this._value[2] = this._port3.get(), this._value[3] = this._port4.get(), this.setValue(this._value)
            }
            updateFromPort3f() {
                this._value[0] = this._port.get(), this._value[1] = this._port2.get(), this._value[2] = this._port3.get(), this.setValue(this._value)
            }
            updateFromPort2f() {
                this._value[0] = this._port.get(), this._value[1] = this._port2.get(), this.setValue(this._value)
            }
            updateFromPort() {
                this.setValue(this._port.get())
            }
        };
        class Q extends q {
            constructor(t, e, i, s, r, n, o, a, h, l) {
                super(t, e, i, s, r, n, o, a, h, l), this._loc = -1, this._cgl = t._cgl
            }
            get name() {
                return this._name
            }
            copy(t) {
                const e = new Q(t, this._type, this._name, this._value, this._port2, this._port3, this._port4, this._structUniformName, this._structName, this._propertyName);
                return e.shaderType = this.shaderType, e
            }
            getGlslTypeString() {
                return Q.glslTypeString(this._type)
            }
            _isValidLoc() {
                return -1 != this._loc
            }
            resetLoc() {
                this._loc = -1, this.needsUpdate = !0
            }
            bindTextures() {}
            getLoc() {
                return this._loc
            }
            updateFromPort4f() {
                this._value[0] = this._port.get(), this._value[1] = this._port2.get(), this._value[2] = this._port3.get(), this._value[3] = this._port4.get(), this.setValue(this._value)
            }
            updateFromPort3f() {
                this._value[0] = this._port.get(), this._value[1] = this._port2.get(), this._value[2] = this._port3.get(), this.setValue(this._value)
            }
            updateFromPort2f() {
                this._value[0] = this._port.get(), this._value[1] = this._port2.get(), this.setValue(this._value)
            }
            updateFromPort() {
                this.setValue(this._port.get())
            }
            updateValueF() {
                this._isValidLoc() ? this.needsUpdate = !1 : this._loc = this._shader.getCgl().gl.getUniformLocation(this._shader.getProgram(), this._name), this._shader.getCgl().gl.uniform1f(this._loc, this._value), this._cgl.profileData.profileUniformCount++
            }
            setValueF(t) {
                t != this._value && (this.needsUpdate = !0, this._value = t)
            }
            updateValueI() {
                this._isValidLoc() ? this.needsUpdate = !1 : this._loc = this._shader.getCgl().gl.getUniformLocation(this._shader.getProgram(), this._name), this._shader.getCgl().gl.uniform1i(this._loc, this._value), this._cgl.profileData.profileUniformCount++
            }
            updateValue2I() {
                this._value && (this._isValidLoc() || (this._loc = this._shader.getCgl().gl.getUniformLocation(this._shader.getProgram(), this._name), this._cgl.profileData.profileShaderGetUniform++, this._cgl.profileData.profileShaderGetUniformName = this._name), this._shader.getCgl().gl.uniform2i(this._loc, this._value[0], this._value[1]), this.needsUpdate = !1, this._cgl.profileData.profileUniformCount++)
            }
            updateValue3I() {
                this._value && (this._isValidLoc() || (this._loc = this._shader.getCgl().gl.getUniformLocation(this._shader.getProgram(), this._name), this._cgl.profileData.profileShaderGetUniform++, this._cgl.profileData.profileShaderGetUniformName = this._name), this._shader.getCgl().gl.uniform3i(this._loc, this._value[0], this._value[1], this._value[2]), this.needsUpdate = !1, this._cgl.profileData.profileUniformCount++)
            }
            updateValue4I() {
                this._isValidLoc() || (this._loc = this._shader.getCgl().gl.getUniformLocation(this._shader.getProgram(), this._name), this._cgl.profileData.profileShaderGetUniform++, this._cgl.profileData.profileShaderGetUniformName = this._name), this._shader.getCgl().gl.uniform4i(this._loc, this._value[0], this._value[1], this._value[2], this._value[3]), this._cgl.profileData.profileUniformCount++
            }
            setValueI(t) {
                t != this._value && (this.needsUpdate = !0, this._value = t)
            }
            setValue2I(t) {
                t && (this._oldValue ? t[0] == this._oldValue[0] && t[1] == this._oldValue[1] || (this._oldValue[0] = t[0], this._oldValue[1] = t[1], this.needsUpdate = !0) : (this._oldValue = [t[0] - 1, 1], this.needsUpdate = !0), this._value = t)
            }
            setValue3I(t) {
                t && (this._oldValue ? t[0] == this._oldValue[0] && t[1] == this._oldValue[1] && t[2] == this._oldValue[2] || (this._oldValue[0] = t[0], this._oldValue[1] = t[1], this._oldValue[2] = t[2], this.needsUpdate = !0) : (this._oldValue = [t[0] - 1, 1, 2], this.needsUpdate = !0), this._value = t)
            }
            setValue4I(t) {
                this.needsUpdate = !0, this._value = t || vec4.create()
            }
            updateValueBool() {
                this._isValidLoc() ? this.needsUpdate = !1 : this._loc = this._shader.getCgl().gl.getUniformLocation(this._shader.getProgram(), this._name), this._shader.getCgl().gl.uniform1i(this._loc, this._value ? 1 : 0), this._cgl.profileData.profileUniformCount++
            }
            setValueBool(t) {
                t != this._value && (this.needsUpdate = !0, this._value = t)
            }
            setValueArray4F(t) {
                this.needsUpdate = !0, this._value = t
            }
            updateValueArray4F() {
                this._isValidLoc() ? this.needsUpdate = !1 : this._loc = this._shader.getCgl().gl.getUniformLocation(this._shader.getProgram(), this._name), this._value && (this._shader.getCgl().gl.uniform4fv(this._loc, this._value), this._cgl.profileData.profileUniformCount++)
            }
            setValueArray3F(t) {
                this.needsUpdate = !0, this._value = t
            }
            updateValueArray3F() {
                this._isValidLoc() ? this.needsUpdate = !1 : this._loc = this._shader.getCgl().gl.getUniformLocation(this._shader.getProgram(), this._name), this._value && (this._shader.getCgl().gl.uniform3fv(this._loc, this._value), this._cgl.profileData.profileUniformCount++)
            }
            setValueArray2F(t) {
                this.needsUpdate = !0, this._value = t
            }
            updateValueArray2F() {
                this._isValidLoc() ? this.needsUpdate = !1 : this._loc = this._shader.getCgl().gl.getUniformLocation(this._shader.getProgram(), this._name), this._value && (this._shader.getCgl().gl.uniform2fv(this._loc, this._value), this._cgl.profileData.profileUniformCount++)
            }
            setValueArrayF(t) {
                this.needsUpdate = !0, this._value = t
            }
            updateValueArrayF() {
                this._isValidLoc() ? this.needsUpdate = !1 : this._loc = this._shader.getCgl().gl.getUniformLocation(this._shader.getProgram(), this._name), this._value && (this._shader.getCgl().gl.uniform1fv(this._loc, this._value), this._cgl.profileData.profileUniformCount++)
            }
            setValueArrayT(t) {
                this.needsUpdate = !0, this._value = t
            }
            updateValue3F() {
                this._value && (this._isValidLoc() || (this._loc = this._shader.getCgl().gl.getUniformLocation(this._shader.getProgram(), this._name), this._cgl.profileData.profileShaderGetUniform++, this._cgl.profileData.profileShaderGetUniformName = this._name), this._shader.getCgl().gl.uniform3f(this._loc, this._value[0], this._value[1], this._value[2]), this.needsUpdate = !1, this._cgl.profileData.profileUniformCount++)
            }
            setValue3F(t) {
                t && (this._oldValue ? t[0] == this._oldValue[0] && t[1] == this._oldValue[1] && t[2] == this._oldValue[2] || (this._oldValue[0] = t[0], this._oldValue[1] = t[1], this._oldValue[2] = t[2], this.needsUpdate = !0) : (this._oldValue = [t[0] - 1, 1, 2], this.needsUpdate = !0), this._value = t)
            }
            updateValue2F() {
                this._value && (this._isValidLoc() || (this._loc = this._shader.getCgl().gl.getUniformLocation(this._shader.getProgram(), this._name), this._cgl.profileData.profileShaderGetUniform++, this._cgl.profileData.profileShaderGetUniformName = this._name), this._shader.getCgl().gl.uniform2f(this._loc, this._value[0], this._value[1]), this.needsUpdate = !1, this._cgl.profileData.profileUniformCount++)
            }
            setValue2F(t) {
                t && (this._oldValue ? t[0] == this._oldValue[0] && t[1] == this._oldValue[1] || (this._oldValue[0] = t[0], this._oldValue[1] = t[1], this.needsUpdate = !0) : (this._oldValue = [t[0] - 1, 1], this.needsUpdate = !0), this._value = t)
            }
            updateValue4F() {
                this._isValidLoc() || (this._loc = this._shader.getCgl().gl.getUniformLocation(this._shader.getProgram(), this._name), this._cgl.profileData.profileShaderGetUniform++, this._cgl.profileData.profileShaderGetUniformName = this._name), this._value || (this._log.warn("no value for uniform", this._name, this), this._value = [0, 0, 0, 0]), this.needsUpdate = !1, this._shader.getCgl().gl.uniform4f(this._loc, this._value[0], this._value[1], this._value[2], this._value[3]), this._cgl.profileData.profileUniformCount++
            }
            setValue4F(t) {
                "number" == typeof this.value && (this.value = vec4.create()), t && (this._oldValue ? t[0] == this._oldValue[0] && t[1] == this._oldValue[1] && t[2] == this._oldValue[2] && t[3] == this._oldValue[3] || (this._oldValue[0] = t[0], this._oldValue[1] = t[1], this._oldValue[2] = t[2], this.needsUpdate = !0) : (this._oldValue = [t[0] - 1, 1, 2, 3], this.needsUpdate = !0), this._value = t)
            }
            updateValueM4() {
                if (this._isValidLoc() || (this._loc = this._shader.getCgl().gl.getUniformLocation(this._shader.getProgram(), this._name), this._cgl.profileData.profileShaderGetUniform++, this._cgl.profileData.profileShaderGetUniformName = this._name), !this._value || this._value.length % 16 != 0) return console.log("this.name", this._name, this._value);
                this._shader.getCgl().gl.uniformMatrix4fv(this._loc, !1, this._value), this._cgl.profileData.profileUniformCount++
            }
            setValueM4(t) {
                this.needsUpdate = !0, this._value = t || mat4.create()
            }
            updateValueArrayT() {
                this._isValidLoc() ? this.needsUpdate = !1 : this._loc = this._shader.getCgl().gl.getUniformLocation(this._shader.getProgram(), this._name), this._value && (this._shader.getCgl().gl.uniform1iv(this._loc, this._value), this._cgl.profileData.profileUniformCount++)
            }
            updateValueT() {
                this._isValidLoc() || (this._loc = this._shader.getCgl().gl.getUniformLocation(this._shader.getProgram(), this._name), this._cgl.profileData.profileShaderGetUniform++, this._cgl.profileData.profileShaderGetUniformName = this._name), this._cgl.profileData.profileUniformCount++, this._shader.getCgl().gl.uniform1i(this._loc, this._value), this.needsUpdate = !1
            }
            setValueT(t) {
                this.needsUpdate = !0, this._value = t
            }
        }
        Q.glslTypeString = t => "f" == t ? "float" : "b" == t ? "bool" : "i" == t ? "int" : "2i" == t ? "ivec2" : "2f" == t ? "vec2" : "3f" == t ? "vec3" : "4f" == t ? "vec4" : "m4" == t ? "mat4" : "t" == t ? "sampler2D" : "tc" == t ? "samplerCube" : "3f[]" == t || "m4[]" == t || "f[]" == t ? null : void console.warn("[CGL UNIFORM] unknown glsl type string ", t);
        const K = 180 / Math.PI,
            J = {
                MATH: {
                    DEG2RAD: Math.PI / 180,
                    RAD2DEG: K
                },
                SHADER: {
                    SHADERVAR_VERTEX_POSITION: "vPosition",
                    SHADERVAR_VERTEX_NUMBER: "attrVertIndex",
                    SHADERVAR_VERTEX_NORMAL: "attrVertNormal",
                    SHADERVAR_VERTEX_TEXCOORD: "attrTexCoord",
                    SHADERVAR_INSTANCE_MMATRIX: "instMat",
                    SHADERVAR_VERTEX_COLOR: "attrVertColor",
                    SHADERVAR_INSTANCE_INDEX: "instanceIndex",
                    SHADERVAR_UNI_PROJMAT: "projMatrix",
                    SHADERVAR_UNI_VIEWMAT: "viewMatrix",
                    SHADERVAR_UNI_MODELMAT: "modelMatrix",
                    SHADERVAR_UNI_NORMALMAT: "normalMatrix",
                    SHADERVAR_UNI_INVVIEWMAT: "inverseViewMatrix",
                    SHADERVAR_UNI_INVPROJMAT: "invProjMatrix",
                    SHADERVAR_UNI_MATERIALID: "materialId",
                    SHADERVAR_UNI_OBJECTID: "objectId",
                    SHADERVAR_UNI_VIEWPOS: "camPos"
                },
                BLEND_MODES: {
                    BLEND_NONE: 0,
                    BLEND_NORMAL: 1,
                    BLEND_ADD: 2,
                    BLEND_SUB: 3,
                    BLEND_MUL: 4
                }
            },
            Z = {
                lastMesh: null
            },
            $ = function(t, e, i) {
                this._cgl = t, this._log = new r("cgl_mesh"), this._bufVertexAttrib = null, this._bufVerticesIndizes = this._cgl.gl.createBuffer(), this._indexType = this._cgl.gl.UNSIGNED_SHORT, this._attributes = [], this._attribLocs = {}, this._geom = null, this._lastShader = null, this._numInstances = 0, this._glPrimitive = i, this._preWireframeGeom = null, this.addVertexNumbers = !1, this._name = "unknown", this.feedBackAttributes = [], this.setGeom(e), this._feedBacks = [], this._feedBacksChanged = !1, this._transformFeedBackLoc = -1, this._lastAttrUpdate = 0, this._cgl.profileData.addHeavyEvent("mesh constructed", this._name), this._queryExt = null, Object.defineProperty(this, "numInstances", {
                    get() {
                        return this._numInstances
                    },
                    set(t) {
                        this.setNumInstances(t)
                    }
                })
            };
        $.prototype.updateVertices = function(t) {
                this.setAttribute(J.SHADER.SHADERVAR_VERTEX_POSITION, t.vertices, 3), this._numVerts = t.vertices.length / 3
            }, $.prototype.setAttributePointer = function(t, e, i, s) {
                for (let r = 0; r < this._attributes.length; r++) this._attributes[r].name == t && (this._attributes[r].pointer || (this._attributes[r].pointer = []), this._attributes[r].pointer.push({
                    loc: -1,
                    name: e,
                    stride: i,
                    offset: s,
                    instanced: t == J.SHADER.SHADERVAR_INSTANCE_MMATRIX
                }))
            }, $.prototype.getAttribute = function(t) {
                for (let e = 0; e < this._attributes.length; e++)
                    if (this._attributes[e].name == t) return this._attributes[e]
            }, $.prototype.setAttributeRange = function(t, e, i, s) {
                t && (i || s) && (t.name || (console.log(t), this._log.stack("no attrname?!")), this._cgl.gl.bindBuffer(this._cgl.gl.ARRAY_BUFFER, t.buffer), this._cgl.profileData.profileMeshAttributes += s - i || 0, this._cgl.profileData.profileSingleMeshAttribute[this._name] = this._cgl.profileData.profileSingleMeshAttribute[this._name] || 0, this._cgl.profileData.profileSingleMeshAttribute[this._name] += s - i || 0, t.numItems < e.length / t.itemSize && this._resizeAttr(e, t), s >= e.length - 1 && this._log.log(this._cgl.canvas.id + " " + t.name + " buffersubdata out of bounds ?", e.length, s, i, t), 1 == this._cgl.glVersion ? this._cgl.gl.bufferSubData(this._cgl.gl.ARRAY_BUFFER, 0, e) : this._cgl.gl.bufferSubData(this._cgl.gl.ARRAY_BUFFER, 4 * i, e, i, s - i))
            }, $.prototype._resizeAttr = function(t, e) {
                e.buffer && this._cgl.gl.deleteBuffer(e.buffer), e.buffer = this._cgl.gl.createBuffer(), this._cgl.gl.bindBuffer(this._cgl.gl.ARRAY_BUFFER, e.buffer), this._bufferArray(t, e), e.numItems = t.length / e.itemSize
            }, $.prototype._bufferArray = function(t, e) {
                let i = e.floatArray || null;
                t && (this._cgl.debugOneFrame && console.log("_bufferArray", t.length, e.name), t instanceof Float32Array ? i = t : e && i && i.length == t.length ? i.set(t) : (i = new Float32Array(t), this._cgl.debugOneFrame && console.log("_bufferArray create new float32array", t.length, e.name), this._cgl.profileData.profileNonTypedAttrib++, this._cgl.profileData.profileNonTypedAttribNames = "(" + this._name + ":" + e.name + ")"), e.arrayLength = i.length, e.floatArray = i, this._cgl.gl.bufferData(this._cgl.gl.ARRAY_BUFFER, i, this._cgl.gl.DYNAMIC_DRAW))
            }, $.prototype.addAttribute = $.prototype.updateAttribute = $.prototype.setAttribute = function(t, e, i, s) {
                if (!e) throw this._log.error("mesh addAttribute - no array given! " + t), new Error;
                let r = null,
                    n = !1,
                    o = 0;
                const a = e.length / i;
                for (this._cgl.profileData.profileMeshAttributes += a || 0, "function" == typeof s && (r = s), "object" == typeof s && (s.cb && (r = s.cb), s.instanced && (n = s.instanced)), t == J.SHADER.SHADERVAR_INSTANCE_MMATRIX && (n = !0), o = 0; o < this._attributes.length; o++) {
                    const i = this._attributes[o];
                    if (i.name == t) return i.numItems === a || this._resizeAttr(e, i), this._cgl.gl.bindBuffer(this._cgl.gl.ARRAY_BUFFER, i.buffer), this._bufferArray(e, i), i
                }
                const h = this._cgl.gl.createBuffer();
                this._cgl.gl.bindBuffer(this._cgl.gl.ARRAY_BUFFER, h);
                let l = this._cgl.gl.FLOAT;
                s && s.type && (l = s.type);
                const c = {
                    buffer: h,
                    name: t,
                    cb: r,
                    itemSize: i,
                    numItems: a,
                    startItem: 0,
                    instanced: n,
                    type: l
                };
                return this._bufferArray(e, c), t == J.SHADER.SHADERVAR_VERTEX_POSITION && (this._bufVertexAttrib = c), this._attributes.push(c), this._attribLocs = {}, c
            }, $.prototype.getAttributes = function() {
                return this._attributes
            }, $.prototype.updateTexCoords = function(t) {
                if (t.texCoords && t.texCoords.length > 0) this.setAttribute(J.SHADER.SHADERVAR_VERTEX_TEXCOORD, t.texCoords, 2);
                else {
                    const e = new Float32Array(Math.round(t.vertices.length / 3 * 2));
                    this.setAttribute(J.SHADER.SHADERVAR_VERTEX_TEXCOORD, e, 2)
                }
            }, $.prototype.updateNormals = function(t) {
                if (t.vertexNormals && t.vertexNormals.length > 0) this.setAttribute(J.SHADER.SHADERVAR_VERTEX_NORMAL, t.vertexNormals, 3);
                else {
                    const e = new Float32Array(Math.round(t.vertices.length));
                    this.setAttribute(J.SHADER.SHADERVAR_VERTEX_NORMAL, e, 3)
                }
            }, $.prototype._setVertexNumbers = function(t) {
                if (!this._verticesNumbers || this._verticesNumbers.length != this._numVerts || t) {
                    if (t) this._verticesNumbers = t;
                    else {
                        this._verticesNumbers = new Float32Array(this._numVerts);
                        for (let t = 0; t < this._numVerts; t++) this._verticesNumbers[t] = t
                    }
                    this.setAttribute(J.SHADER.SHADERVAR_VERTEX_NUMBER, this._verticesNumbers, 1, ((t, e, i) => {
                        i.uniformNumVertices || (i.uniformNumVertices = new Q(i, "f", "numVertices", this._numVerts)), i.uniformNumVertices.setValue(this._numVerts)
                    }))
                }
            }, $.prototype.setVertexIndices = function(t) {
                if (this._bufVerticesIndizes)
                    if (t.length > 0) {
                        t instanceof Float32Array && this._log.warn("vertIndices float32Array: " + this._name);
                        for (let e = 0; e < t.length; e++)
                            if (t[e] >= this._numVerts) return void this._log.warn("invalid index in " + this._name, e, t[e]);
                        this._cgl.gl.bindBuffer(this._cgl.gl.ELEMENT_ARRAY_BUFFER, this._bufVerticesIndizes), t.length > 65535 ? (this.vertIndicesTyped = new Uint32Array(t), this._indexType = this._cgl.gl.UNSIGNED_INT) : t instanceof Uint32Array ? (this.vertIndicesTyped = t, this._indexType = this._cgl.gl.UNSIGNED_INT) : t instanceof Uint16Array ? this.vertIndicesTyped = t : (this.vertIndicesTyped = new Uint16Array(t), this._indexType = this._cgl.gl.UNSIGNED_SHORT), this._cgl.gl.bufferData(this._cgl.gl.ELEMENT_ARRAY_BUFFER, this.vertIndicesTyped, this._cgl.gl.DYNAMIC_DRAW), this._bufVerticesIndizes.itemSize = 1, this._bufVerticesIndizes.numItems = t.length
                    } else this._bufVerticesIndizes.numItems = 0;
                else this._log.warn("no bufVerticesIndizes: " + this._name)
            }, $.prototype.setGeom = function(t, e) {
                this._geom = t, null != t.glPrimitive && (this._glPrimitive = t.glPrimitive), this._geom && this._geom.name && (this._name = "mesh " + this._geom.name), Z.lastMesh = null, this._cgl.profileData.profileMeshSetGeom++, this._disposeAttributes(), this.updateVertices(this._geom), this.setVertexIndices(this._geom.verticesIndices), this.addVertexNumbers && this._setVertexNumbers();
                const i = this._geom.getAttributes(),
                    s = {
                        texCoords: J.SHADER.SHADERVAR_VERTEX_TEXCOORD,
                        vertexNormals: J.SHADER.SHADERVAR_VERTEX_NORMAL,
                        vertexColors: J.SHADER.SHADERVAR_VERTEX_COLOR,
                        tangents: "attrTangent",
                        biTangents: "attrBiTangent"
                    };
                for (const t in i) i[t].data && i[t].data.length && this.setAttribute(s[t] || t, i[t].data, i[t].itemSize);
                e && (this._geom = null)
            }, $.prototype._preBind = function(t) {
                for (let e = 0; e < this._attributes.length; e++) this._attributes[e].cb && this._attributes[e].cb(this._attributes[e], this._geom, t)
            }, $.prototype._checkAttrLengths = function() {
                for (let t = 0; t < this._attributes.length; t++)
                    if (this._attributes[t].arrayLength / this._attributes[t].itemSize < this._attributes[0].arrayLength / this._attributes[0].itemSize) {
                        let t = "unknown";
                        this._geom && (t = this._geom.name)
                    }
            }, $.prototype._bind = function(t) {
                if (!t.isValid()) return;
                let e = [];
                if (this._attribLocs[t.id] ? e = this._attribLocs[t.id] : this._attribLocs[t.id] = e, this._lastShader = t, t.lastCompile > this._lastAttrUpdate || e.length != this._attributes.length) {
                    this._lastAttrUpdate = t.lastCompile;
                    for (let t = 0; t < this._attributes.length; t++) e[t] = -1
                }
                for (let i = 0; i < this._attributes.length; i++) {
                    const s = this._attributes[i];
                    if (-1 == e[i] && s._attrLocationLastShaderTime != t.lastCompile && (s._attrLocationLastShaderTime = t.lastCompile, e[i] = this._cgl.glGetAttribLocation(t.getProgram(), s.name), this._cgl.profileData.profileAttrLoc++), -1 != e[i])
                        if (this._cgl.gl.enableVertexAttribArray(e[i]), this._cgl.gl.bindBuffer(this._cgl.gl.ARRAY_BUFFER, s.buffer), s.instanced)
                            if (s.itemSize <= 4) s.itemSize && 0 != s.itemSize || this._log.warn("instanced attrib itemsize error", this._geom.name, s), this._cgl.gl.vertexAttribPointer(e[i], s.itemSize, s.type, !1, 4 * s.itemSize, 0), this._cgl.gl.vertexAttribDivisor(e[i], 1);
                            else if (16 == s.itemSize) {
                        const t = 64;
                        this._cgl.gl.vertexAttribPointer(e[i], 4, s.type, !1, t, 0), this._cgl.gl.enableVertexAttribArray(e[i] + 1), this._cgl.gl.vertexAttribPointer(e[i] + 1, 4, s.type, !1, t, 16), this._cgl.gl.enableVertexAttribArray(e[i] + 2), this._cgl.gl.vertexAttribPointer(e[i] + 2, 4, s.type, !1, t, 32), this._cgl.gl.enableVertexAttribArray(e[i] + 3), this._cgl.gl.vertexAttribPointer(e[i] + 3, 4, s.type, !1, t, 48), this._cgl.gl.vertexAttribDivisor(e[i], 1), this._cgl.gl.vertexAttribDivisor(e[i] + 1, 1), this._cgl.gl.vertexAttribDivisor(e[i] + 2, 1), this._cgl.gl.vertexAttribDivisor(e[i] + 3, 1)
                    } else this._log.warn("unknown instance attrib size", s.name);
                    else {
                        if (s.itemSize && 0 != s.itemSize || this._log.warn("attrib itemsize error", this._name, s), this._cgl.gl.vertexAttribPointer(e[i], s.itemSize, s.type, !1, 4 * s.itemSize, 0), s.pointer)
                            for (let e = 0; e < s.pointer.length; e++) {
                                const i = s.pointer[e]; - 1 == i.loc && (i.loc = this._cgl.glGetAttribLocation(t.getProgram(), i.name)), this._cgl.profileData.profileAttrLoc++, this._cgl.gl.enableVertexAttribArray(i.loc), this._cgl.gl.vertexAttribPointer(i.loc, s.itemSize, s.type, !1, i.stride, i.offset)
                            }
                        this.bindFeedback(s)
                    }
                }
                this._bufVerticesIndizes && 0 !== this._bufVerticesIndizes.numItems && this._cgl.gl.bindBuffer(this._cgl.gl.ELEMENT_ARRAY_BUFFER, this._bufVerticesIndizes)
            }, $.prototype.unBind = function() {
                const t = this._lastShader;
                if (this._lastShader = null, !t) return;
                let e = [];
                this._attribLocs[t.id] ? e = this._attribLocs[t.id] : this._attribLocs[t.id] = e, Z.lastMesh = null;
                for (let t = 0; t < this._attributes.length; t++) this._attributes[t].instanced && (this._attributes[t].itemSize <= 4 ? (-1 != e[t] && this._cgl.gl.vertexAttribDivisor(e[t], 0), e[t] >= 0 && this._cgl.gl.disableVertexAttribArray(e[t])) : (this._cgl.gl.vertexAttribDivisor(e[t], 0), this._cgl.gl.vertexAttribDivisor(e[t] + 1, 0), this._cgl.gl.vertexAttribDivisor(e[t] + 2, 0), this._cgl.gl.vertexAttribDivisor(e[t] + 3, 0), this._cgl.gl.disableVertexAttribArray(e[t] + 1), this._cgl.gl.disableVertexAttribArray(e[t] + 2), this._cgl.gl.disableVertexAttribArray(e[t] + 3))), -1 != e[t] && this._cgl.gl.disableVertexAttribArray(e[t])
            }, $.prototype.meshChanged = function() {
                return this._cgl.lastMesh && this._cgl.lastMesh != this
            }, $.prototype.printDebug = function(t) {
                console.log("--attributes");
                for (let t = 0; t < this._attributes.length; t++) console.log("attribute " + t + " " + this._attributes[t].name)
            }, $.prototype.setNumVertices = function(t) {
                this._bufVertexAttrib.numItems = t
            }, $.prototype.getNumVertices = function() {
                return this._bufVertexAttrib.numItems
            }, $.prototype.render = function(t) {
                if (!t || !t.isValid() || this._cgl.aborted) return;
                if (this._checkAttrLengths(), this._geom && (!this._preWireframeGeom || t.wireframe || this._geom.isIndexed() || (this.setGeom(this._preWireframeGeom), this._preWireframeGeom = null), t.wireframe)) {
                    let t = !1;
                    this._geom.isIndexed() && (this._preWireframeGeom || (this._preWireframeGeom = this._geom, this._geom = this._geom.copy()), this._geom.unIndex(), t = !0), this._geom.getAttribute("attrBarycentric") || (this._preWireframeGeom || (this._preWireframeGeom = this._geom, this._geom = this._geom.copy()), t = !0, this._geom.calcBarycentric()), t && this.setGeom(this._geom)
                }
                let e = !1;
                if (Z.lastMesh != this && (Z.lastMesh && Z.lastMesh.unBind(), e = !0), e && this._preBind(t), !t.bind()) return;
                this._bind(t), this.addVertexNumbers && this._setVertexNumbers(), Z.lastMesh = this;
                let i = this._cgl.gl.TRIANGLES;
                void 0 !== this._glPrimitive && (i = this._glPrimitive), null !== t.glPrimitive && (i = t.glPrimitive);
                let s = 1,
                    r = this._cgl.profileData.doProfileGlQuery,
                    n = !1;
                if (r) {
                    let e = this._name + " - " + t.getName() + " #" + t.id;
                    this._numInstances && (e += " instanced " + this._numInstances + "x");
                    let i = this._cgl.profileData.glQueryData[e];
                    if (i || (i = {
                            id: e,
                            num: 0
                        }), this._cgl.profileData.glQueryData[e] = i, this._queryExt || !1 === this._queryExt || (this._queryExt = this._cgl.enableExtension("EXT_disjoint_timer_query_webgl2") || !1), this._queryExt) {
                        if (i._drawQuery && this._cgl.gl.getQueryParameter(i._drawQuery, this._cgl.gl.QUERY_RESULT_AVAILABLE)) {
                            const t = this._cgl.gl.getQueryParameter(i._drawQuery, this._cgl.gl.QUERY_RESULT) / 1e6;
                            i._times = i._times || 0, i._times += t, i._numcount++, i.when = performance.now(), i._drawQuery = null, i.queryStarted = !1
                        }
                        i.queryStarted || (i._drawQuery = this._cgl.gl.createQuery(), this._cgl.gl.beginQuery(this._queryExt.TIME_ELAPSED_EXT, i._drawQuery), n = i.queryStarted = !0)
                    }
                }
                if (this.hasFeedbacks() ? this.drawFeedbacks(t, i) : this._bufVerticesIndizes && 0 !== this._bufVerticesIndizes.numItems ? (i == this._cgl.gl.TRIANGLES && (s = 3), 0 === this._numInstances ? this._cgl.gl.drawElements(i, this._bufVerticesIndizes.numItems, this._indexType, 0) : this._cgl.gl.drawElementsInstanced(i, this._bufVerticesIndizes.numItems, this._indexType, 0, this._numInstances)) : (i == this._cgl.gl.TRIANGLES && (s = 3), 0 === this._numInstances ? this._cgl.gl.drawArrays(i, this._bufVertexAttrib.startItem, this._bufVertexAttrib.numItems - this._bufVertexAttrib.startItem) : this._cgl.gl.drawArraysInstanced(i, this._bufVertexAttrib.startItem, this._bufVertexAttrib.numItems, this._numInstances)), this._cgl.debugOneFrame && this._cgl.gl.getError() != this._cgl.gl.NO_ERROR) {
                    this._log.error("mesh draw gl error"), this._log.error("mesh", this), this._log.error("shader", t);
                    for (let e = 0; e < this._cgl.gl.getProgramParameter(t.getProgram(), this._cgl.gl.ACTIVE_ATTRIBUTES); e++) {
                        const i = this._cgl.gl.getActiveAttrib(t.getProgram(), e).name;
                        this._log.error("attrib ", i)
                    }
                }
                this._cgl.profileData.profileMeshNumElements += this._bufVertexAttrib.numItems / s * (this._numInstances || 1), this._cgl.profileData.profileMeshDraw++, r && n && this._cgl.gl.endQuery(this._queryExt.TIME_ELAPSED_EXT), this._cgl.printError("mesh render " + this._name), this.unBind()
            }, $.prototype.setNumInstances = function(t) {
                if (t = Math.max(0, t), this._numInstances != t) {
                    this._numInstances = t;
                    const e = new Float32Array(t);
                    for (let i = 0; i < t; i++) e[i] = i;
                    this.setAttribute(J.SHADER.SHADERVAR_INSTANCE_INDEX, e, 1, {
                        instanced: !0
                    })
                }
            }, $.prototype._disposeAttributes = function() {
                if (this._attributes) {
                    for (let t = 0; t < this._attributes.length; t++) this._attributes[t].buffer && (this._cgl.gl.deleteBuffer(this._attributes[t].buffer), this._attributes[t].buffer = null);
                    this._attributes.length = 0
                }
            }, $.prototype.dispose = function() {
                this._bufVertexAttrib && this._bufVertexAttrib.buffer && this._cgl.gl.deleteBuffer(this._bufVertexAttrib.buffer), this._bufVerticesIndizes && this._cgl.gl.deleteBuffer(this._bufVerticesIndizes), this._bufVerticesIndizes = null, this._disposeAttributes()
            },
            function(t) {
                t.prototype.hasFeedbacks = function() {
                    return this._feedBacks.length > 0
                }, t.prototype.removeFeedbacks = function(t) {
                    this._feedbacks && (this._feedbacks.length = 0, this._feedBacksChanged = !0)
                }, t.prototype.setAttributeFeedback = function() {}, t.prototype.setFeedback = function(t, e, i) {
                    let s = {
                            nameOut: e
                        },
                        r = !1;
                    this.unBindFeedbacks();
                    for (let t = 0; t < this._feedBacks.length; t++) this._feedBacks[t].nameOut == e && (s = this._feedBacks[t], r = !0);
                    return r || (this._feedBacksChanged = !0), s.initialArr = i, s.attrib = t, s.outBuffer && this._cgl.gl.deleteBuffer(s.outBuffer), s.outBuffer = this._cgl.gl.createBuffer(), this._cgl.gl.bindBuffer(this._cgl.gl.ARRAY_BUFFER, s.outBuffer), this._cgl.gl.bufferData(this._cgl.gl.ARRAY_BUFFER, s.initialArr, this._cgl.gl.STATIC_DRAW), this._cgl.gl.bindBuffer(this._cgl.gl.ARRAY_BUFFER, s.attrib.buffer), this._cgl.gl.bufferData(this._cgl.gl.ARRAY_BUFFER, s.initialArr, this._cgl.gl.STATIC_DRAW), r || this._feedBacks.push(s), s
                }, t.prototype.bindFeedback = function(t) {
                    if (!this._feedBacks || 0 === this._feedBacks.length) return; - 1 == this._transformFeedBackLoc && (this._transformFeedBackLoc = this._cgl.gl.createTransformFeedback()), this._cgl.gl.bindTransformFeedback(this._cgl.gl.TRANSFORM_FEEDBACK, this._transformFeedBackLoc);
                    let e = !1;
                    for (let i = 0; i < this._feedBacks.length; i++) {
                        const s = this._feedBacks[i];
                        s.attrib == t && (e = !0, this._cgl.gl.bindBufferBase(this._cgl.gl.TRANSFORM_FEEDBACK_BUFFER, i, s.outBuffer))
                    }
                }, t.prototype.drawFeedbacks = function(t, e) {
                    let i = 0;
                    if (this._feedBacksChanged) {
                        const e = [];
                        for (this._cgl.gl.bindTransformFeedback(this._cgl.gl.TRANSFORM_FEEDBACK, this._transformFeedBackLoc), i = 0; i < this._feedBacks.length; i++) e.push(this._feedBacks[i].nameOut);
                        return t.setFeedbackNames(e), console.log("feedbacknames", e), t.compile(), this._feedBacksChanged = !1, this._cgl.gl.bindTransformFeedback(this._cgl.gl.TRANSFORM_FEEDBACK, null), void console.log("changed finished")
                    }
                    this._cgl.gl.beginTransformFeedback(this.glPrimitive), this._cgl.gl.drawArrays(e, 0, this._feedBacks[0].attrib.numItems), this._cgl.gl.endTransformFeedback(), this.unBindFeedbacks(), this.feedBacksSwapBuffers()
                }, t.prototype.unBindFeedbacks = function() {
                    for (let t = 0; t < this._feedBacks.length; t++) this._cgl.gl.bindBufferBase(this._cgl.gl.TRANSFORM_FEEDBACK_BUFFER, t, null);
                    this._cgl.gl.bindTransformFeedback(this._cgl.gl.TRANSFORM_FEEDBACK, null)
                }, t.prototype.feedBacksSwapBuffers = function() {
                    for (let t = 0; t < this._feedBacks.length; t++) {
                        const e = this._feedBacks[t].attrib.buffer;
                        this._feedBacks[t].attrib.buffer = this._feedBacks[t].outBuffer, this._feedBacks[t].outBuffer = e
                    }
                }
            }($);
        const tt = {
                getSimpleRect: function(t, e) {
                    const i = new H(e);
                    return i.vertices = [1, 1, 0, -1, 1, 0, 1, -1, 0, -1, -1, 0], i.texCoords = [1, 1, 0, 1, 1, 0, 0, 0], i.verticesIndices = [0, 1, 2, 2, 1, 3], i.vertexNormals = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], new $(t, i)
                },
                getSimpleCube: function(t, e) {
                    const i = new H(e);
                    return i.vertices = [-1, -1, 1, 1, -1, 1, 1, 1, 1, -1, 1, 1, -1, -1, -1, 1, -1, -1, 1, 1, -1, -1, 1, -1, -1, 1, -1, 1, 1, -1, 1, 1, 1, -1, 1, 1, -1, -1, -1, 1, -1, -1, 1, -1, 1, -1, -1, 1, 1, -1, -1, 1, -1, 1, 1, 1, 1, 1, 1, -1, -1, -1, -1, -1, -1, 1, -1, 1, 1, -1, 1, -1], i.setTexCoords([0, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 1, 0, 0, 0, 1, 1, 1, 1, 0, 1, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 0, 0, 0]), i.verticesIndices = [0, 1, 2, 0, 2, 3, 4, 5, 6, 4, 6, 7, 8, 9, 10, 8, 10, 11, 12, 13, 14, 12, 14, 15, 16, 17, 18, 16, 18, 19, 20, 21, 22, 20, 22, 23], i.vertexNormals = new Float32Array([0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0]), i.tangents = new Float32Array([0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1]), i.biTangents = new Float32Array([-1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1]), new $(t, i)
                }
            },
            et = function(t, e) {
                this._cgl = t, this._log = new r("cgl_TextureEffect"), t.TextureEffectMesh || this.createMesh(), this._textureSource = null, this._options = e, this.imgCompVer = 0, this.aspectRatio = 1, this._textureTarget = null, this._frameBuf = this._cgl.gl.createFramebuffer(), this._frameBuf2 = this._cgl.gl.createFramebuffer(), this._renderbuffer = this._cgl.gl.createRenderbuffer(), this._renderbuffer2 = this._cgl.gl.createRenderbuffer(), this.switched = !1, this.depth = !1
            };
        et.prototype.getWidth = function() {
            return this._textureSource.width
        }, et.prototype.getHeight = function() {
            return this._textureSource.height
        }, et.prototype.setSourceTexture = function(t) {
            t.pixelFormat == M.PFORMATSTR_R11FG11FB10F && this._cgl.gl.getExtension("EXT_color_buffer_float"), t.pixelFormat == M.PFORMATSTR_RGBA32F && this._cgl.gl.getExtension("EXT_color_buffer_float"), t.pixelFormat == M.PFORMATSTR_RGBA16HF && this._cgl.gl.getExtension("EXT_color_buffer_half_float"), null === t ? (this._textureSource = new M(this._cgl), this._textureSource.setSize(16, 16)) : this._textureSource = t, this._textureSource.compareSettings(this._textureTarget) || (this._textureTarget && this._textureTarget.delete(), this._textureTarget = this._textureSource.clone(), this._cgl.profileData.profileEffectBuffercreate++, this._cgl.gl.bindFramebuffer(this._cgl.gl.FRAMEBUFFER, this._frameBuf), this._cgl.gl.bindRenderbuffer(this._cgl.gl.RENDERBUFFER, this._renderbuffer), this.depth && this._cgl.gl.renderbufferStorage(this._cgl.gl.RENDERBUFFER, this._cgl.gl.DEPTH_COMPONENT16, this._textureSource.width, this._textureSource.height), this._cgl.gl.framebufferTexture2D(this._cgl.gl.FRAMEBUFFER, this._cgl.gl.COLOR_ATTACHMENT0, this._cgl.gl.TEXTURE_2D, this._textureTarget.tex, 0), this.depth && this._cgl.gl.framebufferRenderbuffer(this._cgl.gl.FRAMEBUFFER, this._cgl.gl.DEPTH_ATTACHMENT, this._cgl.gl.RENDERBUFFER, this._renderbuffer), this._cgl.gl.bindTexture(this._cgl.gl.TEXTURE_2D, null), this._cgl.gl.bindRenderbuffer(this._cgl.gl.RENDERBUFFER, null), this._cgl.gl.bindFramebuffer(this._cgl.gl.FRAMEBUFFER, null), this._cgl.gl.bindFramebuffer(this._cgl.gl.FRAMEBUFFER, this._frameBuf2), this._cgl.gl.bindRenderbuffer(this._cgl.gl.RENDERBUFFER, this._renderbuffer2), this.depth && this._cgl.gl.renderbufferStorage(this._cgl.gl.RENDERBUFFER, this._cgl.gl.DEPTH_COMPONENT16, this._textureSource.width, this._textureSource.height), this._cgl.gl.framebufferTexture2D(this._cgl.gl.FRAMEBUFFER, this._cgl.gl.COLOR_ATTACHMENT0, this._cgl.gl.TEXTURE_2D, this._textureSource.tex, 0), this.depth && this._cgl.gl.framebufferRenderbuffer(this._cgl.gl.FRAMEBUFFER, this._cgl.gl.DEPTH_ATTACHMENT, this._cgl.gl.RENDERBUFFER, this._renderbuffer2), this._cgl.gl.bindTexture(this._cgl.gl.TEXTURE_2D, null), this._cgl.gl.bindRenderbuffer(this._cgl.gl.RENDERBUFFER, null), this._cgl.gl.bindFramebuffer(this._cgl.gl.FRAMEBUFFER, null)), this.aspectRatio = this._textureSource.width / this._textureSource.height
        }, et.prototype.continueEffect = function() {
            this._cgl.pushDepthTest(!1), this._cgl.pushModelMatrix(), this._cgl.pushPMatrix(), this._cgl.pushViewPort(0, 0, this.getCurrentTargetTexture().width, this.getCurrentTargetTexture().height), mat4.perspective(this._cgl.pMatrix, 45, this.getCurrentTargetTexture().width / this.getCurrentTargetTexture().height, .1, 1100), this._cgl.pushPMatrix(), mat4.identity(this._cgl.pMatrix), this._cgl.pushViewMatrix(), mat4.identity(this._cgl.vMatrix), this._cgl.pushModelMatrix(), mat4.identity(this._cgl.mMatrix)
        }, et.prototype.startEffect = function(t) {
            this._textureTarget ? (this.switched = !1, this.continueEffect(), t && (this._bgTex = t), this._countEffects = 0) : this._log.warn("effect has no target")
        }, et.prototype.endEffect = function() {
            this._cgl.popDepthTest(), this._cgl.popModelMatrix(), this._cgl.popPMatrix(), this._cgl.popModelMatrix(), this._cgl.popViewMatrix(), this._cgl.popPMatrix(), this._cgl.popViewPort()
        }, et.prototype.bind = function() {
            null !== this._textureSource ? this.switched ? (this._cgl.gl.bindFramebuffer(this._cgl.gl.FRAMEBUFFER, this._frameBuf2), this._cgl.pushGlFrameBuffer(this._frameBuf2)) : (this._cgl.gl.bindFramebuffer(this._cgl.gl.FRAMEBUFFER, this._frameBuf), this._cgl.pushGlFrameBuffer(this._frameBuf)) : this._log.warn("no base texture set!")
        }, et.prototype.finish = function() {
            null !== this._textureSource ? (this._cgl.TextureEffectMesh.render(this._cgl.getShader()), this._cgl.gl.bindFramebuffer(this._cgl.gl.FRAMEBUFFER, this._cgl.popGlFrameBuffer()), this._cgl.profileData.profileTextureEffect++, this._textureTarget.filter == M.FILTER_MIPMAP && (this.switched ? (this._cgl.gl.bindTexture(this._cgl.gl.TEXTURE_2D, this._textureSource.tex), this._textureSource.updateMipMap()) : (this._cgl.gl.bindTexture(this._cgl.gl.TEXTURE_2D, this._textureTarget.tex), this._textureTarget.updateMipMap()), this._cgl.gl.bindTexture(this._cgl.gl.TEXTURE_2D, null)), this.switched = !this.switched, this._countEffects++) : this._log.warn("no base texture set!")
        }, et.prototype.getCurrentTargetTexture = function() {
            return this.switched ? this._textureSource : this._textureTarget
        }, et.prototype.getCurrentSourceTexture = function() {
            return 0 == this._countEffects && this._bgTex ? this._bgTex : this.switched ? this._textureTarget : this._textureSource
        }, et.prototype.delete = function() {
            this._textureTarget && this._textureTarget.delete(), this._textureSource && this._textureSource.delete(), this._cgl.gl.deleteRenderbuffer(this._renderbuffer), this._cgl.gl.deleteFramebuffer(this._frameBuf)
        }, et.prototype.createMesh = function() {
            this._cgl.TextureEffectMesh = tt.getSimpleRect(this._cgl, "texEffectRect")
        }, et.checkOpNotInTextureEffect = function(t) {
            return !(!t.patch.cgl || (t.uiAttribs.error && !t.patch.cgl.currentTextureEffect ? (t.setUiError("textureeffect", null), 0) : t.patch.cgl.currentTextureEffect && (t.patch.cgl.currentTextureEffect && !t.uiAttribs.error ? (t.setUiError("textureeffect", "This op can not be a child of a ImageCompose/texture effect! imagecompose should only have textureeffect childs.", 0), 1) : t.patch.cgl.currentTextureEffect)))
        }, et.checkOpInEffect = function(t, e) {
            if (e = e || 0, t.patch.cgl.currentTextureEffect) {
                if (t.uiAttribs.uierrors && t.patch.cgl.currentTextureEffect.imgCompVer >= e) return t.setUiError("texeffect", null), !0;
                e && t.patch.cgl.currentTextureEffect.imgCompVer < e && t.setUiError("texeffect", "This op must be a child of an ImageCompose op with version >=" + e + ' <span class="button-small" onclick="gui.patchView.downGradeOp(\'' + t.id + "','" + t.name + "')\">Downgrade</span> to previous version", 1)
            }
            return !!t.patch.cgl.currentTextureEffect || (t.patch.cgl.currentTextureEffect || t.uiAttribs.uierrors && 0 != t.uiAttribs.uierrors.length ? !!t.patch.cgl.currentTextureEffect : (t.setUiError("texeffect", 'This op must be a child of an ImageCompose op! More infos <a href="https://docs.cables.gl/image_composition/image_composition.html" target="_blank">here</a>. ', 1), !1))
        }, et.getBlendCode = function(t) {
            let e = "".endl() + "vec3 _blend(vec3 base,vec3 blend)".endl() + "{".endl() + "   vec3 colNew=blend;".endl() + "   #ifdef BM_MULTIPLY".endl() + "       colNew=base*blend;".endl() + "   #endif".endl() + "   #ifdef BM_MULTIPLY_INV".endl() + "       colNew=base* vec3(1.0)-blend;".endl() + "   #endif".endl() + "   #ifdef BM_AVERAGE".endl() + "       colNew=((base + blend) / 2.0);".endl() + "   #endif".endl() + "   #ifdef BM_ADD".endl() + "       colNew=min(base + blend, vec3(1.0));".endl() + "   #endif".endl() + "   #ifdef BM_SUBTRACT_ONE".endl() + "       colNew=max(base + blend - vec3(1.0), vec3(0.0));".endl() + "   #endif".endl() + "   #ifdef BM_SUBTRACT".endl() + "       colNew=base - blend;".endl() + "   #endif".endl() + "   #ifdef BM_DIFFERENCE".endl() + "       colNew=abs(base - blend);".endl() + "   #endif".endl() + "   #ifdef BM_NEGATION".endl() + "       colNew=(vec3(1.0) - abs(vec3(1.0) - base - blend));".endl() + "   #endif".endl() + "   #ifdef BM_EXCLUSION".endl() + "       colNew=(base + blend - 2.0 * base * blend);".endl() + "   #endif".endl() + "   #ifdef BM_LIGHTEN".endl() + "       colNew=max(blend, base);".endl() + "   #endif".endl() + "   #ifdef BM_DARKEN".endl() + "       colNew=min(blend, base);".endl() + "   #endif".endl() + "   #ifdef BM_OVERLAY".endl() + "      #define BlendOverlayf(base, blend)  (base < 0.5 ? (2.0 * base * blend) : (1.0 - 2.0 * (1.0 - base) * (1.0 - blend)))".endl() + "      colNew=vec3(BlendOverlayf(base.r, blend.r),BlendOverlayf(base.g, blend.g),BlendOverlayf(base.b, blend.b));".endl() + "   #endif".endl() + "   #ifdef BM_SCREEN".endl() + "      #define BlendScreenf(base, blend)       (1.0 - ((1.0 - base) * (1.0 - blend)))".endl() + "      colNew=vec3(BlendScreenf(base.r, blend.r),BlendScreenf(base.g, blend.g),BlendScreenf(base.b, blend.b));".endl() + "   #endif".endl() + "   #ifdef BM_SOFTLIGHT".endl() + "      #define BlendSoftLightf(base, blend)    ((blend < 0.5) ? (2.0 * base * blend + base * base * (1.0 - 2.0 * blend)) : (sqrt(base) * (2.0 * blend - 1.0) + 2.0 * base * (1.0 - blend)))".endl() + "      colNew=vec3(BlendSoftLightf(base.r, blend.r),BlendSoftLightf(base.g, blend.g),BlendSoftLightf(base.b, blend.b));".endl() + "   #endif".endl() + "   #ifdef BM_HARDLIGHT".endl() + "      #define BlendOverlayf(base, blend)  (base < 0.5 ? (2.0 * base * blend) : (1.0 - 2.0 * (1.0 - base) * (1.0 - blend)))".endl() + "      colNew=vec3(BlendOverlayf(base.r, blend.r),BlendOverlayf(base.g, blend.g),BlendOverlayf(base.b, blend.b));".endl() + "   #endif".endl() + "   #ifdef BM_COLORDODGE".endl() + "      #define BlendColorDodgef(base, blend)   ((blend == 1.0) ? blend : min(base / (1.0 - blend), 1.0))".endl() + "      colNew=vec3(BlendColorDodgef(base.r, blend.r),BlendColorDodgef(base.g, blend.g),BlendColorDodgef(base.b, blend.b));".endl() + "   #endif".endl() + "   #ifdef BM_COLORBURN".endl() + "      #define BlendColorBurnf(base, blend)    ((blend == 0.0) ? blend : max((1.0 - ((1.0 - base) / blend)), 0.0))".endl() + "      colNew=vec3(BlendColorBurnf(base.r, blend.r),BlendColorBurnf(base.g, blend.g),BlendColorBurnf(base.b, blend.b));".endl() + "   #endif".endl() + "   return colNew;".endl() + "}".endl();
            return t || (e += "vec4 cgl_blend(vec4 oldColor,vec4 newColor,float amount)".endl() + "{".endl() + "vec4 col=vec4( _blend(oldColor.rgb,newColor.rgb) ,1.0);".endl() + "col=vec4( mix( col.rgb, oldColor.rgb ,1.0-oldColor.a*amount),1.0);".endl() + "return col;".endl() + "}".endl()), t >= 3 && (e += "vec4 cgl_blendPixel(vec4 base,vec4 col,float amount)".endl() + "{".endl() + "#ifdef BM_MATH_ADD".endl() + "   return vec4(base.rgb+col.rgb*amount,1.0);".endl() + "#endif".endl() + "#ifdef BM_MATH_SUB".endl() + "   return vec4(base.rgb-col.rgb*amount,1.0);".endl() + "#endif".endl() + "#ifdef BM_MATH_MUL".endl() + "   return vec4(base.rgb*col.rgb*amount,1.0);".endl() + "#endif".endl() + "#ifdef BM_MATH_DIV".endl() + "   return vec4(base.rgb/col.rgb*amount,1.0);".endl() + "#endif".endl() + "#ifndef BM_MATH".endl() + "vec3 colNew=_blend(base.rgb,col.rgb);".endl() + "float newA=clamp(base.a+(col.a*amount),0.,1.);".endl() + "#ifdef BM_ALPHAMASKED".endl() + "newA=base.a;".endl() + "#endif".endl() + "return vec4(".endl() + "mix(colNew,base.rgb,1.0-(amount*col.a)),".endl() + "newA);".endl() + "#endif".endl() + "}".endl()), e
        }, et.onChangeBlendSelect = function(t, e, i) {
            t.toggleDefine("BM_NORMAL", "normal" == e), t.toggleDefine("BM_MULTIPLY", "multiply" == e), t.toggleDefine("BM_MULTIPLY_INV", "multiply invert" == e), t.toggleDefine("BM_AVERAGE", "average" == e), t.toggleDefine("BM_ADD", "add" == e), t.toggleDefine("BM_SUBTRACT_ONE", "subtract one" == e), t.toggleDefine("BM_SUBTRACT", "subtract" == e), t.toggleDefine("BM_DIFFERENCE", "difference" == e), t.toggleDefine("BM_NEGATION", "negation" == e), t.toggleDefine("BM_EXCLUSION", "exclusion" == e), t.toggleDefine("BM_LIGHTEN", "lighten" == e), t.toggleDefine("BM_DARKEN", "darken" == e), t.toggleDefine("BM_OVERLAY", "overlay" == e), t.toggleDefine("BM_SCREEN", "screen" == e), t.toggleDefine("BM_SOFTLIGHT", "softlight" == e), t.toggleDefine("BM_HARDLIGHT", "hardlight" == e), t.toggleDefine("BM_COLORDODGE", "color dodge" == e), t.toggleDefine("BM_COLORBURN", "color burn" == e), t.toggleDefine("BM_MATH_ADD", "Math Add" == e), t.toggleDefine("BM_MATH_SUB", "Math Subtract" == e), t.toggleDefine("BM_MATH_MUL", "Math Multiply" == e), t.toggleDefine("BM_MATH_DIV", "Math Divide" == e), t.toggleDefine("BM_MATH", 0 == e.indexOf("Math ")), t.toggleDefine("BM_ALPHAMASKED", i)
        }, et.AddBlendSelect = function(t, e, i) {
            return t.inValueSelect(e || "Blend Mode", ["normal", "lighten", "darken", "multiply", "multiply invert", "average", "add", "subtract", "difference", "negation", "exclusion", "overlay", "screen", "color dodge", "color burn", "softlight", "hardlight", "subtract one", "Math Add", "Math Subtract", "Math Multiply", "Math Divide"], i || "normal")
        }, et.AddBlendAlphaMask = function(t, e, i) {
            return t.inSwitch(e || "Alpha Mask", ["Off", "On"], i || "Off")
        }, et.setupBlending = function(t, e, i, s, r) {
            const n = () => {
                let s = !1;
                r && (s = "On" == r.get()), et.onChangeBlendSelect(e, i.get(), s);
                let n = i.get();
                "normal" == n ? n = null : "multiply" == n ? n = "mul" : "multiply invert" == n ? n = "mulinv" : "lighten" == n ? n = "light" : "darken" == n ? n = "darken" : "average" == n ? n = "avg" : "subtract one" == n ? n = "sub one" : "subtract" == n ? n = "sub" : "difference" == n ? n = "diff" : "negation" == n ? n = "neg" : "exclusion" == n ? n = "exc" : "overlay" == n ? n = "ovl" : "color dodge" == n ? n = "dodge" : "color burn" == n ? n = "burn" : "softlight" == n ? n = "soft" : "hardlight" == n ? n = "hard" : "Math Add" == n ? n = "+" : "Math Subtract" == n ? n = "-" : "Math Multiply" == n ? n = "*" : "Math Divide" == n && (n = "/"), t.setUiAttrib({
                    extendTitle: n
                })
            };
            t.setPortGroup("Blending", [i, s, r]);
            let o = !1;
            i.onChange = n, r && (r.onChange = n, o = "On" == r.get()), et.onChangeBlendSelect(e, i.get(), o)
        };
        const it = {
                "CGL.BLENDMODES": function() {
                    this.name = "blendmodes", this.srcHeadFrag = et.getBlendCode()
                },
                "CGL.BLENDMODES3": function() {
                    this.name = "blendmodes3", this.srcHeadFrag = et.getBlendCode(3)
                },
                "CGL.LUMINANCE": function() {
                    this.name = "luminance", this.srcHeadFrag = "".endl() + "float cgl_luminance(vec3 c)".endl() + "{".endl() + "    return dot(vec3(0.2126,0.7152,0.0722),c);".endl() + "}".endl()
                },
                "CGL.RANDOM_OLD": function() {
                    this.name = "randomNumber", this.srcHeadFrag = "".endl() + "float cgl_random(vec2 co)".endl() + "{".endl() + "    return fract(sin(dot(co.xy ,vec2(12.9898,4.1414))) * 432758.5453);".endl() + "}".endl() + "vec3 cgl_random3(vec2 co)".endl() + "{".endl() + "    return vec3( cgl_random(co),cgl_random(co+0.5711),cgl_random(co+1.5711));".endl() + "}"
                },
                "CGL.RANDOM_LOW": function() {
                    this.name = "randomNumber", this.srcHeadFrag = "".endl() + "float cgl_random(vec2 co)".endl() + "{".endl() + "    return fract(sin(dot(co.xy ,vec2(12.9898,4.1414))) * 358.5453);".endl() + "}".endl() + "vec3 cgl_random3(vec2 co)".endl() + "{".endl() + "    return vec3( cgl_random(co),cgl_random(co+0.5711),cgl_random(co+1.5711));".endl() + "}"
                },
                "CGL.RANDOM_TEX": function() {
                    this.name = "randomNumbertex", this.srcHeadFrag = "".endl() + "UNI sampler2D CGLRNDTEX;".endl() + "float cgl_random(vec2 co)".endl() + "{".endl() + "    return texture(CGLRNDTEX,co*5711.0).r;".endl() + "}".endl() + "vec3 cgl_random3(vec2 co)".endl() + "{".endl() + "    return texture(CGLRNDTEX,co*5711.0).rgb;".endl() + "}", this.initUniforms = function(t) {
                        return [new Q(t, "t", "CGLRNDTEX", 7)]
                    }, this.onBind = function(t, e) {
                        M.getRandomTexture(t), t.setTexture(7, M.getRandomTexture(t).tex)
                    }
                }
            },
            st = function() {
                return window.performance.now()
            },
            rt = function() {
                return st()
            },
            nt = function() {
                CABLES.EventTarget.apply(this), this._timeStart = st(), this._timeOffset = 0, this._currentTime = 0, this._lastTime = 0, this._paused = !0, this._delay = 0, this.overwriteTime = -1
            };
        nt.prototype._getTime = function() {
            return this._lastTime = (st() - this._timeStart) / 1e3, this._lastTime + this._timeOffset
        }, nt.prototype.setDelay = function(t) {
            this._delay = t, this.emitEvent("timeChange")
        }, nt.prototype.isPlaying = function() {
            return !this._paused
        }, nt.prototype.update = function() {
            if (!this._paused) return this._currentTime = this._getTime(), this._currentTime
        }, nt.prototype.getMillis = function() {
            return 1e3 * this.get()
        }, nt.prototype.get = nt.prototype.getTime = function() {
            return this.overwriteTime >= 0 ? this.overwriteTime - this._delay : this._currentTime - this._delay
        }, nt.prototype.togglePlay = function() {
            this._paused ? this.play() : this.pause()
        }, nt.prototype.setTime = function(t) {
            (isNaN(t) || t < 0) && (t = 0), this._timeStart = st(), this._timeOffset = t, this._currentTime = t, this.emitEvent("timeChange")
        }, nt.prototype.setOffset = function(t) {
            this._currentTime + t < 0 ? (this._timeStart = st(), this._timeOffset = 0, this._currentTime = 0) : (this._timeOffset += t, this._currentTime = this._lastTime + this._timeOffset), this.emitEvent("timeChange")
        }, nt.prototype.play = function() {
            this._timeStart = st(), this._paused = !1, this.emitEvent("playPause")
        }, nt.prototype.pause = function() {
            this._timeOffset = this._currentTime, this._paused = !0, this.emitEvent("playPause")
        };
        const ot = Math.PI / 180,
            at = (Math.PI, -1 != window.navigator.userAgent.indexOf("Windows")),
            ht = function(t) {
                let e;
                if (t.wheelDelta) e = t.wheelDelta % 120 - 0 == -0 ? t.wheelDelta / 120 : t.wheelDelta / 30, e *= -1.5, at && (e *= 2);
                else {
                    let i = t.deltaY;
                    t.shiftKey && (i = t.deltaX);
                    const s = i || t.detail;
                    e = -(s % 3 ? 10 * s : s / 3), e *= -3
                }
                return e > 20 && (e = 20), e < -20 && (e = -20), e
            },
            lt = ht,
            ct = ht,
            ut = {
                "&": "&amp;",
                "<": "&lt;",
                ">": "&gt;",
                '"': "&quot;",
                "'": "&#39;"
            },
            _t = /[&<>"']/g,
            pt = RegExp(_t.source);
        let gt = 0;
        const dt = function(t, e) {
            if (!t) throw new Error("shader constructed without cgl " + e);
            this._log = new r("cgl_shader"), this._cgl = t, e || this._log.stack("no shader name given"), this._name = e || "unknown", this.glslVersion = 0, t.glVersion > 1 && (this.glslVersion = 300), this._materialId = ++gt, this.id = A(), this._isValid = !0, this._program = null, this._uniforms = [], this._drawBuffers = [!0], this._defines = [], this._needsRecompile = !0, this._compileReason = "initial", this.ignoreMissingUniforms = !1, this._projMatrixUniform = null, this._mvMatrixUniform = null, this._mMatrixUniform = null, this._vMatrixUniform = null, this._camPosUniform = null, this._normalMatrixUniform = null, this._inverseViewMatrixUniform = null, this._attrVertexPos = -1, this.precision = t.patch.config.glslPrecision || "highp", this._pMatrixState = -1, this._vMatrixState = -1, this._countMissingUniforms = 0, this._modGroupCount = 0, this._feedBackNames = [], this._attributes = [], this.glPrimitive = null, this.offScreenPass = !1, this._extensions = [], this.srcVert = this.getDefaultVertexShader(), this.srcFrag = this.getDefaultFragmentShader(), this.lastCompile = 0, this._moduleNames = [], this._modules = [], this._moduleNumId = 0, this._libs = [], this._structNames = [], this._structUniformNames = [], this._textureStackUni = [], this._textureStackTex = [], this._textureStackType = [], this._textureStackTexCgl = [], this._tempNormalMatrix = mat4.create(), this._tempCamPosMatrix = mat4.create(), this._tempInverseViewMatrix = mat4.create(), this._tempInverseProjMatrix = mat4.create(), this.setModules(["MODULE_VERTEX_POSITION", "MODULE_COLOR", "MODULE_BEGIN_FRAG"])
        };
        dt.prototype.isValid = function() {
            return this._isValid
        }, dt.prototype.getCgl = function() {
            return this._cgl
        }, dt.prototype.getName = function() {
            return this._name
        }, dt.prototype.enableExtension = function(t) {
            this.setWhyCompile("enable extension " + t), this._needsRecompile = !0, this._extensions.push(t)
        }, dt.prototype.getAttrVertexPos = function() {
            return this._attrVertexPos
        }, dt.prototype.hasTextureUniforms = function() {
            for (let t = 0; t < this._uniforms.length; t++)
                if ("t" == this._uniforms[t].getType()) return !0;
            return !1
        }, dt.prototype.setWhyCompile = function(t) {
            this._compileReason = t
        }, dt.prototype.copyUniformValues = function(t) {
            for (let e = 0; e < t._uniforms.length; e++) this._uniforms[e] ? (-1 != t._uniforms[e].getName().indexOf("pathPoints") && console.log("copyUniformValues", t._uniforms[e].getName(), t._uniforms[e].getValue()), this.getUniform(t._uniforms[e].getName()).set(t._uniforms[e].getValue())) : this._log.log("unknown uniform?!");
            this.popTextures();
            for (let e = 0; e < t._textureStackUni.length; e++) this._textureStackUni[e] = t._textureStackUni[e], this._textureStackTex[e] = t._textureStackTex[e], this._textureStackType[e] = t._textureStackType[e], this._textureStackTexCgl[e] = t._textureStackTexCgl[e]
        }, dt.prototype.copy = function() {
            const t = new dt(this._cgl, this._name + " copy");
            t.setSource(this.srcVert, this.srcFrag), t._modules = JSON.parse(JSON.stringify(this._modules)), t._defines = JSON.parse(JSON.stringify(this._defines)), t._modGroupCount = this._modGroupCount, t._moduleNames = this._moduleNames, t.glPrimitive = this.glPrimitive, t.offScreenPass = this.offScreenPass, t._extensions = this._extensions, t.wireframe = this.wireframe, t._attributes = this._attributes;
            for (let e = 0; e < this._uniforms.length; e++) this._uniforms[e].copy(t).resetLoc();
            return this.setWhyCompile("copy"), t._needsRecompile = !0, t
        }, dt.prototype.setSource = function(t, e) {
            this.srcVert = t, this.srcFrag = e, this.setWhyCompile("Source changed"), this._needsRecompile = !0, this._isValid = !0
        }, dt.prototype._addLibs = function(t) {
            for (const e in it)
                if (t.indexOf(e) > -1) {
                    const i = new it[e];
                    t = t.replace("{{" + e + "}}", i.srcHeadFrag), this._libs.push(i), i.initUniforms && i.initUniforms(this)
                } return t
        }, dt.prototype.createStructUniforms = function() {
            let t = "",
                e = "";
            this._structNames = [], this._injectedStringsFrag = {}, this._injectedStringsVert = {}, this._structUniformNamesIndicesFrag = [], this._structUniformNamesIndicesVert = [];
            for (let i = 0; i < this._uniforms.length; i++)
                if (this._uniforms[i].isStructMember()) {
                    const s = "{{INJECTION_POINT_STRUCT_" + this._uniforms[i]._structName + "}}";
                    if (-1 === this._structNames.indexOf(this._uniforms[i]._structName)) {
                        const r = "struct " + this._uniforms[i]._structName + " {".endl() + s + "};".endl().endl();
                        "both" !== this._uniforms[i].getShaderType() && "frag" !== this._uniforms[i].getShaderType() || (t = t.concat(r)), "both" !== this._uniforms[i].getShaderType() && "vert" !== this._uniforms[i].getShaderType() || (e = e.concat(r)), this._structNames.push(this._uniforms[i]._structName), this._injectedStringsFrag[this._uniforms[i]._structName] = [], this._injectedStringsVert[this._uniforms[i]._structName] = []
                    }
                    let r = "";
                    this._uniforms[i].comment && (r = " // " + this._uniforms[i].comment);
                    let n = "";
                    if (null == this._uniforms[i].getGlslTypeString() && (n += "//"), n += "  " + this._uniforms[i].getGlslTypeString() + " " + this._uniforms[i]._propertyName + ";" + r, "both" === this._uniforms[i].getShaderType()) {
                        if (-1 === this._injectedStringsFrag[this._uniforms[i]._structName].indexOf(n) && -1 === this._injectedStringsVert[this._uniforms[i]._structName].indexOf(n)) {
                            const r = t.lastIndexOf(s),
                                o = e.lastIndexOf(s);
                            t = t.slice(0, r) + n + t.slice(r - 1), e = e.slice(0, o) + n + e.slice(o - 1), this._injectedStringsFrag[this._uniforms[i]._structName].push(n), this._injectedStringsVert[this._uniforms[i]._structName].push(n)
                        } - 1 === this._structUniformNamesIndicesFrag.indexOf(i) && this._structUniformNamesIndicesFrag.push(i), -1 === this._structUniformNamesIndicesVert.indexOf(i) && this._structUniformNamesIndicesVert.push(i)
                    } else if ("frag" === this._uniforms[i].getShaderType()) {
                        if (-1 === this._injectedStringsFrag[this._uniforms[i]._structName].indexOf(n)) {
                            const e = t.lastIndexOf(s);
                            t = t.slice(0, e) + n + t.slice(e - 1), this._injectedStringsFrag[this._uniforms[i]._structName].push(n)
                        } - 1 === this._structUniformNamesIndicesFrag.indexOf(i) && this._structUniformNamesIndicesFrag.push(i)
                    } else if ("vert" === this._uniforms[i].getShaderType()) {
                        if (-1 === this._injectedStringsVert[this._uniforms[i]._structName].indexOf(n)) {
                            const t = e.lastIndexOf(s);
                            e = e.slice(0, t) + n + e.slice(t - 1), this._injectedStringsVert[this._uniforms[i]._structName].push(n)
                        } - 1 === this._structUniformNamesIndicesVert.indexOf(i) && this._structUniformNamesIndicesVert.push(i)
                    }
                } this._uniDeclarationsFrag = [], this._uniDeclarationsVert = [];
            for (let e = 0; e < this._structUniformNamesIndicesFrag.length; e += 1) {
                const i = this._structUniformNamesIndicesFrag[e],
                    s = "UNI " + this._uniforms[i]._structName + " " + this._uniforms[i]._structUniformName + ";".endl();
                if (-1 === this._uniDeclarationsFrag.indexOf(s)) {
                    const e = "{{INJECTION_POINT_STRUCT_" + this._uniforms[i]._structName + "}}";
                    t = t.replace(e, ""), t += s, this._uniDeclarationsFrag.push(s)
                }
            }
            for (let t = 0; t < this._structUniformNamesIndicesVert.length; t += 1) {
                const i = this._structUniformNamesIndicesVert[t],
                    s = "UNI " + this._uniforms[i]._structName + " " + this._uniforms[i]._structUniformName + ";".endl();
                if (-1 === this._uniDeclarationsVert.indexOf(s)) {
                    const t = "{{INJECTION_POINT_STRUCT_" + this._uniforms[i]._structName + "}}";
                    e = e.replace(t, ""), e += s, this._uniDeclarationsVert.push(s)
                }
            }
            return [e, t]
        }, dt.prototype._getAttrSrc = function(t, e) {
            const i = {};
            return t.name && t.type && (i.srcHeadVert = "", e || (i.srcHeadVert += "#ifndef ATTRIB_" + t.name.endl()), i.srcHeadVert += "#define ATTRIB_" + t.name.endl(), i.srcHeadVert += "IN " + t.type + " " + t.name + ";".endl(), e || (i.srcHeadVert += "#endif".endl()), t.nameFrag && (i.srcHeadVert += "", e || (i.srcHeadVert += "#ifndef ATTRIB_" + t.nameFrag.endl()), i.srcHeadVert += "#define ATTRIB_" + t.nameFrag.endl(), i.srcHeadVert += "OUT " + t.type + " " + t.nameFrag + ";".endl(), e || (i.srcHeadVert += "#endif".endl()), i.srcVert = "".endl() + t.nameFrag + "=" + t.name + ";", i.srcHeadFrag = "", e || (i.srcHeadFrag += "#ifndef ATTRIB_" + t.nameFrag.endl()), i.srcHeadFrag += "#define ATTRIB_" + t.nameFrag.endl(), i.srcHeadFrag += "IN " + t.type + " " + t.nameFrag + ";".endl(), e || (i.srcHeadFrag += "#endif".endl()))), i
        }, dt.prototype.compile = function() {
            if (this._cgl.aborted) return;
            const t = performance.now();
            this._cgl.profileData.profileShaderCompiles++, this._cgl.profileData.profileShaderCompileName = this._name + " [" + this._compileReason + "]";
            let e = "";
            if (this._extensions)
                for (let t = 0; t < this._extensions.length; t++) e += "#extension " + this._extensions[t] + " : enable".endl();
            let i = "";
            this._defines.length && (i = "\n// cgl generated".endl());
            for (let t = 0; t < this._defines.length; t++) i += "#define " + this._defines[t][0] + " " + this._defines[t][1] + "".endl();
            const s = this.createStructUniforms();
            if (this._cgl.profileData.addHeavyEvent("shader compile", this._name + " [" + this._compileReason + "]"), this._compileReason = "", this._uniforms) {
                const t = this._uniforms.map((t => t._name)),
                    e = [];
                for (let i = 0; i < this._uniforms.length; i++) {
                    const s = this._uniforms[i];
                    t.indexOf(s._name, i + 1) > -1 && e.push(i)
                }
                for (let t = this._uniforms.length - 1; t >= 0; t -= 1) e.indexOf(t) > -1 ? this._uniforms.splice(t, 1) : this._uniforms[t].resetLoc()
            }
            this._cgl.printError("uniform resets"), this.hasTextureUniforms() && (i += "#define HAS_TEXTURES".endl());
            let r = "",
                n = "";
            this.srcFrag || (this._log.error("[cgl shader] has no fragment source!", this), this.srcVert = this.getDefaultVertexShader(), this.srcFrag = this.getDefaultFragmentShader()), 300 == this.glslVersion ? (r = "#version 300 es".endl() + "// ".endl() + "// vertex shader " + this._name.endl() + "// ".endl() + "precision " + this.precision + " float;".endl() + "precision " + this.precision + " sampler2D;".endl() + "".endl() + "#define WEBGL2".endl() + "#define texture2D texture".endl() + "#define UNI uniform".endl() + "#define IN in".endl() + "#define OUT out".endl(), n = "#version 300 es".endl() + "// ".endl() + "// fragment shader " + this._name.endl() + "// ".endl() + "precision " + this.precision + " float;".endl() + "precision " + this.precision + " sampler2D;".endl() + "".endl() + "#define WEBGL2".endl() + "#define texture2D texture".endl() + "#define IN in".endl() + "#define OUT out".endl() + "#define UNI uniform".endl() + "{{DRAWBUFFER}}".endl()) : (n = "".endl() + "// ".endl() + "// fragment shader " + this._name.endl() + "// ".endl() + "#define WEBGL1".endl() + "#define texture texture2D".endl() + "#define outColor gl_FragColor".endl() + "#define IN varying".endl() + "#define UNI uniform".endl(), r = "".endl() + "// ".endl() + "// vertex shader " + this._name.endl() + "// ".endl() + "#define WEBGL1".endl() + "#define texture texture2D".endl() + "#define OUT varying".endl() + "#define IN attribute".endl() + "#define UNI uniform".endl());
            let o = "\n// cgl generated".endl(),
                a = "\n// cgl generated".endl();
            n += "\n// active mods: --------------- ", r += "\n// active mods: --------------- ";
            let h = !1,
                l = !1;
            for (let t = 0; t < this._moduleNames.length; t++)
                for (let e = 0; e < this._modules.length; e++) this._modules[e].name == this._moduleNames[t] && ((this._modules[e].srcBodyFrag || this._modules[e].srcHeadFrag) && (h = !0, n += "\n// " + t + "." + e + ". " + this._modules[e].title + " (" + this._modules[e].name + ")"), (this._modules[e].srcBodyVert || this._modules[e].srcHeadVert) && (r += "\n// " + t + "." + e + ". " + this._modules[e].title + " (" + this._modules[e].name + ")", l = !0));
            l || (n += "\n// no mods used..."), h || (n += "\n// no mods used..."), n += "\n", r += "\n";
            for (let t = 0; t < this._uniforms.length; t++)
                if (this._uniforms[t].shaderType && !this._uniforms[t].isStructMember()) {
                    let e = "";
                    this._uniforms[t].getGlslTypeString() || (e += "// "), e += "UNI " + this._uniforms[t].getGlslTypeString() + " " + this._uniforms[t].getName();
                    let i = "";
                    this._uniforms[t].comment && (i = " // " + this._uniforms[t].comment), "vert" != this._uniforms[t].shaderType && "both" != this._uniforms[t].shaderType || -1 == this.srcVert.indexOf(e) && -1 == this.srcVert.indexOf("uniform " + this._uniforms[t].getGlslTypeString() + " " + this._uniforms[t].getName()) && (o += e + ";" + i.endl()), "frag" != this._uniforms[t].shaderType && "both" != this._uniforms[t].shaderType || -1 == this.srcFrag.indexOf(e) && -1 == this.srcFrag.indexOf("uniform " + this._uniforms[t].getGlslTypeString() + " " + this._uniforms[t].getName()) && (a += e + ";" + i.endl())
                } let c = 0,
                u = 0;
            for (let t = 0; t < this._uniforms.length; t++) this._uniforms[t].shaderType && !this._uniforms[t].isStructMember() && ("vert" != this._uniforms[t].shaderType && "both" != this._uniforms[t].shaderType || u++, "frag" != this._uniforms[t].shaderType && "both" != this._uniforms[t].shaderType || c++);
            c >= this._cgl.maxUniformsFrag && this._log.warn("[cgl_shader] num uniforms frag: " + c + " / " + this._cgl.maxUniformsFrag), u >= this._cgl.maxUniformsVert && this._log.warn("[cgl_shader] num uniforms vert: " + u + " / " + this._cgl.maxUniformsVert), -1 == n.indexOf("precision") && (n = "precision " + this.precision + " float;".endl() + n), -1 == r.indexOf("precision") && (r = "precision " + this.precision + " float;".endl() + r), /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) && (n += "#define MOBILE".endl(), r += "#define MOBILE".endl()), r = e + r + i + s[0] + o + "\n// -- \n" + this.srcVert, n = e + n + i + s[1] + a + "\n// -- \n" + this.srcFrag;
            let _ = "",
                p = "";
            this._modules.sort((function(t, e) {
                return t.group - e.group
            })), this._modules.sort((function(t, e) {
                return t.priority || 0 - e.priority || 0
            }));
            let g = !1;
            for (let t = 0; t < this._moduleNames.length; t++) {
                let e = "",
                    i = "";
                if (!g) {
                    g = !0;
                    for (let t = 0; t < this._attributes.length; t++) {
                        const i = this._getAttrSrc(this._attributes[t], !0);
                        i.srcHeadVert && (_ += i.srcHeadVert), i.srcVert && (e += i.srcVert), i.srcHeadFrag && (p += i.srcHeadFrag)
                    }
                }
                for (let s = 0; s < this._modules.length; s++) {
                    const r = this._modules[s];
                    if (r.name == this._moduleNames[t]) {
                        if (_ += "\n//---- MOD: group:" + r.group + ": idx:" + s + " - prfx:" + r.prefix + " - " + r.title + " ------\n", p += "\n//---- MOD: group:" + r.group + ": idx:" + s + " - prfx:" + r.prefix + " - " + r.title + " ------\n", e += "\n\n//---- MOD: " + r.title + " / " + r.priority + " ------\n", i += "\n\n//---- MOD: " + r.title + " / " + r.priority + " ------\n", r.attributes)
                            for (let t = 0; t < r.attributes.length; t++) {
                                const i = this._getAttrSrc(r.attributes[t], !1);
                                i.srcHeadVert && (_ += i.srcHeadVert), i.srcVert && (e += i.srcVert), i.srcHeadFrag && (p += i.srcHeadFrag)
                            }
                        _ += r.srcHeadVert || "", p += r.srcHeadFrag || "", e += r.srcBodyVert || "", i += r.srcBodyFrag || "", _ += "\n//---- end mod ------\n", p += "\n//---- end mod ------\n", e += "\n//---- end mod ------\n", i += "\n//---- end mod ------\n", e = e.replace(/{{mod}}/g, r.prefix), i = i.replace(/{{mod}}/g, r.prefix), _ = _.replace(/{{mod}}/g, r.prefix), p = p.replace(/{{mod}}/g, r.prefix), e = e.replace(/MOD_/g, r.prefix), i = i.replace(/MOD_/g, r.prefix), _ = _.replace(/MOD_/g, r.prefix), p = p.replace(/MOD_/g, r.prefix)
                    }
                }
                r = r.replace("{{" + this._moduleNames[t] + "}}", e), n = n.replace("{{" + this._moduleNames[t] + "}}", i)
            }
            r = r.replace("{{MODULES_HEAD}}", _), n = n.replace("{{MODULES_HEAD}}", p), r = this._addLibs(r), n = this._addLibs(n);
            let d = "";
            for (let t = 0; t < 16; t++) n.indexOf("outColor" + t) > -1 && (this._drawBuffers[t] = !0);
            if (1 == this._drawBuffers.length) d = "out vec4 outColor;".endl(), d += "#define gl_FragColor outColor".endl();
            else {
                d += "#define MULTI_COLORTARGETS".endl(), d += "vec4 outColor;".endl();
                let t = 0;
                for (let e = 0; e < this._drawBuffers.length; e++) 0 == t && (d += "#define gl_FragColor outColor" + e + "".endl()), d += "layout(location = " + e + ") out vec4 outColor" + e + ";".endl(), t++
            }
            if (n = n.replace("{{DRAWBUFFER}}", d), this._program) {
                this._program = this._createProgram(r, n), this._projMatrixUniform = null;
                for (let t = 0; t < this._uniforms.length; t++) this._uniforms[t].resetLoc()
            } else this._program = this._createProgram(r, n);
            this.finalShaderFrag = n, this.finalShaderVert = r, Z.lastMesh = null, Z.lastShader = null, this._countMissingUniforms = 0, this._needsRecompile = !1, this.lastCompile = rt(), this._cgl.profileData.shaderCompileTime += performance.now() - t
        }, dt.hasChanged = function() {
            return this._needsRecompile
        }, dt.prototype.bind = function() {
            if (this._isValid && !this._cgl.aborted && (Z.lastShader = this, this._program && !this._needsRecompile || this.compile(), this._isValid)) {
                if (!this._projMatrixUniform && !this.ignoreMissingUniforms && (this._countMissingUniforms++, this._countMissingUniforms < 10)) {
                    this._projMatrixUniform = this._cgl.gl.getUniformLocation(this._program, J.SHADER.SHADERVAR_UNI_PROJMAT), this._attrVertexPos = this._cgl.glGetAttribLocation(this._program, J.SHADER.SHADERVAR_VERTEX_POSITION), this._mvMatrixUniform = this._cgl.gl.getUniformLocation(this._program, "mvMatrix"), this._vMatrixUniform = this._cgl.gl.getUniformLocation(this._program, J.SHADER.SHADERVAR_UNI_VIEWMAT), this._mMatrixUniform = this._cgl.gl.getUniformLocation(this._program, J.SHADER.SHADERVAR_UNI_MODELMAT), this._camPosUniform = this._cgl.gl.getUniformLocation(this._program, J.SHADER.SHADERVAR_UNI_VIEWPOS), this._normalMatrixUniform = this._cgl.gl.getUniformLocation(this._program, J.SHADER.SHADERVAR_UNI_NORMALMAT), this._inverseViewMatrixUniform = this._cgl.gl.getUniformLocation(this._program, J.SHADER.SHADERVAR_UNI_INVVIEWMAT), this._inverseProjMatrixUniform = this._cgl.gl.getUniformLocation(this._program, J.SHADER.SHADERVAR_UNI_INVPROJMAT), this._materialIdUniform = this._cgl.gl.getUniformLocation(this._program, J.SHADER.SHADERVAR_UNI_MATERIALID), this._objectIdUniform = this._cgl.gl.getUniformLocation(this._program, J.SHADER.SHADERVAR_UNI_OBJECTID);
                    for (let t = 0; t < this._uniforms.length; t++) this._uniforms[t].needsUpdate = !0
                }
                this._cgl.currentProgram != this._program && (this._cgl.profileData.profileShaderBinds++, this._cgl.gl.useProgram(this._program), this._cgl.currentProgram = this._program);
                for (let t = 0; t < this._uniforms.length; t++) this._uniforms[t].needsUpdate && this._uniforms[t].updateValue();
                if (this._pMatrixState != this._cgl.getProjectionMatrixStateCount() && (this._pMatrixState = this._cgl.getProjectionMatrixStateCount(), this._cgl.gl.uniformMatrix4fv(this._projMatrixUniform, !1, this._cgl.pMatrix), this._cgl.profileData.profileMVPMatrixCount++), this._objectIdUniform && this._cgl.gl.uniform1f(this._objectIdUniform, ++this._cgl.frameStore.objectIdCounter), this._materialIdUniform && this._cgl.gl.uniform1f(this._materialIdUniform, this._materialId), this._vMatrixUniform) this._vMatrixState != this._cgl.getViewMatrixStateCount() && (this._cgl.gl.uniformMatrix4fv(this._vMatrixUniform, !1, this._cgl.vMatrix), this._cgl.profileData.profileMVPMatrixCount++, this._vMatrixState = this._cgl.getViewMatrixStateCount(), this._inverseViewMatrixUniform && (mat4.invert(this._tempInverseViewMatrix, this._cgl.vMatrix), this._cgl.gl.uniformMatrix4fv(this._inverseViewMatrixUniform, !1, this._tempInverseViewMatrix), this._cgl.profileData.profileMVPMatrixCount++), this._inverseProjMatrixUniform && (mat4.invert(this._tempInverseProjMatrix, this._cgl.pMatrix), this._cgl.gl.uniformMatrix4fv(this._inverseProjMatrixUniform, !1, this._tempInverseProjMatrix), this._cgl.profileData.profileMVPMatrixCount++)), this._cgl.gl.uniformMatrix4fv(this._mMatrixUniform, !1, this._cgl.mMatrix), this._cgl.profileData.profileMVPMatrixCount++, this._camPosUniform && (mat4.invert(this._tempCamPosMatrix, this._cgl.vMatrix), this._cgl.gl.uniform3f(this._camPosUniform, this._tempCamPosMatrix[12], this._tempCamPosMatrix[13], this._tempCamPosMatrix[14]), this._cgl.profileData.profileMVPMatrixCount++);
                else {
                    const t = mat4.create();
                    mat4.mul(t, this._cgl.vMatrix, this._cgl.mMatrix), this._cgl.gl.uniformMatrix4fv(this._mvMatrixUniform, !1, t), this._cgl.profileData.profileMVPMatrixCount++
                }
                this._normalMatrixUniform && (mat4.invert(this._tempNormalMatrix, this._cgl.mMatrix), mat4.transpose(this._tempNormalMatrix, this._tempNormalMatrix), this._cgl.gl.uniformMatrix4fv(this._normalMatrixUniform, !1, this._tempNormalMatrix), this._cgl.profileData.profileMVPMatrixCount++);
                for (let t = 0; t < this._libs.length; t++) this._libs[t].onBind && this._libs[t].onBind.bind(this._libs[t])(this._cgl, this);
                return this._bindTextures(), this._isValid
            }
        }, dt.prototype.unBind = function() {}, dt.prototype.toggleDefine = function(t, e) {
            e && "object" == typeof e && e.addEventListener && (e.changeListener && e.removeEventListener(e.changeListener), e.onToggleDefine = e => {
                this.toggleDefine(t, e)
            }, e.changeListener = e.on("change", e.onToggleDefine), e = e.get()), e ? this.define(t) : this.removeDefine(t)
        }, dt.prototype.define = function(t, e) {
            null == e && (e = ""), "object" == typeof e && (e.removeEventListener("change", e.onDefineChange), e.onDefineChange = e => {
                this.define(t, e)
            }, e.on("change", e.onDefineChange), e = e.get());
            for (let i = 0; i < this._defines.length; i++) {
                if (this._defines[i][0] == t && this._defines[i][1] == e) return;
                if (this._defines[i][0] == t) return this._defines[i][1] = e, this.setWhyCompile("define " + t + " " + e), void(this._needsRecompile = !0)
            }
            this.setWhyCompile("define " + t + " " + e), this._needsRecompile = !0, this._defines.push([t, e])
        }, dt.prototype.getDefines = function() {
            return this._defines
        }, dt.prototype.getDefine = function(t) {
            for (let e = 0; e < this._defines.length; e++)
                if (this._defines[e][0] == t) return this._defines[e][1];
            return null
        }, dt.prototype.hasDefine = function(t) {
            for (let e = 0; e < this._defines.length; e++)
                if (this._defines[e][0] == t) return !0
        }, dt.prototype.removeDefine = function(t) {
            for (let e = 0; e < this._defines.length; e++)
                if (this._defines[e][0] == t) return this._defines.splice(e, 1), this._needsRecompile = !0, void this.setWhyCompile("define removed:" + t)
        }, dt.prototype.removeModule = function(t) {
            for (let e = 0; e < this._modules.length; e++)
                if (t && t.id && (this._modules[e].id == t.id || !this._modules[e])) {
                    let i = !0;
                    for (; i;) {
                        i = !1;
                        for (let e = 0; e < this._uniforms.length; e++) 0 != this._uniforms[e].getName().indexOf(t.prefix) || (this._uniforms.splice(e, 1), i = !0)
                    }
                    this._needsRecompile = !0, this.setWhyCompile("remove module " + t.title), this._modules.splice(e, 1);
                    break
                }
        }, dt.prototype.getNumModules = function() {
            return this._modules.length
        }, dt.prototype.getCurrentModules = function() {
            return this._modules
        }, dt.prototype.addModule = function(t, e) {
            if (!this.hasModule(t.id)) return t.id || (t.id = CABLES.simpleId()), t.numId || (t.numId = this._moduleNumId), t.num || (t.num = this._modules.length), e && !e.group && (e.group = A()), t.group || (t.group = e ? e.group : A()), t.prefix = "mod" + t.group + "_", this._modules.push(t), this._needsRecompile = !0, this.setWhyCompile("add module " + t.title), this._moduleNumId++, t
        }, dt.prototype.hasModule = function(t) {
            for (let e = 0; e < this._modules.length; e++)
                if (this._modules[e].id == t) return !0;
            return !1
        }, dt.prototype.setModules = function(t) {
            this._moduleNames = t
        }, dt.prototype.dispose = function() {
            this._cgl.gl.deleteProgram(this._program)
        }, dt.prototype.needsRecompile = function() {
            return this._needsRecompile
        }, dt.prototype.setDrawBuffers = function(t) {
            console.log("useless drawbuffers...?!")
        }, dt.prototype.getUniforms = function() {
            return this._uniforms
        }, dt.prototype.getUniform = function(t) {
            for (let e = 0; e < this._uniforms.length; e++)
                if (this._uniforms[e].getName() == t) return this._uniforms[e];
            return null
        }, dt.prototype.removeAllUniforms = function() {
            this._uniforms = []
        }, dt.prototype.removeUniform = function(t) {
            for (let e = 0; e < this._uniforms.length; e++) this._uniforms[e].getName() == t && this._uniforms.splice(e, 1);
            this._needsRecompile = !0, this.setWhyCompile("remove uniform " + t)
        }, dt.prototype._addUniform = function(t) {
            this._uniforms.push(t), this.setWhyCompile("add uniform " + name), this._needsRecompile = !0
        }, dt.prototype.addUniformFrag = function(t, e, i, s, r, n) {
            const o = new CGL.Uniform(this, t, e, i, s, r, n);
            return o.shaderType = "frag", o
        }, dt.prototype.addUniformVert = function(t, e, i, s, r, n) {
            const o = new CGL.Uniform(this, t, e, i, s, r, n);
            return o.shaderType = "vert", o
        }, dt.prototype.addUniformBoth = function(t, e, i, s, r, n) {
            const o = new CGL.Uniform(this, t, e, i, s, r, n);
            return o.shaderType = "both", o
        }, dt.prototype.addUniformStructFrag = function(t, e, i) {
            const s = {};
            if (!i) return s;
            for (let r = 0; r < i.length; r += 1) {
                const n = i[r];
                if (!this.hasUniform(e + "." + n.name)) {
                    const i = new CGL.Uniform(this, n.type, e + "." + n.name, n.v1, n.v2, n.v3, n.v4, e, t, n.name);
                    i.shaderType = "frag", s[e + "." + n.name] = i
                }
            }
            return s
        }, dt.prototype.addUniformStructVert = function(t, e, i) {
            const s = {};
            if (!i) return s;
            for (let r = 0; r < i.length; r += 1) {
                const n = i[r];
                if (!this.hasUniform(e + "." + n.name)) {
                    const i = new CGL.Uniform(this, n.type, e + "." + n.name, n.v1, n.v2, n.v3, n.v4, e, t, n.name);
                    i.shaderType = "vert", s[e + "." + n.name] = i
                }
            }
            return s
        }, dt.prototype.addUniformStructBoth = function(t, e, i) {
            const s = {};
            if (!i) return s;
            for (let r = 0; r < i.length; r += 1) {
                const n = i[r];
                if ("2i" !== n.type && "i" !== n.type && "3i" !== n.type || this._log.error("Adding an integer struct member to both shaders can potentially error. Please use different structs for each shader. Error occured in struct:", t, " with member:", n.name, " of type:", n.type, "."), !this.hasUniform(e + "." + n.name)) {
                    const i = new CGL.Uniform(this, n.type, e + "." + n.name, n.v1, n.v2, n.v3, n.v4, e, t, n.name);
                    i.shaderType = "both", s[e + "." + n.name] = i
                }
            }
            return s
        }, dt.prototype.hasUniform = function(t) {
            for (let e = 0; e < this._uniforms.length; e++)
                if (this._uniforms[e].getName() == t) return !0;
            return !1
        }, dt.prototype._createProgram = function(t, e) {
            this._cgl.printError("before _createprogram");
            const i = this._cgl.gl.createProgram();
            return this.vshader = dt.createShader(this._cgl, t, this._cgl.gl.VERTEX_SHADER, this), this.fshader = dt.createShader(this._cgl, e, this._cgl.gl.FRAGMENT_SHADER, this), this.vshader && this.fshader ? (this._cgl.gl.attachShader(i, this.vshader), this._cgl.gl.attachShader(i, this.fshader), this._linkProgram(i, t, e), this._cgl.printError("shader _createProgram"), i) : (this._isValid = !1, this._cgl.printError("shader _createProgram"), console.log("could not link shaderprogram"), null)
        }, dt.prototype.hasErrors = function() {
            return this._hasErrors
        }, dt.prototype._linkProgram = function(t, e, i) {
            this._cgl.printError("before _linkprogram"), this._feedBackNames.length > 0 && this._cgl.gl.transformFeedbackVaryings(t, this._feedBackNames, this._cgl.gl.SEPARATE_ATTRIBS), this._cgl.gl.linkProgram(t), this._cgl.printError("gl.linkprogram"), this._isValid = !0, this._hasErrors = !1, !1 !== this._cgl.patch.config.glValidateShader && (this._cgl.gl.validateProgram(t), this._cgl.gl.getProgramParameter(t, this._cgl.gl.VALIDATE_STATUS) || (console.log("shaderprogram validation failed..."), console.log(this._name + " programinfo: ", this._cgl.gl.getProgramInfoLog(t))), this._cgl.gl.getProgramParameter(t, this._cgl.gl.LINK_STATUS) || (this._hasErrors = !0, this._log.warn(this._cgl.gl.getShaderInfoLog(this.fshader) || "empty shader infolog"), this._log.warn(this._cgl.gl.getShaderInfoLog(this.vshader) || "empty shader infolog"), this._log.error(this._name + " shader linking fail..."), console.log(this._name + " programinfo: ", this._cgl.gl.getProgramInfoLog(t)), console.log("--------------------------------------"), console.log(this), console.log("--------------------------------------"), this._isValid = !1, this._name = "errorshader", this.setSource(dt.getDefaultVertexShader(), dt.getErrorFragmentShader()), this._cgl.printError("shader link err")))
        }, dt.prototype.getProgram = function() {
            return this._program
        }, dt.prototype.setFeedbackNames = function(t) {
            this.setWhyCompile("setFeedbackNames"), this._needsRecompile = !0, this._feedBackNames = t
        }, dt.prototype.getDefaultVertexShader = dt.getDefaultVertexShader = function() {
            return "{{MODULES_HEAD}}\nIN vec3 vPosition;\nIN vec2 attrTexCoord;\nIN vec3 attrVertNormal;\nIN vec3 attrTangent,attrBiTangent;\n\nIN float attrVertIndex;\n\nOUT vec2 texCoord;\nOUT vec3 norm;\nUNI mat4 projMatrix;\nUNI mat4 viewMatrix;\nUNI mat4 modelMatrix;\n\nvoid main()\n{\n    texCoord=attrTexCoord;\n    norm=attrVertNormal;\n    vec4 pos=vec4(vPosition,  1.0);\n    vec3 tangent=attrTangent;\n    vec3 bitangent=attrBiTangent;\n    mat4 mMatrix=modelMatrix;\n    {{MODULE_VERTEX_POSITION}}\n    gl_Position = projMatrix * (viewMatrix*mMatrix) * pos;\n}\n"
        }, dt.prototype.getDefaultFragmentShader = dt.getDefaultFragmentShader = function(t, e, i) {
            return null == t && (t = .5, e = .5, i = .5), "".endl() + "IN vec2 texCoord;".endl() + "{{MODULES_HEAD}}".endl() + "void main()".endl() + "{".endl() + "    vec4 col=vec4(" + t + "," + e + "," + i + ",1.0);".endl() + "    {{MODULE_COLOR}}".endl() + "    outColor = col;".endl() + "}"
        }, dt.prototype.addAttribute = function(t) {
            for (let e = 0; e < this._attributes.length; e++)
                if (this._attributes[e].name == t.name && this._attributes[e].nameFrag == t.nameFrag) return;
            this._attributes.push(t), this._needsRecompile = !0, this.setWhyCompile("addAttribute")
        }, dt.prototype.bindTextures = dt.prototype._bindTextures = function() {
            this._textureStackTex.length > this._cgl.maxTextureUnits && this._log.warn("[shader._bindTextures] too many textures bound", this._textureStackTex.length + "/" + this._cgl.maxTextureUnits);
            for (let t = 0; t < this._textureStackTex.length; t++)
                if (this._textureStackTex[t] || this._textureStackTexCgl[t]) {
                    let e = this._textureStackTex[t];
                    this._textureStackTexCgl[t] && (e = this._textureStackTexCgl[t].tex || CGL.Texture.getEmptyTexture(this._cgl).tex);
                    let i = !0;
                    this._textureStackUni[t] ? (this._textureStackUni[t].setValue(t), i = this._cgl.setTexture(t, e, this._textureStackType[t])) : (this._log.warn("no uniform for pushtexture", this._name), i = this._cgl.setTexture(t, e, this._textureStackType[t])), i || console.warn("tex bind failed", this.getName(), this._textureStackUni[t])
                } else this._log.warn("no texture for pushtexture", this._name)
        }, dt.prototype.setUniformTexture = function(t, e) {
            e = e || CGL.Texture.getTempTexture(this._cgl);
            for (let i = 0; i < this._textureStackUni.length; i++)
                if (this._textureStackUni[i] == t) {
                    const t = this._textureStackTex[i] || this._textureStackTexCgl[i];
                    return e.hasOwnProperty("tex") ? (this._textureStackTexCgl[i] = e, this._textureStackTex[i] = null) : (this._textureStackTexCgl[i] = null, this._textureStackTex[i] = e), t
                } return null
        }, dt.prototype.pushTexture = function(t, e, i) {
            if (!t) throw new Error("no uniform given to texturestack");
            if (e) {
                if (!(e.hasOwnProperty("tex") || e instanceof WebGLTexture)) return this._log.warn(new Error("invalid texture").stack), void this._log.warn("[cgl_shader] invalid texture...", e);
                this._textureStackUni.push(t), e.hasOwnProperty("tex") ? (this._textureStackTexCgl.push(e), this._textureStackTex.push(null)) : (this._textureStackTexCgl.push(null), this._textureStackTex.push(e)), this._textureStackType.push(i)
            }
        }, dt.prototype.popTexture = function() {
            this._textureStackUni.pop(), this._textureStackTex.pop(), this._textureStackTexCgl.pop(), this._textureStackType.pop()
        }, dt.prototype.popTextures = function() {
            this._textureStackTex.length = this._textureStackTexCgl.length = this._textureStackType.length = this._textureStackUni.length = 0
        }, dt.prototype.getMaterialId = function() {
            return this._materialId
        }, dt.prototype.getInfo = function() {
            const t = {};
            return t.name = this._name, t.defines = this.getDefines(), t.hasErrors = this.hasErrors(), t
        }, dt.getErrorFragmentShader = function() {
            return "".endl() + "void main()".endl() + "{".endl() + "   float g=mod((gl_FragCoord.y+gl_FragCoord.x),50.0)/50.0;".endl() + "   g= step(0.1,g);".endl() + "   outColor = vec4( g+0.5, 0.0, 0.0, 1.0);".endl() + "}"
        }, dt.createShader = function(t, e, i, s) {
            if (t.aborted) return;
            const r = t.gl.createShader(i);
            if (t.gl.shaderSource(r, e), t.gl.compileShader(r), !t.gl.getShaderParameter(r, t.gl.COMPILE_STATUS)) {
                let o = t.gl.getShaderInfoLog(r);
                if (!o) return void console.warn("empty shader info log", this._name);
                console.log("compile status: ");
                const a = function(t) {
                    const e = [],
                        i = t.split("\n");
                    for (const t in i) {
                        const s = i[t].split(":");
                        parseInt(s[2], 10) && e.push(parseInt(s[2], 10))
                    }
                    return e
                }(o);
                let h = '<pre style="margin-bottom:0px;"><code class="shaderErrorCode language-glsl" style="padding-bottom:0px;max-height: initial;max-width: initial;">';
                const l = e.match(/^.*((\r\n|\n|\r)|$)/gm);
                if (!t.aborted && o) {
                    i == t.gl.VERTEX_SHADER && console.log("VERTEX_SHADER"), i == t.gl.FRAGMENT_SHADER && console.log("FRAGMENT_SHADER");
                    for (const t in l) {
                        const e = parseInt(t, 10) + 1,
                            i = e + ": " + l[t];
                        console.log(i);
                        let s = !1;
                        for (const t in a) a[t] == e && (s = !0);
                        s && (h += "</code></pre>", h += '<pre style="margin:0"><code class="language-glsl" style="background-color:#660000;padding-top:0px;padding-bottom:0px">'), h += (n = i) && pt.test(n) ? n.replace(_t, (function(t) {
                            return ut[t]
                        })) : n || "", s && (h += "</code></pre>", h += '<pre style="margin:0"><code class="language-glsl" style=";padding-top:0px;padding-bottom:0px">')
                    }
                }
                console.warn(o), o = o.replace(/\n/g, "<br/>"), t.patch.isEditorMode() && console.log("Shader error ", this._name, o), h = o + "<br/>" + h + "<br/><br/>", h += "</code></pre>", t.patch.emitEvent("criticalError", {
                    title: "Shader error " + this._name,
                    text: h
                }), this._name = "errorshader", s.setSource(dt.getDefaultVertexShader(), dt.getErrorFragmentShader())
            }
            var n;
            return r
        };
        class ft {
            constructor(t) {
                this._cgl = t, this._lastTime = 0, this.pause = !1, this.profileUniformCount = 0, this.profileShaderBinds = 0, this.profileUniformCount = 0, this.profileShaderCompiles = 0, this.profileVideosPlaying = 0, this.profileMVPMatrixCount = 0, this.profileEffectBuffercreate = 0, this.profileShaderGetUniform = 0, this.profileFrameBuffercreate = 0, this.profileMeshSetGeom = 0, this.profileTextureNew = 0, this.profileGenMipMap = 0, this.profileOnAnimFrameOps = 0, this.profileFencedPixelRead = 0, this.profileMainloopMs = 0, this.profileMeshDraw = 0, this.profileTextureEffect = 0, this.profileTexPreviews = 0, this.shaderCompileTime = 0, this.profileMeshNumElements = 0, this.profileMeshAttributes = 0, this.profileSingleMeshAttribute = [], this.heavyEvents = [], this.doProfileGlQuery = !1, this.glQueryData = {}
            }
            clear() {
                this.profileSingleMeshAttribute = {}, this.profileMeshAttributes = 0, this.profileUniformCount = 0, this.profileShaderGetUniform = 0, this.profileShaderCompiles = 0, this.profileShaderBinds = 0, this.profileTextureResize = 0, this.profileFrameBuffercreate = 0, this.profileEffectBuffercreate = 0, this.profileTextureDelete = 0, this.profileMeshSetGeom = 0, this.profileVideosPlaying = 0, this.profileMVPMatrixCount = 0, this.profileNonTypedAttrib = 0, this.profileNonTypedAttribNames = "", this.profileTextureNew = 0, this.profileGenMipMap = 0, this.profileFramebuffer = 0, this.profileMeshDraw = 0, this.profileTextureEffect = 0, this.profileTexPreviews = 0, this.profileMeshNumElements = 0, this.profileFencedPixelRead = 0
            }
            clearGlQuery() {
                for (let t in this.glQueryData)(!this.glQueryData[t].lastClear || performance.now() - this.glQueryData[t].lastClear > 1e3) && (this.glQueryData[t].time = this.glQueryData[t]._times / this.glQueryData[t]._numcount, this.glQueryData[t].num = this.glQueryData[t]._numcount, this.glQueryData[t]._times = 0, this.glQueryData[t]._numcount = 0, this.glQueryData[t].lastClear = performance.now())
            }
            addHeavyEvent(t, e, i) {
                const s = {
                    event: t,
                    name: e,
                    info: i,
                    date: performance.now()
                };
                this.heavyEvents.push(s), this._cgl.emitEvent("heavyEvent", s)
            }
        }
        const mt = {
                GAPI_WEBGL: 0,
                GAPI_WEBGPU: 1,
                Geometry: H,
                BoundingBox: G,
                FpsCounter: class extends z {
                    constructor() {
                        super(), this._timeStartFrame = 0, this._timeStartSecond = 0, this._fpsCounter = 0, this._msCounter = 0, this._frameCount = 0, this.stats = {
                            ms: 0,
                            fps: 0
                        }
                    }
                    get frameCount() {
                        return this._frameCount
                    }
                    startFrame() {
                        this._timeStartFrame = CABLES.now()
                    }
                    endFrame() {
                        this._frameCount++, this._fpsCounter++;
                        const t = CABLES.now() - this._timeStartFrame;
                        this._msCounter += t, CABLES.now() - this._timeStartSecond > 1e3 && this.endSecond()
                    }
                    endSecond() {
                        this.stats.fps = this._fpsCounter, this.stats.ms = Math.round(this._msCounter / this._fpsCounter * 100) / 100, this.emitEvent("performance", this.stats), this._fpsCounter = 0, this._msCounter = 0, this._timeStartSecond = CABLES.now()
                    }
                }
            },
            Et = function(t) {
                It.apply(this), this.patch = t, this.gApi = mt.GAPI_WEBGPU, this._viewport = [0, 0, 256, 256], this._shaderStack = [], this.getViewPort = function() {
                    return [0, 0, this.canvasWidth, this.canvasHeight]
                }, this.renderStart = function(t, e, i) {
                    this.fpsCounter.startFrame(), this._startMatrixStacks(e, i), this.setViewPort(0, 0, this.canvasWidth, this.canvasHeight), this.emitEvent("beginFrame")
                }, this.renderEnd = function(t) {
                    this._endMatrixStacks(), this.emitEvent("endFrame"), this.fpsCounter.endFrame()
                }
            };
        Et.prototype.setViewPort = function(t, e, i, s) {
            this._viewport = [t, e, i, s]
        }, Et.prototype.getViewPort = function() {
            return this._viewPort
        }, Et.prototype.createMesh = function(t, e) {
            return new CGP.Mesh(this, t, e)
        }, Et.prototype.getShader = function() {
            return {}
        }, Et.prototype.pushShader = function(t) {
            this._shaderStack.push(t)
        }, Et.prototype.popShader = function() {
            if (0 === this._shaderStack.length) throw new Error("Invalid shader stack pop!");
            this._shaderStack.pop()
        }, Et.prototype.getShader = function() {
            return this._shaderStack[this._shaderStack.length - 1]
        }, Et.prototype.pushErrorScope = function() {
            this.device.pushErrorScope("validation")
        }, Et.prototype.popErrorScope = function(t, e) {
            this.device.popErrorScope().then((i => {
                i && (this.patch.emitEvent("criticalError", {
                    title: 'WebGPU error "' + t + '"',
                    codeText: i.message
                }), console.warn("[cgp]", t, i.message, i, e), e && e(i))
            }))
        };
        class Tt extends q {
            constructor(t, e, i, s, r, n, o, a, h, l) {
                super(t, e, i, s, r, n, o, a, h, l), this._loc = -1, this._cgl = t._cgl
            }
            updateValueF() {}
            setValueF(t) {
                this.needsUpdate = !0, this._value = t
            }
            updateValue2F() {}
            setValue2F(t) {
                this.needsUpdate = !0, this._value = t
            }
            updateValue3F() {}
            setValue3F(t) {
                this.needsUpdate = !0, this._value = t
            }
            updateValue4F() {}
            setValue4F(t) {
                this.needsUpdate = !0, this._value = t
            }
            getSizeBytes() {
                return "f" == this._type || "i" == this._type ? 4 : "2i" == this._type || "2f" == this._type ? 8 : "3f" == this._type ? 12 : "4f" == this._type ? 16 : "m4" == this._type ? 64 : void this._log.warn("unknown type getSizeBytes")
            }
        }
        class At {
            constructor(t, e) {
                this._shaderType = e, this._shader = t, this._cgp = t._cgp, this._gpuBuffer = null, this._values = null, this._sizeBytes = 0, this.update()
            }
            update() {
                this._sizeBytes = 0;
                for (let t = 0; t < this._shader.uniforms.length; t++) {
                    const e = this._shader.uniforms[t];
                    this._shaderType == e.shaderType && (this._sizeBytes += e.getSizeBytes())
                }
                this._gpuBuffer = this._cgp.device.createBuffer({
                    size: this._sizeBytes,
                    usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST
                }), this._values = new Float32Array(this._sizeBytes / 4), this.updateUniformValues()
            }
            updateUniformValues() {
                let t = 0;
                for (let e = 0; e < this._shader.uniforms.length; e++) {
                    const i = this._shader.uniforms[e];
                    if (i.shaderType == this._shaderType)
                        if (i.getSizeBytes() / 4 > 1)
                            for (let e = 0; e < i.getValue().length; e++) this._values[t] = i.getValue()[e], t++;
                        else this._values[t] = i.getValue(), t++
                }
                this._cgp.device.queue.writeBuffer(this._gpuBuffer, 0, this._values.buffer, this._values.byteOffset, this._values.byteLength)
            }
        }
        class bt {
            constructor(t, e) {
                if (!t) throw new Error("Pipeline constructed without cgp " + e);
                this._cgp = t, this._isValid = !0, this._pipeCfg = null, this._renderPipeline = null, this._fsUniformBuffer = null, this._vsUniformBuffer = null, this._old = {}
            }
            get isValid() {
                return this._isValid
            }
            setPipeline(t, e) {
                e && t ? ((!this._renderPipeline || !this._pipeCfg || this._old.mesh != e || this._old.shader != t || e.needsPipelineUpdate || t.needsPipelineUpdate) && (this._old.shader = t, this._old.mesh = e, this._pipeCfg = this.getPiplelineObject(t, e), console.log(this._pipeCfg), this._renderPipeline = this._cgp.device.createRenderPipeline(this._pipeCfg), this._bindUniforms(t)), this._renderPipeline && this._isValid && (mat4.copy(this._matModel, this._cgp.mMatrix), mat4.copy(this._matView, this._cgp.vMatrix), mat4.copy(this._matProj, this._cgp.pMatrix), this._cgp.device.queue.writeBuffer(this._vsUniformBuffer, 0, this._vsUniformValues.buffer, this._vsUniformValues.byteOffset, this._vsUniformValues.byteLength), this._uniBufFrag.updateUniformValues(), this._cgp.passEncoder.setPipeline(this._renderPipeline), this._cgp.passEncoder.setBindGroup(0, this._bindGroup))) : console.log("pipeline unknown shader/mesh")
            }
            getPiplelineObject(t, e) {
                return {
                    layout: "auto",
                    vertex: {
                        module: t.shaderModule,
                        entryPoint: "myVSMain",
                        buffers: [{
                            arrayStride: 12,
                            attributes: [{
                                shaderLocation: 0,
                                offset: 0,
                                format: "float32x3"
                            }]
                        }, {
                            arrayStride: 12,
                            attributes: [{
                                shaderLocation: 1,
                                offset: 0,
                                format: "float32x3"
                            }]
                        }, {
                            arrayStride: 8,
                            attributes: [{
                                shaderLocation: 2,
                                offset: 0,
                                format: "float32x2"
                            }]
                        }]
                    },
                    fragment: {
                        module: t.shaderModule,
                        entryPoint: "myFSMain",
                        targets: [{
                            format: this._cgp.presentationFormat
                        }]
                    },
                    primitive: {
                        topology: "triangle-list",
                        cullMode: "none"
                    },
                    depthStencil: {
                        depthWriteEnabled: !0,
                        depthCompare: "less",
                        format: "depth24plus"
                    }
                }
            }
            _bindUniforms(t) {
                this._cgp.pushErrorScope(), this._uniBufFrag = new At(t, "frag"), this._vsUniformBuffer = this._cgp.device.createBuffer({
                    size: 192,
                    usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST
                }), this._vsUniformValues = new Float32Array(48), this._matModel = this._vsUniformValues.subarray(0, 16), this._matView = this._vsUniformValues.subarray(16, 32), this._matProj = this._vsUniformValues.subarray(32, 48), this._bindGroup = this._cgp.device.createBindGroup({
                    layout: this._renderPipeline.getBindGroupLayout(0),
                    entries: [{
                        binding: 0,
                        resource: {
                            buffer: this._vsUniformBuffer
                        }
                    }, {
                        binding: 1,
                        resource: {
                            buffer: this._uniBufFrag._gpuBuffer
                        }
                    }]
                }), this._cgp.device.queue.writeBuffer(this._vsUniformBuffer, 0, this._vsUniformValues.buffer, this._vsUniformValues.byteOffset, this._vsUniformValues.byteLength), this._uniBufFrag.updateUniformValues(), this._cgp.popErrorScope("cgp_pipeline end", (t => {
                    this._isValid = !1
                }))
            }
        }
        class xt {
            constructor(t, e) {
                if (!t) throw new Error("no cgp");
                this._log = new r("cgp_texture"), this._cgp = t, this.id = CABLES.uuid(), e = e || {}, this.name = e.name || "unknown"
            }
            initTexture(t, e) {
                this.width = t.width, this.height = t.height, this.textureType = "rgba8unorm";
                const i = {
                        size: {
                            width: t.width,
                            height: t.height
                        },
                        format: this.textureType,
                        usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST
                    },
                    s = this._cgp.device.createTexture(i);
                return this._cgp.device.queue.copyExternalImageToTexture({
                    source: t
                }, {
                    texture: s
                }, i.size), s
            }
            getInfo() {
                const t = this,
                    e = {};
                return e.name = t.name, e.size = t.width + " x " + t.height, e.textureType = t.textureType, e
            }
        }
        xt.load = function(t, e, i, s) {
            fetch(e).then((s => {
                s.blob().then((s => {
                    createImageBitmap(s).then((s => {
                        const r = new xt(t, {
                            name: e
                        });
                        r.initTexture(s), i ? i(r) : console.log("Texture.load no onFinished callback")
                    }))
                }))
            }))
        };
        const vt = Object.assign({
            Context: Et,
            Shader: class {
                constructor(t, e) {
                    if (!t) throw new Error("shader constructed without cgp " + e);
                    this._log = new r("cgp_shader"), this._cgp = t, this._name = e, this._uniforms = [], e || this._log.stack("no shader name given"), this._name = e || "unknown", this.id = A(), this._isValid = !0, this._compileReason = "", this.shaderModule = null, this._needsRecompile = !0, this._src = ""
                }
                get isValid() {
                    return this._isValid
                }
                get uniforms() {
                    return this._uniforms
                }
                getName() {
                    return this._name
                }
                setWhyCompile(t) {
                    this._compileReason = t
                }
                setSource(t) {
                    this._src = t, this.setWhyCompile("Source changed"), this._needsRecompile = !0
                }
                compile() {
                    this._isValid = !0, console.log("compiling shader...", this._compileReason), this._cgp.pushErrorScope(), this.shaderModule = this._cgp.device.createShaderModule({
                        code: this._src
                    }), this._cgp.popErrorScope("cgp_shader " + this._name, this.error.bind(this)), this._needsRecompile = !1
                }
                error(t) {
                    this._isValid = !1
                }
                bind() {
                    for (let t = 0; t < this._uniforms.length; t++);
                    this._needsRecompile && this.compile()
                }
                addUniformFrag(t, e, i, s, r, n) {
                    const o = new Tt(this, t, e, i, s, r, n);
                    return o.shaderType = "frag", o
                }
                addUniformVert(t, e, i, s, r, n) {
                    const o = new Tt(this, t, e, i, s, r, n);
                    return o.shaderType = "vert", o
                }
                addUniform(t, e, i, s, r, n) {
                    const o = new Tt(this, t, e, i, s, r, n);
                    return o.shaderType = "both", o
                }
                _addUniform(t) {
                    this._uniforms.push(t), this.setWhyCompile("add uniform " + name), this._needsRecompile = !0
                }
            },
            Mesh: class {
                constructor(t, e) {
                    this._log = new r("cgl_mesh"), this._cgp = t, this._geom = null, this.numIndex = 0, this._pipe = new bt(this._cgp), this._numNonIndexed = 0, this._positionBuffer = null, this._bufVerticesIndizes = null, this._attributes = [], this._needsPipelineUpdate = !1, e && this.setGeom(e)
                }
                _createBuffer(t, e, i) {
                    const s = t.createBuffer({
                        size: e.byteLength,
                        usage: i,
                        mappedAtCreation: !0
                    });
                    return new e.constructor(s.getMappedRange()).set(e), s.unmap(), s
                }
                setGeom(t, e) {
                    this._needsPipelineUpdate = !0, this._geom = t, this._disposeAttributes(), this._positionBuffer = this._createBuffer(this._cgp.device, new Float32Array(t.vertices), GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST);
                    let i = t.verticesIndices;
                    t.isIndexed() || (i = Array.from(Array(t.vertices.length / 3).keys())), this._numIndices = i.length, this._indicesBuffer = this._createBuffer(this._cgp.device, new Uint32Array(i), GPUBufferUsage.INDEX | GPUBufferUsage.COPY_DST), t.texCoords && t.texCoords.length && this.setAttribute("texCoords", t.texCoords, 2), t.vertexNormals && t.vertexNormals.length && this.setAttribute("normals", t.vertexNormals, 3)
                }
                _disposeAttributes() {
                    this._needsPipelineUpdate = !0;
                    for (let t = 0; t < this._attributes.length; t++) this._attributes[t].buffer.destroy();
                    this._attributes.length = 0
                }
                dispose() {
                    this._disposeAttributes()
                }
                setAttribute(t, e, i, s) {
                    if (!e) throw this._log.error("mesh addAttribute - no array given! " + t), new Error;
                    for (let e = 0; e < this._attributes.length; e++) {
                        const i = this._attributes[e];
                        if (i.name == t) return i
                    }
                    const r = {
                        buffer: this._createBuffer(this._cgp.device, new Float32Array(e), GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST),
                        name: t
                    };
                    return this._attributes.push(r), r
                }
                render() {
                    if (!this._positionBuffer) return;
                    const t = this._cgp.getShader();
                    if (t && t.bind(), this._cgp.getShader().isValid && (this._pipe.setPipeline(this._cgp.getShader(), this), this._pipe.isValid)) {
                        this._cgp.passEncoder.setVertexBuffer(0, this._positionBuffer);
                        for (let t = 0; t < this._attributes.length; t++) this._cgp.passEncoder.setVertexBuffer(t + 1, this._attributes[t].buffer);
                        this._cgp.passEncoder.setIndexBuffer(this._indicesBuffer, "uint32"), this._numNonIndexed ? this._cgp.passEncoder.draw(this._numIndices) : this._cgp.passEncoder.drawIndexed(this._numIndices)
                    }
                }
            },
            Pipeline: bt,
            Texture: xt
        });
        window.CGP = vt;
        const yt = function() {
            this._arr = [mat4.create()], this._index = 0, this.stateCounter = 0
        };
        yt.prototype.push = function(t) {
            if (this._index++, this.stateCounter++, this._index == this._arr.length) {
                const t = mat4.create();
                this._arr.push(t)
            }
            return mat4.copy(this._arr[this._index], t || this._arr[this._index - 1]), this._arr[this._index]
        }, yt.prototype.pop = function() {
            return this.stateCounter++, this._index--, this._index < 0 && (this._index = 0), this._arr[this._index]
        }, yt.prototype.length = function() {
            return this._index
        }, __webpack_require__(122);
        const It = function() {
                z.apply(this), this.canvas = null, this.fpsCounter = new CABLES.CG.FpsCounter, this._identView = vec3.create(), this._ident = vec3.create(), vec3.set(this._identView, 0, 0, -2), vec3.set(this._ident, 0, 0, 0), this.pMatrix = mat4.create(), this.mMatrix = mat4.create(), this.vMatrix = mat4.create(), this._textureslots = [], this._pMatrixStack = new yt, this._mMatrixStack = new yt, this._vMatrixStack = new yt, this.canvasWidth = -1, this.canvasHeight = -1, this.canvasScale = 1, this.canvas = null, this.pixelDensity = 1, mat4.identity(this.mMatrix), mat4.identity(this.vMatrix), this.getGApiName = () => ["WebGL", "WebGPU"][this.gApi], this.setCanvas = function(t) {
                    this.canvas = "string" == typeof t ? document.getElementById(t) : t, this._setCanvas && this._setCanvas(t), this.updateSize()
                }, this.updateSize = function() {
                    this.canvas.width = this.canvasWidth = this.canvas.clientWidth * this.pixelDensity, this.canvas.height = this.canvasHeight = this.canvas.clientHeight * this.pixelDensity
                }, this.setSize = function(t, e, i) {
                    i || (this.canvas.style.width = t + "px", this.canvas.style.height = e + "px"), this.canvas.width = t * this.pixelDensity, this.canvas.height = e * this.pixelDensity, this.updateSize()
                }, this._resizeToWindowSize = function() {
                    this.setSize(window.innerWidth, window.innerHeight), this.updateSize()
                }, this._resizeToParentSize = function() {
                    const t = this.canvas.parentElement;
                    t ? (this.setSize(t.clientWidth, t.clientHeight), this.updateSize()) : this._log.error("cables: can not resize to container element")
                }, this.setAutoResize = function(t) {
                    window.removeEventListener("resize", this._resizeToWindowSize.bind(this)), window.removeEventListener("resize", this._resizeToParentSize.bind(this)), "window" == t && (window.addEventListener("resize", this._resizeToWindowSize.bind(this)), window.addEventListener("orientationchange", this._resizeToWindowSize.bind(this)), this._resizeToWindowSize()), "parent" == t && (window.addEventListener("resize", this._resizeToParentSize.bind(this)), this._resizeToParentSize())
                }, this.pushPMatrix = function() {
                    this.pMatrix = this._pMatrixStack.push(this.pMatrix)
                }, this.popPMatrix = function() {
                    return this.pMatrix = this._pMatrixStack.pop(), this.pMatrix
                }, this.getProjectionMatrixStateCount = function() {
                    return this._pMatrixStack.stateCounter
                }, this.pushModelMatrix = function() {
                    this.mMatrix = this._mMatrixStack.push(this.mMatrix)
                }, this.popModelMatrix = function() {
                    return this.mMatrix = this._mMatrixStack.pop(), this.mMatrix
                }, this.modelMatrix = function() {
                    return this.mMatrix
                }, this.pushViewMatrix = function() {
                    this.vMatrix = this._vMatrixStack.push(this.vMatrix)
                }, this.popViewMatrix = function() {
                    this.vMatrix = this._vMatrixStack.pop()
                }, this.getViewMatrixStateCount = function() {
                    return this._vMatrixStack.stateCounter
                }, this._startMatrixStacks = (t, e) => {
                    t = t || this._ident, e = e || this._identView, mat4.perspective(this.pMatrix, 45, this.canvasWidth / this.canvasHeight, .1, 1e3), mat4.identity(this.mMatrix), mat4.identity(this.vMatrix), mat4.translate(this.mMatrix, this.mMatrix, t), mat4.translate(this.vMatrix, this.vMatrix, e), this.pushPMatrix(), this.pushModelMatrix(), this.pushViewMatrix()
                }, this._endMatrixStacks = () => {
                    this.popViewMatrix(), this.popModelMatrix(), this.popPMatrix()
                }
            },
            St = function(t) {
                It.apply(this), this.gApi = mt.GAPI_WEBGL, this.pushMvMatrix = this.pushModelMatrix, this.popMvMatrix = this.popmMatrix = this.popModelMatrix, this.profileData = new ft(this), this._log = new r("cgl_context"), this._viewPort = [0, 0, 0, 0], this.glVersion = 0, this.glUseHalfFloatTex = !1, this.clearCanvasTransparent = !0, this.clearCanvasDepth = !0, this.patch = t, this.debugOneFrame = !1, this.checkGlErrors = !1, this.maxTextureUnits = 0, this.maxVaryingVectors = 0, this.currentProgram = null, this._hadStackError = !1, this.glSlowRenderer = !1, this._isSafariCrap = !1, this.temporaryTexture = null, this.frameStore = {}, this._onetimeCallbacks = [], this.gl = null, this._cursor = "auto", this._currentCursor = "", this._viewPortStack = [], this._glFrameBufferStack = [], this._frameBufferStack = [], this._shaderStack = [], this._stackDepthTest = [], Object.defineProperty(this, "viewPort", {
                    get() {
                        if (this._viewPortStack.length > 3) {
                            const t = this._viewPortStack.length;
                            return [this._viewPortStack[t - 4], this._viewPortStack[t - 3], this._viewPortStack[t - 2], this._viewPortStack[t - 1]]
                        }
                        return this._viewPort
                    }
                }), Object.defineProperty(this, "mvMatrix", {
                    get() {
                        return this.mMatrix
                    },
                    set(t) {
                        this.mMatrix = t
                    }
                });
                const e = new dt(this, "simpleshader");
                e.setModules(["MODULE_VERTEX_POSITION", "MODULE_COLOR", "MODULE_BEGIN_FRAG"]), e.setSource(dt.getDefaultVertexShader(), dt.getDefaultFragmentShader());
                let i = e;
                this.aborted = !1;
                const s = [];
                this.exitError = function(t, e) {
                    console.log(t, e), this.patch.exitError(t, e), this.aborted = !0
                }, this._setCanvas = function(t) {
                    if (this.patch.config.canvas || (this.patch.config.canvas = {}), this.patch.config.canvas.hasOwnProperty("preserveDrawingBuffer") || (this.patch.config.canvas.preserveDrawingBuffer = !1), this.patch.config.canvas.hasOwnProperty("premultipliedAlpha") || (this.patch.config.canvas.premultipliedAlpha = !1), this.patch.config.canvas.hasOwnProperty("alpha") || (this.patch.config.canvas.alpha = !1), this.patch.config.canvas.stencil = !0, this.patch.config.hasOwnProperty("clearCanvasColor") && (this.clearCanvasTransparent = this.patch.config.clearCanvasColor), this.patch.config.hasOwnProperty("clearCanvasDepth") && (this.clearCanvasDepth = this.patch.config.clearCanvasDepth), /^((?!chrome|android).)*safari/i.test(navigator.userAgent) && navigator.userAgent.match(/iPhone/i) && (this._isSafariCrap = !0, this.glUseHalfFloatTex = !0), this.patch.config.canvas.forceWebGl1 || (this.gl = this.canvas.getContext("webgl2", this.patch.config.canvas)), this.gl && "WebGL 1.0" != this.gl.getParameter(this.gl.VERSION)) this.glVersion = 2;
                    else {
                        this.gl = this.canvas.getContext("webgl", this.patch.config.canvas) || this.canvas.getContext("experimental-webgl", this.patch.config.canvas), this.glVersion = 1, /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream && (this.patch.config.canvas.hasOwnProperty("powerPreference") || (this.patch.config.canvas.powerPreference = "high-performance")), this.enableExtension("OES_standard_derivatives");
                        const t = this.enableExtension("ANGLE_instanced_arrays") || this.gl;
                        t.vertexAttribDivisorANGLE && (this.gl.vertexAttribDivisor = t.vertexAttribDivisorANGLE.bind(t), this.gl.drawElementsInstanced = t.drawElementsInstancedANGLE.bind(t))
                    }
                    if (!this.gl) return this.aborted = !0, void this.exitError("NO_WEBGL", "sorry, could not initialize WebGL. Please check if your Browser supports WebGL or try to restart your browser.");
                    const e = this.enableExtension("WEBGL_debug_renderer_info");
                    if (e && (this.glRenderer = this.gl.getParameter(e.UNMASKED_RENDERER_WEBGL), "Google SwiftShader" === this.glRenderer && (this.glSlowRenderer = !0)), this.canvas.addEventListener("webglcontextlost", (t => {
                            this._log.error("canvas lost...", t), this.emitEvent("webglcontextlost"), this.aborted = !0
                        })), this.maxVaryingVectors = this.gl.getParameter(this.gl.MAX_VARYING_VECTORS), this.maxTextureUnits = this.gl.getParameter(this.gl.MAX_TEXTURE_IMAGE_UNITS), this.maxTexSize = this.gl.getParameter(this.gl.MAX_TEXTURE_SIZE), this.maxUniformsFrag = this.gl.getParameter(this.gl.MAX_FRAGMENT_UNIFORM_VECTORS), this.maxUniformsVert = this.gl.getParameter(this.gl.MAX_VERTEX_UNIFORM_VECTORS), this.maxSamples = 0, this.gl.MAX_SAMPLES && (this.maxSamples = this.gl.getParameter(this.gl.MAX_SAMPLES)), 1 == this.glVersion) {
                        this.enableExtension("OES_standard_derivatives");
                        const t = this.enableExtension("ANGLE_instanced_arrays") || this.gl;
                        t.vertexAttribDivisorANGLE && (this.gl.vertexAttribDivisor = t.vertexAttribDivisorANGLE.bind(t), this.gl.drawElementsInstanced = t.drawElementsInstancedANGLE.bind(t))
                    }
                }, this.getInfo = function() {
                    return {
                        glVersion: this.glVersion,
                        glRenderer: this.glRenderer,
                        glUseHalfFloatTex: this.glUseHalfFloatTex,
                        maxVaryingVectors: this.maxVaryingVectors,
                        maxTextureUnits: this.maxTextureUnits,
                        maxTexSize: this.maxTexSize,
                        maxUniformsFrag: this.maxUniformsFrag,
                        maxUniformsVert: this.maxUniformsVert,
                        maxSamples: this.maxSamples
                    }
                };
                let n = -1,
                    o = -1;
                this.popViewPort = function() {
                    this._viewPortStack.pop(), this._viewPortStack.pop(), this._viewPortStack.pop(), this._viewPortStack.pop(), 0 == this._viewPortStack.length ? this.setViewPort(0, 0, this.canvasWidth, this.canvasHeight) : this.setViewPort(this._viewPortStack[this._viewPort.length - 4], this._viewPortStack[this._viewPort.length - 3], this._viewPortStack[this._viewPort.length - 2], this._viewPortStack[this._viewPort.length - 1])
                }, this.pushViewPort = function(t, e, i, s) {
                    this._viewPortStack.push(t, e, i, s), this.setViewPort(t, e, i, s)
                }, this.getViewPort = function() {
                    return this._viewPort
                }, this.resetViewPort = function() {
                    this.gl.viewport(this._viewPort[0], this._viewPort[1], this._viewPort[2], this._viewPort[3])
                }, this.setViewPort = function(t, e, i, s) {
                    this._viewPort[0] = Math.round(t), this._viewPort[1] = Math.round(e), this._viewPort[2] = Math.round(i), this._viewPort[3] = Math.round(s), this.gl.viewport(this._viewPort[0], this._viewPort[1], this._viewPort[2], this._viewPort[3])
                }, this.screenShot = function(t, e, i, s) {
                    e && (this.gl.clearColor(1, 1, 1, 1), this.gl.colorMask(!1, !1, !1, !0), this.gl.clear(this.gl.COLOR_BUFFER_BIT), this.gl.colorMask(!0, !0, !0, !0)), this.canvas && this.canvas.toBlob && this.canvas.toBlob((e => {
                        t ? t(e) : this._log.log("no screenshot callback...")
                    }), i, s)
                }, this.endFrame = function() {
                    if (this.patch.isEditorMode() && CABLES.GL_MARKER.drawMarkerLayer(this), this.setPreviousShader(), this._vMatrixStack.length() > 0 && this.logStackError("view matrix stack length !=0 at end of rendering..."), this._mMatrixStack.length() > 0 && this.logStackError("mvmatrix stack length !=0 at end of rendering..."), this._pMatrixStack.length() > 0 && this.logStackError("pmatrix stack length !=0 at end of rendering..."), this._glFrameBufferStack.length > 0 && this.logStackError("glFrameBuffer stack length !=0 at end of rendering..."), this._stackDepthTest.length > 0 && this.logStackError("depthtest stack length !=0 at end of rendering..."), this._stackDepthWrite.length > 0 && this.logStackError("depthwrite stack length !=0 at end of rendering..."), this._stackDepthFunc.length > 0 && this.logStackError("depthfunc stack length !=0 at end of rendering..."), this._stackBlend.length > 0 && this.logStackError("blend stack length !=0 at end of rendering..."), this._stackBlendMode.length > 0 && this.logStackError("blendMode stack length !=0 at end of rendering..."), this._shaderStack.length > 0 && this.logStackError("this._shaderStack length !=0 at end of rendering..."), this._stackCullFace.length > 0 && this.logStackError("this._stackCullFace length !=0 at end of rendering..."), this._stackCullFaceFacing.length > 0 && this.logStackError("this._stackCullFaceFacing length !=0 at end of rendering..."), this._viewPortStack.length > 0 && this.logStackError("viewport stack length !=0 at end of rendering..."), this._frameStarted = !1, n != this.canvasWidth || o != this.canvasHeight) {
                        n = this.canvasWidth, o = this.canvasHeight, this.setSize(this.canvasWidth / this.pixelDensity, this.canvasHeight / this.pixelDensity), this.updateSize();
                        for (let t = 0; t < s.length; t++) s[t]();
                        this.emitEvent("resize")
                    }
                    this._cursor != this._currentCursor && (this._currentCursor = this.canvas.style.cursor = this._cursor), this.emitEvent("endframe"), this.fpsCounter.endFrame()
                }, this.logStackError = function(t) {
                    this._hadStackError || (this._hadStackError = !0, this._log.warn("[" + this.canvas.id + "]: ", t))
                }, this.getShader = function() {
                    if (i && (!this.frameStore || !0 === this.frameStore.renderOffscreen == i.offScreenPass == 1)) return i;
                    for (let t = this._shaderStack.length - 1; t >= 0; t--)
                        if (this._shaderStack[t] && this.frameStore.renderOffscreen == this._shaderStack[t].offScreenPass) return this._shaderStack[t]
                }, this.getDefaultShader = function() {
                    return e
                }, this.pushShader = this.setShader = function(t) {
                    if (this.frameStore.forceShaderMods)
                        for (let e = 0; e < this.frameStore.forceShaderMods.length; e++) t = this.frameStore.forceShaderMods[e].bind(t, !1);
                    this._shaderStack.push(t), i = t
                }, this.popShader = this.setPreviousShader = function() {
                    if (this.frameStore.forceShaderMods)
                        for (let t = 0; t < this.frameStore.forceShaderMods.length; t++) this.frameStore.forceShaderMods[t].unbind(!1);
                    if (0 === this._shaderStack.length) throw new Error("Invalid shader stack pop!");
                    this._shaderStack.pop(), i = this._shaderStack[this._shaderStack.length - 1]
                }, this.pushGlFrameBuffer = function(t) {
                    this._glFrameBufferStack.push(t)
                }, this.popGlFrameBuffer = function() {
                    return 0 == this._glFrameBufferStack.length ? null : (this._glFrameBufferStack.pop(), this._glFrameBufferStack[this._glFrameBufferStack.length - 1])
                }, this.getCurrentGlFrameBuffer = function() {
                    return 0 === this._glFrameBufferStack.length ? null : this._glFrameBufferStack[this._glFrameBufferStack.length - 1]
                }, this.pushFrameBuffer = function(t) {
                    this._frameBufferStack.push(t)
                }, this.popFrameBuffer = function() {
                    return 0 == this._frameBufferStack.length ? null : (this._frameBufferStack.pop(), this._frameBufferStack[this._frameBufferStack.length - 1])
                }, this.getCurrentFrameBuffer = function() {
                    return 0 === this._frameBufferStack.length ? null : this._frameBufferStack[this._frameBufferStack.length - 1]
                }, this.renderStart = function(t, i, s) {
                    this.fpsCounter.startFrame(), this.pushDepthTest(!0), this.pushDepthWrite(!0), this.pushDepthFunc(t.gl.LEQUAL), this.pushCullFaceFacing(t.gl.BACK), this.pushCullFace(!1), this.clearCanvasTransparent && (t.gl.clearColor(0, 0, 0, 0), t.gl.clear(t.gl.COLOR_BUFFER_BIT)), this.clearCanvasDepth && t.gl.clear(t.gl.DEPTH_BUFFER_BIT), t.setViewPort(0, 0, t.canvasWidth, t.canvasHeight), this._startMatrixStacks(i, s), t.pushBlendMode(J.BLEND_MODES.BLEND_NORMAL, !1);
                    for (let t = 0; t < this._textureslots.length; t++) this._textureslots[t] = null;
                    if (this.pushShader(e), this._frameStarted = !0, this._onetimeCallbacks.length > 0) {
                        for (let t = 0; t < this._onetimeCallbacks.length; t++) this._onetimeCallbacks[t]();
                        this._onetimeCallbacks.length = 0
                    }
                    this.emitEvent("beginFrame")
                }, this.renderEnd = function(t) {
                    this._endMatrixStacks(), this.popDepthTest(), this.popDepthWrite(), this.popDepthFunc(), this.popCullFaceFacing(), this.popCullFace(), this.popBlend(), this.popBlendMode(), t.endFrame(), this.emitEvent("endFrame")
                }, this.getTexture = function(t) {
                    return this._textureslots[t]
                }, this.hasFrameStarted = function() {
                    return this._frameStarted
                }, this.checkFrameStarted = function(t) {
                    this._frameStarted || (this._log.warn("frame not started " + t), this.patch.printTriggerStack())
                }, this.setTexture = function(t, e, i) {
                    return this.checkFrameStarted("cgl setTexture"), null === e && (e = CGL.Texture.getEmptyTexture(this).tex), this._textureslots[t] != e && (this.gl.activeTexture(this.gl.TEXTURE0 + t), this.gl.bindTexture(i || this.gl.TEXTURE_2D, e), this._textureslots[t] = e), !0
                }, this.fullScreen = function() {
                    this.canvas.requestFullscreen ? this.canvas.requestFullscreen() : this.canvas.mozRequestFullScreen ? this.canvas.mozRequestFullScreen() : this.canvas.webkitRequestFullscreen ? this.canvas.webkitRequestFullscreen() : this.canvas.msRequestFullscreen && this.canvas.msRequestFullscreen()
                }, this.printError = function(t) {
                    if (!this.checkGlErrors) return;
                    let e = !1,
                        i = this.gl.getError();
                    if (i != this.gl.NO_ERROR) {
                        let s = "";
                        i == this.gl.OUT_OF_MEMORY && (s = "OUT_OF_MEMORY"), i == this.gl.INVALID_ENUM && (s = "INVALID_ENUM"), i == this.gl.INVALID_OPERATION && (s = "INVALID_OPERATION"), i == this.gl.INVALID_FRAMEBUFFER_OPERATION && (s = "INVALID_FRAMEBUFFER_OPERATION"), i == this.gl.INVALID_VALUE && (s = "INVALID_VALUE"), i == this.gl.CONTEXT_LOST_WEBGL && (this.aborted = !0, s = "CONTEXT_LOST_WEBGL"), i == this.gl.NO_ERROR && (s = "NO_ERROR"), e = !0, this._log.warn("gl error [" + this.canvas.id + "]: ", t, i, s), -1 == this.canvas.id.indexOf("glGuiCanvas") && (this._loggedGlError || (this.patch.printTriggerStack(), this._log.stack("glerror"), this._loggedGlError = !0))
                    }
                    return i = this.gl.getError(), e
                }, this.saveScreenshot = function(t, e, i, s, r) {
                    this.patch.renderOneFrame();
                    let n = this.canvas.clientWidth * this.pixelDensity,
                        o = this.canvas.clientHeight * this.pixelDensity;

                    function a(t, e, i) {
                        return Array(e - String(t).length + 1).join(i || "0") + t
                    }
                    i && (this.canvas.width = i, n = i), s && (this.canvas.height = s, o = s);
                    const h = new Date,
                        l = "".concat(String(h.getFullYear()) + String(h.getMonth() + 1) + String(h.getDate()), "_").concat(a(h.getHours(), 2)).concat(a(h.getMinutes(), 2)).concat(a(h.getSeconds(), 2));
                    t ? t += ".png" : t = "cables_" + l + ".png", this.patch.cgl.screenShot(function(i) {
                        if (this.canvas.width = n, this.canvas.height = o, i) {
                            const s = document.createElement("a");
                            s.download = t, s.href = URL.createObjectURL(i), setTimeout((function() {
                                s.click(), e && e(i)
                            }), 100)
                        } else this._log.log("screenshot: no blob")
                    }.bind(this), r)
                }
            };
        St.prototype.addNextFrameOnceCallback = function(t) {
            t && this._onetimeCallbacks.push(t)
        }, St.prototype._stackDepthTest = [], St.prototype.pushDepthTest = function(t) {
            this._stackDepthTest.push(t), t ? this.gl.enable(this.gl.DEPTH_TEST) : this.gl.disable(this.gl.DEPTH_TEST)
        }, St.prototype.stateDepthTest = function() {
            return this._stackDepthTest[this._stackDepthTest.length - 1]
        }, St.prototype.popDepthTest = function() {
            this._stackDepthTest.pop(), this._stackDepthTest[this._stackDepthTest.length - 1] ? this.gl.enable(this.gl.DEPTH_TEST) : this.gl.disable(this.gl.DEPTH_TEST)
        }, St.prototype._stackDepthWrite = [], St.prototype.pushDepthWrite = function(t) {
            t = t || !1, this._stackDepthWrite.push(t), this.gl.depthMask(t)
        }, St.prototype.stateDepthWrite = function() {
            return this._stackDepthWrite[this._stackDepthWrite.length - 1]
        }, St.prototype.popDepthWrite = function() {
            this._stackDepthWrite.pop(), this.gl.depthMask(this._stackDepthWrite[this._stackDepthWrite.length - 1] || !1)
        }, St.prototype._stackCullFace = [], St.prototype.pushCullFace = function(t) {
            this._stackCullFace.push(t), t ? this.gl.enable(this.gl.CULL_FACE) : this.gl.disable(this.gl.CULL_FACE)
        }, St.prototype.stateCullFace = function() {
            return this._stackCullFace[this._stackCullFace.length - 1]
        }, St.prototype.popCullFace = function() {
            this._stackCullFace.pop(), this._stackCullFace[this._stackCullFace.length - 1] ? this.gl.enable(this.gl.CULL_FACE) : this.gl.disable(this.gl.CULL_FACE)
        }, St.prototype._stackCullFaceFacing = [], St.prototype.pushCullFaceFacing = function(t) {
            this._stackCullFaceFacing.push(t), this.gl.cullFace(this._stackCullFaceFacing[this._stackCullFaceFacing.length - 1])
        }, St.prototype.stateCullFaceFacing = function() {
            return this._stackCullFaceFacing[this._stackCullFaceFacing.length - 1]
        }, St.prototype.popCullFaceFacing = function() {
            this._stackCullFaceFacing.pop(), this._stackCullFaceFacing.length > 0 && this.gl.cullFace(this._stackCullFaceFacing[this._stackCullFaceFacing.length - 1])
        }, St.prototype._stackDepthFunc = [], St.prototype.pushDepthFunc = function(t) {
            this._stackDepthFunc.push(t), this.gl.depthFunc(t)
        }, St.prototype.stateDepthFunc = function() {
            return this._stackDepthFunc.length > 0 && this._stackDepthFunc[this._stackDepthFunc.length - 1]
        }, St.prototype.popDepthFunc = function() {
            this._stackDepthFunc.pop(), this._stackDepthFunc.length > 0 && this.gl.depthFunc(this._stackDepthFunc[this._stackDepthFunc.length - 1])
        }, St.prototype._stackBlend = [], St.prototype.pushBlend = function(t) {
            this._stackBlend.push(t), t ? this.gl.enable(this.gl.BLEND) : this.gl.disable(this.gl.BLEND)
        }, St.prototype.popBlend = function() {
            this._stackBlend.pop(), this._stackBlend[this._stackBlend.length - 1] ? this.gl.enable(this.gl.BLEND) : this.gl.disable(this.gl.BLEND)
        }, St.prototype.stateBlend = function() {
            return this._stackBlend[this._stackBlend.length - 1]
        }, St.prototype._stackBlendMode = [], St.prototype._stackBlendModePremul = [], St.prototype.pushBlendMode = function(t, e) {
            this._stackBlendMode.push(t), this._stackBlendModePremul.push(e);
            const i = this._stackBlendMode.length - 1;
            this.pushBlend(this._stackBlendMode[i] !== J.BLEND_MODES.BLEND_NONE), this._setBlendMode(this._stackBlendMode[i], this._stackBlendModePremul[i])
        }, St.prototype.popBlendMode = function() {
            this._stackBlendMode.pop(), this._stackBlendModePremul.pop();
            const t = this._stackBlendMode.length - 1;
            this.popBlend(this._stackBlendMode[t] !== J.BLEND_MODES.BLEND_NONE), t >= 0 && this._setBlendMode(this._stackBlendMode[t], this._stackBlendModePremul[t])
        }, St.prototype._stackStencil = [], St.prototype.pushStencil = function(t) {
            this._stackStencil.push(t), t ? this.gl.enable(this.gl.STENCIL_TEST) : this.gl.disable(this.gl.STENCIL_TEST)
        }, St.prototype.popStencil = function() {
            this._stackStencil.pop(), this._stackStencil[this._stackStencil.length - 1] ? this.gl.enable(this.gl.STENCIL_TEST) : this.gl.disable(this.gl.STENCIL_TEST)
        }, St.prototype.glGetAttribLocation = function(t, e) {
            return this.gl.getAttribLocation(t, e)
        }, St.prototype.shouldDrawHelpers = function(t) {
            if (this.frameStore.shadowPass) return !1;
            if (!t.patch.isEditorMode()) return !1;
            const e = this.getCurrentFrameBuffer();
            return (!e || !e.getWidth || this.canvasWidth / this.canvasHeight == e.getWidth() / e.getHeight()) && (CABLES.UI.renderHelper || CABLES.UI.renderHelperCurrent && t.isCurrentUiOp())
        }, St.prototype._setBlendMode = function(t, e) {
            const i = this.gl;
            t == J.BLEND_MODES.BLEND_NONE || (t == J.BLEND_MODES.BLEND_ADD ? e ? (i.blendEquationSeparate(i.FUNC_ADD, i.FUNC_ADD), i.blendFuncSeparate(i.ONE, i.ONE, i.ONE, i.ONE)) : (i.blendEquation(i.FUNC_ADD), i.blendFunc(i.SRC_ALPHA, i.ONE)) : t == J.BLEND_MODES.BLEND_SUB ? e ? (i.blendEquationSeparate(i.FUNC_ADD, i.FUNC_ADD), i.blendFuncSeparate(i.ZERO, i.ZERO, i.ONE_MINUS_SRC_COLOR, i.ONE_MINUS_SRC_ALPHA)) : (i.blendEquation(i.FUNC_ADD), i.blendFunc(i.ZERO, i.ONE_MINUS_SRC_COLOR)) : t == J.BLEND_MODES.BLEND_MUL ? e ? (i.blendEquationSeparate(i.FUNC_ADD, i.FUNC_ADD), i.blendFuncSeparate(i.ZERO, i.SRC_COLOR, i.ZERO, i.SRC_ALPHA)) : (i.blendEquation(i.FUNC_ADD), i.blendFunc(i.ZERO, i.SRC_COLOR)) : t == J.BLEND_MODES.BLEND_NORMAL ? e ? (i.blendEquationSeparate(i.FUNC_ADD, i.FUNC_ADD), i.blendFuncSeparate(i.ONE, i.ONE_MINUS_SRC_ALPHA, i.ONE, i.ONE_MINUS_SRC_ALPHA)) : (i.blendEquationSeparate(i.FUNC_ADD, i.FUNC_ADD), i.blendFuncSeparate(i.SRC_ALPHA, i.ONE_MINUS_SRC_ALPHA, i.ONE, i.ONE_MINUS_SRC_ALPHA)) : this._log.log("setblendmode: unknown blendmode"))
        }, St.prototype.createMesh = function(t, e) {
            return new CGL.Mesh(this, t, e)
        }, St.prototype.setCursor = function(t) {
            this._cursor = t
        }, St.prototype.enableExtension = function(t) {
            const e = this.gl.getExtension(t);
            return e || this._log.stack("[cgl_state] extension not available"), e
        };
        const Rt = Object.assign({
            Framebuffer: function(t, e, i, s) {
                const n = t;
                this._log = new r("Framebuffer"), this.valid = !0;
                const o = n.enableExtension("WEBGL_depth_texture") || n.enableExtension("WEBKIT_WEBGL_depth_texture") || n.enableExtension("MOZ_WEBGL_depth_texture") || n.gl.DEPTH_TEXTURE;
                o || n.exitError("NO_DEPTH_TEXTURE", "no depth texture support");
                let a = e || 512,
                    h = i || 512;
                (s = s || {
                    isFloatingPointTexture: !1
                }).hasOwnProperty("clear") || (s.clear = !0), s.hasOwnProperty("filter") || (s.filter = M.FILTER_LINEAR);
                const l = new M(n, {
                    isFloatingPointTexture: s.isFloatingPointTexture,
                    filter: s.filter,
                    wrap: s.wrap || M.CLAMP_TO_EDGE
                });
                let c = null;
                o && (c = new M(n, {
                    isDepthTexture: !0
                })), this._options = s;
                const u = n.gl.createFramebuffer(),
                    _ = n.gl.createRenderbuffer();
                this.getWidth = function() {
                    return a
                }, this.getHeight = function() {
                    return h
                }, this.getGlFrameBuffer = function() {
                    return u
                }, this.getDepthRenderBuffer = function() {
                    return _
                }, this.getTextureColor = function() {
                    return l
                }, this.getTextureDepth = function() {
                    return c
                }, this.setFilter = function(t) {
                    l.filter = t, l.setSize(a, h)
                }, this.setSize = function(t, e) {
                    if (t < 2 && (t = 2), e < 2 && (e = 2), a = Math.ceil(t), h = Math.ceil(e), n.profileData.profileFrameBuffercreate++, n.gl.bindFramebuffer(n.gl.FRAMEBUFFER, u), n.gl.bindRenderbuffer(n.gl.RENDERBUFFER, _), l.setSize(a, h), c && c.setSize(a, h), o && n.gl.renderbufferStorage(n.gl.RENDERBUFFER, n.gl.DEPTH_COMPONENT16, a, h), n.gl.framebufferTexture2D(n.gl.FRAMEBUFFER, n.gl.COLOR_ATTACHMENT0, n.gl.TEXTURE_2D, l.tex, 0), o && (n.gl.framebufferRenderbuffer(n.gl.FRAMEBUFFER, n.gl.DEPTH_ATTACHMENT, n.gl.RENDERBUFFER, _), n.gl.framebufferTexture2D(n.gl.FRAMEBUFFER, n.gl.DEPTH_ATTACHMENT, n.gl.TEXTURE_2D, c.tex, 0)), !n.gl.isFramebuffer(u)) throw new Error("Invalid framebuffer");
                    const i = n.gl.checkFramebufferStatus(n.gl.FRAMEBUFFER);
                    switch (i) {
                        case n.gl.FRAMEBUFFER_COMPLETE:
                            break;
                        case n.gl.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:
                            throw this._log.warn("FRAMEBUFFER_INCOMPLETE_ATTACHMENT...", a, h, l.tex, _), this.valid = !1, new Error("Incomplete framebuffer: FRAMEBUFFER_INCOMPLETE_ATTACHMENT");
                        case n.gl.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:
                            throw this._log.warn("FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT"), this.valid = !1, new Error("Incomplete framebuffer: FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT");
                        case n.gl.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:
                            throw this._log.warn("FRAMEBUFFER_INCOMPLETE_DIMENSIONS"), this.valid = !1, new Error("Incomplete framebuffer: FRAMEBUFFER_INCOMPLETE_DIMENSIONS");
                        case n.gl.FRAMEBUFFER_UNSUPPORTED:
                            throw this._log.warn("FRAMEBUFFER_UNSUPPORTED"), this.valid = !1, new Error("Incomplete framebuffer: FRAMEBUFFER_UNSUPPORTED");
                        case 36059:
                            this._log.warn("Incomplete: FRAMEBUFFER_INCOMPLETE_DRAW_BUFFER from ext. Or Safari/iOS undefined behaviour."), this.valid = !1;
                            break;
                        default:
                            throw this._log.warn("incomplete framebuffer", i), this.valid = !1, new Error("Incomplete framebuffer: " + i)
                    }
                    n.gl.bindTexture(n.gl.TEXTURE_2D, null), n.gl.bindRenderbuffer(n.gl.RENDERBUFFER, null), n.gl.bindFramebuffer(n.gl.FRAMEBUFFER, null)
                }, this.renderStart = function() {
                    n.pushModelMatrix(), n.gl.bindFramebuffer(n.gl.FRAMEBUFFER, u), n.pushGlFrameBuffer(u), n.pushFrameBuffer(this), n.pushPMatrix(), n.gl.viewport(0, 0, a, h), this._options.clear && (n.gl.clearColor(0, 0, 0, 0), n.gl.clear(n.gl.COLOR_BUFFER_BIT | n.gl.DEPTH_BUFFER_BIT))
                }, this.renderEnd = function() {
                    n.popPMatrix(), n.gl.bindFramebuffer(n.gl.FRAMEBUFFER, n.popGlFrameBuffer()), n.popFrameBuffer(), n.popModelMatrix(), n.resetViewPort()
                }, this.delete = function() {
                    l.delete(), this.valid = !1, c && c.delete(), n.gl.deleteRenderbuffer(_), n.gl.deleteFramebuffer(u)
                }, this.setSize(a, h)
            },
            Framebuffer2: B,
            Geometry: H,
            BoundingBox: G,
            Marker: function(t) {
                const e = new H("marker");
                e.setPointVertices([1e-5, 0, 0, 1, 0, 0, 0, 1e-5, 0, 0, 1, 0, 0, 0, 1e-5, 0, 0, 1]);
                const i = new $(t, e, t.gl.LINES);
                i.setGeom(e);
                const s = new dt(t, "markermaterial"),
                    r = "".endl() + "precision highp float;".endl() + "IN vec3 axisColor;".endl() + "void main()".endl() + "{".endl() + "    vec4 col=vec4(axisColor,1.0);".endl() + "    outColor = col;".endl() + "}",
                    n = "".endl() + "IN vec3 vPosition;".endl() + "UNI mat4 projMatrix;".endl() + "UNI mat4 mvMatrix;".endl() + "OUT vec3 axisColor;".endl() + "void main()".endl() + "{".endl() + "   vec4 pos=vec4(vPosition, 1.0);".endl() + "   if(pos.x!=0.0)axisColor=vec3(1.0,0.3,0.0);".endl() + "   if(pos.y!=0.0)axisColor=vec3(0.0,1.0,0.2);".endl() + "   if(pos.z!=0.0)axisColor=vec3(0.0,0.5,1.0);".endl() + "   gl_Position = projMatrix * mvMatrix * pos;".endl() + "}";
                s.setSource(n, r), this._vScale = vec3.create(), this.draw = function(t, e, r) {
                    const n = e || 2;
                    t.pushModelMatrix(), t.pushShader(s), vec3.set(this._vScale, n, n, n), mat4.scale(t.mvMatrix, t.mvMatrix, this._vScale), t.pushDepthTest(1 == r), i.render(t.getShader()), t.popDepthTest(), t.popShader(), t.popModelMatrix()
                }
            },
            WirePoint: function(t) {
                const e = t.gl.createBuffer(),
                    i = vec3.create();
                this.render = function(t, s) {
                        t.pushModelMatrix(), vec3.set(i, s, s, s), mat4.scale(t.mvMatrix, t.mvMatrix, i);
                        const r = t.getShader();
                        r && (r.bind(), t.gl.bindBuffer(t.gl.ARRAY_BUFFER, e), t.gl.vertexAttribPointer(r.getAttrVertexPos(), e.itemSize, t.gl.FLOAT, !1, 0, 0), t.gl.enableVertexAttribArray(r.getAttrVertexPos()), t.gl.bindBuffer(t.gl.ARRAY_BUFFER, e), t.gl.drawArrays(t.gl.LINE_STRIP, 0, e.numItems)), t.popModelMatrix()
                    },
                    function() {
                        const i = [],
                            s = 24;
                        let r = 0,
                            n = 0;
                        const o = .5;
                        for (r = 0; r <= Math.round(s); r++) n = 360 / Math.round(s) * r * ot, i.push(Math.cos(n) * o), i.push(0), i.push(Math.sin(n) * o);
                        for (r = 0; r <= Math.round(s); r++) n = 360 / Math.round(s) * r * ot, i.push(Math.cos(n) * o), i.push(Math.sin(n) * o), i.push(0);
                        for (r = 0; r <= Math.round(s); r++) n = 360 / Math.round(s) * r * ot, i.push(0), i.push(Math.cos(n) * o), i.push(Math.sin(n) * o);
                        t.gl.bindBuffer(t.gl.ARRAY_BUFFER, e), t.gl.bufferData(t.gl.ARRAY_BUFFER, new Float32Array(i), t.gl.STATIC_DRAW), e.itemSize = 3, e.numItems = i.length / e.itemSize
                    }()
            },
            WireCube: function(t) {
                const e = t.gl.createBuffer(),
                    i = vec3.create();
                this.render = function(t, s, r, n) {
                        t.pushModelMatrix(), vec3.set(i, s || 1, r || 1, n || 1), mat4.scale(t.mvMatrix, t.mvMatrix, i);
                        const o = t.getShader();
                        o && (o.bind(), t.gl.bindBuffer(t.gl.ARRAY_BUFFER, e), t.gl.vertexAttribPointer(o.getAttrVertexPos(), e.itemSize, t.gl.FLOAT, !1, 0, 0), t.gl.enableVertexAttribArray(o.getAttrVertexPos()), t.gl.bindBuffer(t.gl.ARRAY_BUFFER, e), t.gl.drawArrays(t.gl.LINE_STRIP, 0, e.numItems)), t.popModelMatrix()
                    },
                    function() {
                        const i = [];
                        i.push(-1, -1, 1), i.push(1, -1, 1), i.push(1, 1, 1), i.push(-1, 1, 1), i.push(-1, -1, 1), i.push(-1, -1, -1), i.push(1, -1, -1), i.push(1, 1, -1), i.push(-1, 1, -1), i.push(-1, -1, -1), i.push(-1, -1, -1), i.push(-1, 1, -1), i.push(-1, 1, 1), i.push(-1, -1, 1), i.push(-1, -1, -1), i.push(1, -1, -1), i.push(1, 1, -1), i.push(1, 1, 1), i.push(1, -1, 1), i.push(1, -1, -1), t.gl.bindBuffer(t.gl.ARRAY_BUFFER, e), t.gl.bufferData(t.gl.ARRAY_BUFFER, new Float32Array(i), t.gl.STATIC_DRAW), e.itemSize = 3, e.numItems = i.length / e.itemSize
                    }()
            },
            MatrixStack: yt,
            Mesh: $,
            MESH: Z,
            ShaderLibMods: it,
            Shader: dt,
            Uniform: Q,
            MESHES: tt,
            Context: St,
            Texture: M,
            TextureEffect: et,
            isWindows: at,
            getWheelSpeed: lt,
            getWheelDelta: ct,
            onLoadingAssetsFinished: null,
            ProfileData: ft,
            UniColorShader: class {
                constructor(t) {
                    this.shader = new CGL.Shader(t, "markermaterial");
                    const e = "".endl() + "void main()".endl() + "{".endl() + "    outColor = vec4(color.rgb,1.0);".endl() + "}",
                        i = "".endl() + "IN vec3 vPosition;".endl() + "UNI mat4 projMatrix;".endl() + "UNI mat4 mvMatrix;".endl() + "void main()".endl() + "{".endl() + "   gl_Position = projMatrix * mvMatrix * vec4(vPosition,1.0);".endl() + "}";
                    this.shader.setSource(i, e), this.coloruni = this.shader.addUniformFrag("4f", "color", [1, .777, 1, 1])
                }
                setColor(t, e, i, s) {
                    this.coloruni.set(t, e, i, s)
                }
            }
        }, J.BLEND_MODES, J.SHADER, J.MATH, J.BLEND_MODES);
        window.CGL = Rt;
        const Pt = function(t) {
            z.apply(this), this.id = CABLES.simpleId(), this.portIn = null, this.portOut = null, this.scene = t, this.activityCounter = 0, this.ignoreInSerialize = !1
        };
        Pt.prototype.setValue = function(t) {
            void 0 === t ? this._setValue() : this.portIn.set(t)
        }, Pt.prototype.activity = function() {
            this.activityCounter++
        }, Pt.prototype._setValue = function() {
            if (!this.portOut) return void this.remove();
            const t = this.portOut.get();
            t == t && (this.portIn.type != o.OP_PORT_TYPE_FUNCTION && this.activity(), this.portIn.get() !== t ? this.portIn.set(t) : (this.portIn.changeAlways && this.portIn.set(t), this.portOut.forceRefChange && this.portIn.forceChange()))
        }, Pt.prototype.getOtherPort = function(t) {
            return t == this.portIn ? this.portOut : this.portIn
        }, Pt.prototype.remove = function() {
            this.portIn && this.portIn.removeLink(this), this.portOut && this.portOut.removeLink(this), this.scene && this.scene.emitEvent("onUnLink", this.portIn, this.portOut, this), !this.portIn || this.portIn.type != o.OP_PORT_TYPE_OBJECT && this.portIn.type != o.OP_PORT_TYPE_ARRAY || (this.portIn.set(null), this.portIn.links.length > 0 && this.portIn.set(this.portIn.links[0].getOtherPort(this.portIn).get())), this.portIn && this.portIn.op._checkLinksNeededToWork(), this.portOut && this.portOut.op._checkLinksNeededToWork(), this.portIn = null, this.portOut = null, this.scene = null
        }, Pt.prototype.link = function(t, e) {
            if (!Pt.canLink(t, e)) return console.warn("[core_link] cannot link ports!", t, e), !1;
            t.direction == a.PORT_DIR_IN ? (this.portIn = t, this.portOut = e) : (this.portIn = e, this.portOut = t), t.addLink(this), e.addLink(this), this.setValue(), t.onLink && t.onLink(this), e.onLink && e.onLink(this), t.op._checkLinksNeededToWork(), e.op._checkLinksNeededToWork()
        }, Pt.prototype.getSerialized = function() {
            const t = {};
            return t.portIn = this.portIn.getName(), t.portOut = this.portOut.getName(), t.objIn = this.portIn.op.id, t.objOut = this.portOut.op.id, t
        }, Pt.canLinkText = function(t, e) {
            if (t.direction == e.direction) {
                let t = "(out)";
                return e.direction == a.PORT_DIR_IN && (t = "(in)"), "can not link: same direction " + t
            }
            return t.op == e.op ? "can not link: same op" : t.type != o.OP_PORT_TYPE_DYNAMIC && e.type != o.OP_PORT_TYPE_DYNAMIC && t.type != e.type ? "can not link: different type" : CABLES.UI && t.type == o.OP_PORT_TYPE_OBJECT && e.type == o.OP_PORT_TYPE_OBJECT && t.uiAttribs.objType && e.uiAttribs.objType && t.uiAttribs.objType != e.uiAttribs.objType ? "incompatible objects" : t ? e ? t.direction == a.PORT_DIR_IN && t.isAnimated() || e.direction == a.PORT_DIR_IN && e.isAnimated() ? "can not link: is animated" : t.isLinkedTo(e) ? "ports already linked" : t.canLink && !t.canLink(e) || e.canLink && !e.canLink(t) ? "Incompatible" : "can link" : "can not link: port 2 invalid" : "can not link: port 1 invalid"
        }, Pt.canLink = function(t, e) {
            if (!t) return !1;
            if (!e) return !1;
            if (t.direction == a.PORT_DIR_IN && t.isAnimated()) return !1;
            if (e.direction == a.PORT_DIR_IN && e.isAnimated()) return !1;
            if (t.isHidden() || e.isHidden()) return !1;
            if (t.isLinkedTo(e)) return !1;
            if (t.direction == e.direction) return !1;
            if (CABLES.UI && t.type == o.OP_PORT_TYPE_OBJECT && e.type == o.OP_PORT_TYPE_OBJECT && t.uiAttribs.objType && e.uiAttribs.objType) {
                if (0 == t.uiAttribs.objType.indexOf("sg_") && 0 == e.uiAttribs.objType.indexOf("sg_")) return !0;
                if (t.uiAttribs.objType != e.uiAttribs.objType) return !1
            }
            return !(t.type != e.type && t.type != o.OP_PORT_TYPE_DYNAMIC && e.type != o.OP_PORT_TYPE_DYNAMIC || t.type != o.OP_PORT_TYPE_DYNAMIC && e.type != o.OP_PORT_TYPE_DYNAMIC && (t.op == e.op || t.canLink && !t.canLink(e) || e.canLink && !e.canLink(t)))
        };
        class Ot extends X {
            constructor(t, e, i, s, r) {
                super(t, e, i, s), this.get = () => {
                    let t = super.get();
                    return CABLES.UI && ("" === t || null == t || s.values && -1 === s.values.indexOf(String(t)) ? this.op.setUiError("invalidswitch", "Invalid Value [" + this.name + ']: "' + t + '"') : this.op.setUiError("invalidswitch", null)), null == t && (t = ""), t
                }, this.indexPort = r, this.indexPort.set = t => {
                    const e = s.values;
                    if (!e) return void console.log("has no values");
                    let i = Math.floor(t);
                    i = Math.min(i, e.length - 1), i = Math.max(i, 0), this.indexPort.setValue(i), this.set(e[i]), this.op.patch.isEditorMode() && window.gui && gui.patchView.isCurrentOp(this.op) && gui.opParams.show(this.op)
                }
            }
            setUiAttribs(t) {
                const e = t.hidePort;
                t.hidePort = !0, super.setUiAttribs(t), void 0 !== e && this.indexPort.setUiAttribs({
                    hidePort: e
                })
            }
        }
        class Ft extends Ot {
            setUiAttribs(t) {
                if (this.indexPort.isLinked())
                    for (const e in t) "greyout" != e || t[e] || (t[e] = "true");
                super.setUiAttribs(t)
            }
        }
        const Nt = function() {
            z.apply(this), this._log = new r("core_op"), this.data = {}, this.storage = {}, this._objName = "", this.portsOut = [], this.portsIn = [], this.portsInData = [], this.opId = "", this.uiAttribs = {}, this.enabled = !0, this.patch = arguments[0], this.name = arguments[1], this._linkTimeRules = {
                needsLinkedToWork: [],
                needsParentOp: null
            }, this.shouldWork = {}, this.hasUiErrors = !1, this._uiErrors = {}, this._hasAnimPort = !1, arguments[1] && (this._shortOpName = CABLES.getShortOpName(arguments[1]), this.getTitle()), this.id = arguments[2] || f(), this.onAddPort = null, this.onCreate = null, this.onResize = null, this.onLoaded = null, this.onDelete = null, this.onUiAttrChange = null, this.onError = null, this._instances = null, this.preRender = null, this.init = null, Object.defineProperty(this, "objName", {
                get() {
                    return this._objName
                }
            }), Object.defineProperty(this, "shortName", {
                get() {
                    return this._shortOpName
                }
            })
        };
        {
            Nt.prototype.clearUiAttrib = function(t) {
                this.uiAttrib({
                    name: null
                })
            }, Nt.prototype.getTitle = function() {
                return this.uiAttribs ? (void 0 !== this.uiAttribs.title && "" !== this.uiAttribs.title || -1 != this.objName.indexOf("Ops.Ui.") || (this.uiAttribs.title = this._shortOpName), void 0 === this.uiAttribs.title && (this.uiAttribs.title = this._shortOpName), this.uiAttribs.title) : "nouiattribs" + this.name
            }, Nt.prototype.setTitle = function(t) {
                const e = this.name != t;
                this.name = t, this.uiAttribs.title != t && this.uiAttr({
                    title: t
                }), e && this.emitEvent("onTitleChange", t)
            }, Nt.prototype.setStorage = function(t) {
                if (!t) return;
                this.storage = this.storage || {};
                let e = !1;
                for (const i in t) this.storage[i] != t[i] && (e = !0), this.storage[i] = t[i];
                e && this.emitEvent("onStorageChange", t)
            }, Nt.prototype.isSubPatchOp = function() {
                if (this.storage) return this.storage.subPatchVer || 0
            };
            const t = function(t) {
                if (!t) return;
                (t.error || t.warning || t.hint) && this._log.warn("old ui error/warning attribute in " + this.name + ", use op.setUiError !", t), "object" != typeof t && this._log.error("op.uiAttrib attribs are not of type object"), this.uiAttribs || (this.uiAttribs = {});
                let e = !1;
                !CABLES.UI || !t.hasOwnProperty("translate") || this.uiAttribs.translate && this.uiAttribs.translate.x == t.translate.x && this.uiAttribs.translate.y == t.translate.y || (e = !0);
                let i = !1;
                for (const e in t) this.uiAttribs[e] != t[e] && (i = !0), this.uiAttribs[e] = t[e];
                this.uiAttribs.hasOwnProperty("selected") && 0 == this.uiAttribs.selected && delete this.uiAttribs.selected, t.title && t.title != this.name && this.setTitle(t.title), i && (this.emitEvent("onUiAttribsChange", t), this.patch.emitEvent("onUiAttribsChange", this, t)), e && this.emitEvent("move")
            };
            Nt.prototype.setUiAttribs = Nt.prototype.setUiAttrib = Nt.prototype.uiAttr = t, Nt.prototype.getName = function() {
                return this.uiAttribs.name ? this.uiAttribs.name : this.name
            }, Nt.prototype.addOutPort = function(t) {
                return t.direction = a.PORT_DIR_OUT, t._op = this, this.portsOut.push(t), this.emitEvent("onPortAdd", t), t
            }, Nt.prototype.hasDynamicPort = function() {
                let t = 0;
                for (t = 0; t < this.portsIn.length; t++) {
                    if (this.portsIn[t].type == o.OP_PORT_TYPE_DYNAMIC) return !0;
                    if ("dyn" == this.portsIn[t].getName()) return !0
                }
                for (t = 0; t < this.portsOut.length; t++) {
                    if (this.portsOut[t].type == o.OP_PORT_TYPE_DYNAMIC) return !0;
                    if ("dyn" == this.portsOut[t].getName()) return !0
                }
                return !1
            }, Nt.prototype.addInPort = function(t) {
                if (!(t instanceof X)) throw new Error("parameter is not a port!");
                return t.direction = a.PORT_DIR_IN, t._op = this, this.portsIn.push(t), this.emitEvent("onPortAdd", t), t
            }, Nt.prototype.inFunction = Nt.prototype.inTrigger = function(t, e) {
                const i = this.addInPort(new X(this, t, o.OP_PORT_TYPE_FUNCTION));
                return void 0 !== e && i.set(e), i
            }, Nt.prototype.inFunctionButton = Nt.prototype.inTriggerButton = function(t, e) {
                const i = this.addInPort(new X(this, t, o.OP_PORT_TYPE_FUNCTION, {
                    display: "button"
                }));
                return void 0 !== e && i.set(e), i
            }, Nt.prototype.inFunctionButton = Nt.prototype.inUiTriggerButtons = function(t, e) {
                const i = this.addInPort(new X(this, t, o.OP_PORT_TYPE_FUNCTION, {
                    display: "buttons"
                }));
                return void 0 !== e && i.set(e), i
            }, Nt.prototype.inValueFloat = Nt.prototype.inValue = Nt.prototype.inFloat = function(t, e) {
                const i = this.addInPort(new X(this, t, o.OP_PORT_TYPE_VALUE));
                return void 0 !== e && (i.set(e), i.defaultValue = e), i
            }, Nt.prototype.inValueBool = Nt.prototype.inBool = function(t, e) {
                const i = this.addInPort(new X(this, t, o.OP_PORT_TYPE_VALUE, {
                    display: "bool"
                }));
                return void 0 !== e && (i.set(e), i.defaultValue = i.get()), i
            }, Nt.prototype.inValueString = function(t, e) {
                const i = this.addInPort(new X(this, t, o.OP_PORT_TYPE_VALUE, {
                    type: "string"
                }));
                return i.value = "", void 0 !== e && (i.set(e), i.defaultValue = e), i
            }, Nt.prototype.inString = function(t, e) {
                const i = this.addInPort(new X(this, t, o.OP_PORT_TYPE_STRING, {
                    type: "string"
                }));
                return e = e || "", i.value = e, i.set(e), i.defaultValue = e, i
            }, Nt.prototype.inValueText = function(t, e) {
                const i = this.addInPort(new X(this, t, o.OP_PORT_TYPE_VALUE, {
                    type: "string",
                    display: "text"
                }));
                return i.value = "", void 0 !== e && (i.set(e), i.defaultValue = e), i
            }, Nt.prototype.inTextarea = function(t, e) {
                const i = this.addInPort(new X(this, t, o.OP_PORT_TYPE_STRING, {
                    type: "string",
                    display: "text"
                }));
                return i.value = "", void 0 !== e && (i.set(e), i.defaultValue = e), i
            }, Nt.prototype.inStringEditor = function(t, e, i, s = !0) {
                const r = this.addInPort(new X(this, t, o.OP_PORT_TYPE_STRING, {
                    type: "string",
                    display: "editor",
                    editShortcut: !0,
                    editorSyntax: i,
                    hideFormatButton: s
                }));
                return r.value = "", void 0 !== e && (r.set(e), r.defaultValue = e), r
            }, Nt.prototype.inValueEditor = function(t, e, i, s = !0) {
                const r = this.addInPort(new X(this, t, o.OP_PORT_TYPE_VALUE, {
                    type: "string",
                    display: "editor",
                    editorSyntax: i,
                    hideFormatButton: s
                }));
                return r.value = "", void 0 !== e && (r.set(e), r.defaultValue = e), r
            }, Nt.prototype.inValueSelect = Nt.prototype.inDropDown = function(t, e, i, s) {
                let r = null;
                if (s) {
                    const i = new X(this, t, o.OP_PORT_TYPE_VALUE, {
                        display: "dropdown",
                        hidePort: !0,
                        type: "string",
                        values: e
                    });
                    r = this.addInPort(i)
                } else {
                    const s = new X(this, t + " index", o.OP_PORT_TYPE_VALUE, {
                            increment: "integer",
                            hideParam: !0
                        }),
                        n = this.addInPort(s);
                    if (e)
                        for (let t = 0; t < e.length; t++) e[t] = String(e[t]);
                    const a = new Ft(this, t, o.OP_PORT_TYPE_VALUE, {
                        display: "dropdown",
                        hidePort: !0,
                        type: "string",
                        values: e
                    }, n);
                    if (a.indexPort = s, s.onLinkChanged = function() {
                            a.setUiAttribs({
                                greyout: s.isLinked()
                            })
                        }, r = this.addInPort(a), void 0 !== i) {
                        r.set(i);
                        const t = e.findIndex((t => t == i));
                        n.setValue(t), r.defaultValue = i, n.defaultValue = t
                    }
                }
                return r
            }, Nt.prototype.inSwitch = function(t, e, i, s) {
                let r = null;
                if (s) {
                    const i = new X(this, t, o.OP_PORT_TYPE_STRING, {
                        display: "switch",
                        hidePort: !0,
                        type: "string",
                        values: e
                    });
                    r = this.addInPort(i)
                } else {
                    i || (i = e[0]);
                    const s = new X(this, t + " index", o.OP_PORT_TYPE_VALUE, {
                            increment: "integer",
                            hideParam: !0
                        }),
                        n = this.addInPort(s);
                    if (e)
                        for (let t = 0; t < e.length; t++) e[t] = String(e[t]);
                    const a = new Ot(this, t, o.OP_PORT_TYPE_STRING, {
                        display: "switch",
                        hidePort: !0,
                        type: "string",
                        values: e
                    }, n);
                    if (s.onLinkChanged = function() {
                            a.setUiAttribs({
                                greyout: s.isLinked()
                            })
                        }, r = this.addInPort(a), void 0 !== i) {
                        r.set(i);
                        const t = e.findIndex((t => t == i));
                        n.setValue(t), r.defaultValue = i, n.defaultValue = t
                    }
                }
                return r
            }, Nt.prototype.inValueInt = Nt.prototype.inInt = function(t, e) {
                const i = this.addInPort(new X(this, t, o.OP_PORT_TYPE_VALUE, {
                    increment: "integer"
                }));
                return void 0 !== e && (i.set(e), i.defaultValue = e), i
            }, Nt.prototype.inFile = function(t, e, i) {
                const s = this.addInPort(new X(this, t, o.OP_PORT_TYPE_VALUE, {
                    display: "file",
                    type: "string",
                    filter: e
                }));
                return void 0 !== i && (s.set(i), s.defaultValue = i), s
            }, Nt.prototype.inUrl = function(t, e, i) {
                const s = this.addInPort(new X(this, t, o.OP_PORT_TYPE_STRING, {
                    display: "file",
                    type: "string",
                    filter: e
                }));
                return void 0 !== i && (s.set(i), s.defaultValue = i), s
            }, Nt.prototype.inTexture = function(t, e) {
                const i = this.addInPort(new X(this, t, o.OP_PORT_TYPE_OBJECT, {
                    display: "texture",
                    objType: "texture",
                    preview: !0
                }));
                return i.ignoreValueSerialize = !0, void 0 !== e && i.set(e), i
            }, Nt.prototype.inObject = function(t, e, i) {
                const s = this.addInPort(new X(this, t, o.OP_PORT_TYPE_OBJECT, {
                    objType: i
                }));
                return s.ignoreValueSerialize = !0, void 0 !== e && s.set(e), s
            }, Nt.prototype.inGradient = function(t, e) {
                const i = this.addInPort(new X(this, t, o.OP_PORT_TYPE_VALUE, {
                    display: "gradient",
                    hidePort: !0
                }));
                return void 0 !== e && i.set(e), i
            }, Nt.prototype.inArray = function(t, e, i) {
                !i && CABLES.UTILS.isNumeric(e) && (i = e);
                const s = this.addInPort(new X(this, t, o.OP_PORT_TYPE_ARRAY, {
                    stride: i
                }));
                return void 0 === e || !Array.isArray(e) && null != e || s.set(e), s
            }, Nt.prototype.inValueSlider = Nt.prototype.inFloatSlider = function(t, e, i, s) {
                const r = {
                    display: "range"
                };
                null != i && null != s && (r.min = i, r.max = s);
                const n = this.addInPort(new X(this, t, o.OP_PORT_TYPE_VALUE, r));
                return void 0 !== e && (n.set(e), n.defaultValue = e), n
            }, Nt.prototype.outFunction = Nt.prototype.outTrigger = function(t, e) {
                const i = this.addOutPort(new X(this, t, o.OP_PORT_TYPE_FUNCTION));
                return void 0 !== e && i.set(e), i
            }, Nt.prototype.outValue = Nt.prototype.outNumber = function(t, e) {
                const i = this.addOutPort(new X(this, t, o.OP_PORT_TYPE_VALUE));
                return void 0 !== e && i.set(e), i
            }, Nt.prototype.outValueBool = Nt.prototype.outBool = function(t, e) {
                const i = this.addOutPort(new X(this, t, o.OP_PORT_TYPE_VALUE, {
                    display: "bool"
                }));
                return void 0 !== e ? i.set(e) : i.set(0), i
            }, Nt.prototype.outBoolNum = function(t, e) {
                const i = this.addOutPort(new X(this, t, o.OP_PORT_TYPE_VALUE, {
                    display: "boolnum"
                }));
                return i.set = function(t) {
                    this.setValue(t ? 1 : 0)
                }.bind(i), void 0 !== e ? i.set(e) : i.set(0), i
            }, Nt.prototype.outValueString = function(t, e) {
                const i = this.addOutPort(new X(this, t, o.OP_PORT_TYPE_VALUE, {
                    type: "string"
                }));
                return void 0 !== e && i.set(e), i
            }, Nt.prototype.outString = function(t, e) {
                const i = this.addOutPort(new X(this, t, o.OP_PORT_TYPE_STRING, {
                    type: "string"
                }));
                return void 0 !== e ? i.set(e) : i.set(""), i
            }, Nt.prototype.outObject = function(t, e, i) {
                const s = this.addOutPort(new X(this, t, o.OP_PORT_TYPE_OBJECT, {
                    objType: i || null
                }));
                return s.set(e || null), s.ignoreValueSerialize = !0, s
            }, Nt.prototype.outArray = function(t, e, i) {
                !i && CABLES.UTILS.isNumeric(e) && (i = e);
                const s = this.addOutPort(new X(this, t, o.OP_PORT_TYPE_ARRAY, {
                    stride: i
                }));
                return void 0 === e || !Array.isArray(e) && null != e || s.set(e), s.ignoreValueSerialize = !0, s
            }, Nt.prototype.outTexture = function(t, e) {
                const i = this.addOutPort(new X(this, t, o.OP_PORT_TYPE_OBJECT, {
                    preview: !0,
                    objType: "texture"
                }));
                return void 0 !== e && i.set(e || CGL.Texture.getEmptyTexture(this.patch.cgl)), i.ignoreValueSerialize = !0, i
            }, Nt.prototype.inDynamic = function(t, e, i, s) {
                const r = new X(this, t, o.OP_PORT_TYPE_DYNAMIC, i);
                return r.shouldLink = function(t, i) {
                    if (e && l.isArray(e)) {
                        for (let s = 0; s < e.length; s++) {
                            if (t == this && i.type === e[s]) return !0;
                            if (i == this && t.type === e[s]) return !0
                        }
                        return !1
                    }
                    return !0
                }, this.addInPort(r), void 0 !== s && (r.set(s), r.defaultValue = s), r
            }, Nt.prototype.removeLinks = function() {
                for (let t = 0; t < this.portsIn.length; t++) this.portsIn[t].removeLinks();
                for (let t = 0; t < this.portsOut.length; t++) this.portsOut[t].removeLinks()
            }, Nt.prototype.getSerialized = function() {
                const t = {};
                this.opId && (t.opId = this.opId), this.patch.storeObjNames && (t.objName = this.objName), t.id = this.id, t.uiAttribs = JSON.parse(JSON.stringify(this.uiAttribs)) || {}, this.storage && Object.keys(this.storage).length > 0 && (t.storage = JSON.parse(JSON.stringify(this.storage))), this.uiAttribs.hasOwnProperty("working") && 1 == this.uiAttribs.working && delete this.uiAttribs.working, t.uiAttribs.hasOwnProperty("uierrors") && delete t.uiAttribs.uierrors, t.portsIn = [], t.portsOut = [];
                for (let e = 0; e < this.portsIn.length; e++) t.portsIn.push(this.portsIn[e].getSerialized());
                for (const e in this.portsOut) t.portsOut.push(this.portsOut[e].getSerialized());
                return t
            }, Nt.prototype.getFirstOutPortByType = function(t) {
                for (const e in this.portsOut)
                    if (this.portsOut[e].type == t) return this.portsOut[e]
            }, Nt.prototype.getFirstInPortByType = function(t) {
                for (const e in this.portsIn)
                    if (this.portsIn[e].type == t) return this.portsIn[e]
            }, Nt.prototype.getPort = Nt.prototype.getPortByName = function(t, e) {
                if (e) {
                    for (let e = 0; e < this.portsIn.length; e++)
                        if (this.portsIn[e].getName().toLowerCase() == t || this.portsIn[e].id.toLowerCase() == t) return this.portsIn[e];
                    for (let e = 0; e < this.portsOut.length; e++)
                        if (this.portsOut[e].getName().toLowerCase() == t || this.portsOut[e].id.toLowerCase() == t) return this.portsOut[e]
                } else {
                    for (let e = 0; e < this.portsIn.length; e++)
                        if (this.portsIn[e].getName() == t || this.portsIn[e].id == t) return this.portsIn[e];
                    for (let e = 0; e < this.portsOut.length; e++)
                        if (this.portsOut[e].getName() == t || this.portsOut[e].id == t) return this.portsOut[e]
                }
            }, Nt.prototype.getPortById = function(t) {
                for (let e = 0; e < this.portsIn.length; e++)
                    if (this.portsIn[e].id == t) return this.portsIn[e];
                for (let e = 0; e < this.portsOut.length; e++)
                    if (this.portsOut[e].id == t) return this.portsOut[e]
            }, Nt.prototype.updateAnims = function() {
                if (this._hasAnimPort)
                    for (let t = 0; t < this.portsIn.length; t++) this.portsIn[t].updateAnim()
            }, Nt.prototype.log = function() {
                const t = "op " + this.objName;
                if (CABLES.UI && !CABLES.UI.logFilter.shouldPrint(t, ...arguments)) return;
                if (!CABLES.UI && this.patch.silent) return;
                const e = ["[op " + CABLES.getShortOpName(this.objName) + "]"];
                e.push.apply(e, arguments), Function.prototype.apply.apply(console.log, [console, e])
            }, Nt.prototype.error = Nt.prototype.logError = function() {
                if (!this) return void console.log("no this...!!!");
                const t = ["[op " + CABLES.getShortOpName(this.objName) + "]"];
                t.push.apply(t, arguments), Function.prototype.apply.apply(console.error, [console, t]), window.gui && window.gui.emitEvent("opLogEvent", this.objName, "error", arguments)
            }, Nt.prototype.warn = Nt.prototype.logWarn = function() {
                const t = ["[op " + CABLES.getShortOpName(this.objName) + "]"];
                t.push.apply(t, arguments), Function.prototype.apply.apply(console.warn, [console, t])
            }, Nt.prototype.verbose = Nt.prototype.logVerbose = function() {
                const t = "op " + CABLES.getShortOpName(this.objName);
                if (CABLES.UI && !CABLES.UI.logFilter.shouldPrint(t, ...arguments)) return;
                if (!CABLES.UI && this.patch.silent) return;
                const e = ["[" + t + "]"];
                e.push.apply(e, arguments), Function.prototype.apply.apply(console.info, [console, e])
            }, Nt.prototype.profile = function(t) {
                for (let t = 0; t < this.portsIn.length; t++) this.portsIn[t]._onTriggered = this.portsIn[t]._onTriggeredProfiling, this.portsIn[t].set = this.portsIn[t]._onSetProfiling
            }, Nt.prototype.findParent = function(t) {
                for (let e = 0; e < this.portsIn.length; e++)
                    if (this.portsIn[e].isLinked()) {
                        if (this.portsIn[e].links[0].portOut.parent.objName == t) return this.portsIn[e].links[0].portOut.parent;
                        let i = null;
                        if (i = this.portsIn[e].links[0].portOut.parent.findParent(t), i) return i
                    } return null
            }, Nt.prototype.cleanUp = function() {
                if (this._instances) {
                    for (let t = 0; t < this._instances.length; t++) this._instances[t].onDelete && this._instances[t].onDelete();
                    this._instances.length = 0
                }
                for (let t = 0; t < this.portsIn.length; t++) this.portsIn[t].setAnimated(!1);
                this.onAnimFrame && this.patch.removeOnAnimFrame(this)
            }, Nt.prototype.instanced = function(t) {
                if (console.log("instanced", this.patch.instancing.numCycles()), 0 === this.patch.instancing.numCycles()) return !1;
                let e = 0,
                    i = 0;
                if (!this._instances || this._instances.length != this.patch.instancing.numCycles()) {
                    for (this._instances || (this._instances = []), this._.log("creating instances of ", this.objName, this.patch.instancing.numCycles(), this._instances.length), this._instances.length = this.patch.instancing.numCycles(), e = 0; e < this._instances.length; e++) {
                        this._instances[e] = this.patch.createOp(this.objName, !0), this._instances[e].instanced = function() {
                            return !1
                        }, this._instances[e].uiAttr(this.uiAttribs);
                        for (let t = 0; t < this.portsOut.length; t++) this.portsOut[t].type == o.OP_PORT_TYPE_FUNCTION && (this._instances[e].getPortByName(this.portsOut[t].name).trigger = this.portsOut[t].trigger.bind(this.portsOut[t]))
                    }
                    for (i = 0; i < this.portsIn.length; i++) this.portsIn[i].onChange = null, this.portsIn[i].onValueChanged = null
                }
                for (i = 0; i < this.portsIn.length; i++) this.portsIn[i].type != o.OP_PORT_TYPE_VALUE && this.portsIn[i].type != o.OP_PORT_TYPE_ARRAY || this._instances[this.patch.instancing.index()].portsIn[i].set(this.portsIn[i].get()), this.portsIn[i].type;
                for (i = 0; i < this.portsOut.length; i++) this.portsOut[i].type == o.OP_PORT_TYPE_VALUE && this.portsOut[i].set(this._instances[this.patch.instancing.index()].portsOut[i].get());
                return !0
            }, Nt.prototype.initInstancable = function() {}, Nt.prototype.setValues = function(t) {
                for (const e in t) {
                    const i = this.getPortByName(e);
                    i ? i.set(t[e]) : this._log.warn("op.setValues: port not found:", e)
                }
            }, Nt.prototype.hasUiError = function(t) {
                return this._uiErrors.hasOwnProperty(t) && this._uiErrors[t]
            }, Nt.prototype.setUiError = function(t, e, i) {
                if (!e && !this.hasUiErrors) return;
                if (!e && !this._uiErrors.hasOwnProperty(t)) return;
                if (this._uiErrors.hasOwnProperty(t) && this._uiErrors[t].txt == e) return;
                t.indexOf(" ") > -1 && this._log.warn("setuierror id cant have spaces! ", t), t = t.replaceAll(" ", "_"), !e && this._uiErrors.hasOwnProperty(t) ? delete this._uiErrors[t] : !e || this._uiErrors.hasOwnProperty(t) && this._uiErrors[t].txt == e || (null == i && (i = 2), this._uiErrors[t] = {
                    txt: e,
                    level: i,
                    id: t
                });
                const s = [];
                for (const t in this._uiErrors) s.push(this._uiErrors[t]);
                this.uiAttr({
                    uierrors: s
                }), this.hasUiErrors = Object.keys(this._uiErrors).length, this.emitEvent("uiErrorChange")
            }, Nt.prototype.setError = function(t, e) {
                this._log.warn("old error message op.error() - use op.setUiError()")
            }, Nt.prototype.setEnabled = function(t) {
                this.enabled = t, this.emitEvent("onEnabledChange", t)
            }, Nt.prototype.setPortGroup = function(t, e) {
                for (let i = 0; i < e.length; i++) e[i] && (e[i].setUiAttribs ? e[i].setUiAttribs({
                    group: t
                }) : this._log.error("setPortGroup: invalid port!"))
            }, Nt.prototype.setUiAxisPorts = function(t, e, i) {
                t && t.setUiAttribs({
                    axis: "X"
                }), e && e.setUiAttribs({
                    axis: "Y"
                }), i && i.setUiAttribs({
                    axis: "Z"
                })
            }, Nt.prototype.removePort = function(t) {
                for (let e = 0; e < this.portsIn.length; e++)
                    if (this.portsIn[e] == t) return this.portsIn.splice(e, 1), this.emitEvent("onUiAttribsChange", {}), void this.emitEvent("onPortRemoved", {})
            }, Nt.prototype._checkLinksNeededToWork = function() {}, Nt.prototype.toWorkNeedsParent = function(t) {
                this.patch.isEditorMode() && (this._linkTimeRules.needsParentOp = t)
            }, Nt.prototype.toWorkShouldNotBeChild = function(t, e) {
                this.patch.isEditorMode() && (this._linkTimeRules.forbiddenParent = t, null != e && (this._linkTimeRules.forbiddenParentType = e))
            }, Nt.prototype.toWorkPortsNeedToBeLinked = function() {
                if (this.patch.isEditorMode())
                    for (let t = 0; t < arguments.length; t++) - 1 == this._linkTimeRules.needsLinkedToWork.indexOf(arguments[t]) && this._linkTimeRules.needsLinkedToWork.push(arguments[t])
            }, Nt.prototype.toWorkPortsNeedToBeLinkedReset = function() {
                this.patch.isEditorMode() && (this._linkTimeRules.needsLinkedToWork.length = 0, this.checkLinkTimeWarnings && this.checkLinkTimeWarnings())
            }, Nt.prototype.initVarPorts = function() {
                for (let t = 0; t < this.portsIn.length; t++) this.portsIn[t].getVariableName() && this.portsIn[t].setVariable(this.portsIn[t].getVariableName())
            }, Nt.prototype.refreshParams = function() {
                this.patch && this.patch.isEditorMode() && this.isCurrentUiOp() && gui.opParams.show(this)
            }, Nt.prototype.isCurrentUiOp = function() {
                if (this.patch.isEditorMode()) return gui.patchView.isCurrentOp(this)
            }, Nt.prototype.renderVizLayer = null
        }
        const Ct = function(t) {
            CABLES.EventTarget.apply(this), this._log = new r("LoadingStatus"), this._loadingAssets = {}, this._cbFinished = [], this._assetTasks = [], this._percent = 0, this._count = 0, this._countFinished = 0, this._order = 0, this._startTime = 0, this._patch = t, this._wasFinishedPrinted = !1, this._loadingAssetTaskCb = !1
        };
        Ct.prototype.setOnFinishedLoading = function(t) {
            this._cbFinished.push(t)
        }, Ct.prototype.getNumAssets = function() {
            return this._countFinished
        }, Ct.prototype.getProgress = function() {
            return this._percent
        }, Ct.prototype.checkStatus = function() {
            this._countFinished = 0, this._count = 0;
            for (const t in this._loadingAssets) this._count++, this._loadingAssets[t].finished || this._countFinished++;
            if (this._percent = (this._count - this._countFinished) / this._count, 0 === this._countFinished) {
                for (let t = 0; t < this._cbFinished.length; t++)
                    if (this._cbFinished[t]) {
                        const e = this._cbFinished[t];
                        setTimeout((() => {
                            e(this._patch), this.emitEvent("finishedAll")
                        }), 100)
                    } this._wasFinishedPrinted || (this._wasFinishedPrinted = !0, this.print()), this.emitEvent("finishedAll")
            }
        }, Ct.prototype.getList = function() {
            let t = [];
            for (const e in this._loadingAssets) t.push(this._loadingAssets[e]);
            return t
        }, Ct.prototype.getListJobs = function() {
            let t = [];
            for (const e in this._loadingAssets) this._loadingAssets[e].finished || t.push(this._loadingAssets[e].name);
            return t
        }, Ct.prototype.print = function() {
            if (this._patch.config.silent) return;
            const t = [];
            for (const e in this._loadingAssets) t.push([this._loadingAssets[e].order, this._loadingAssets[e].type, this._loadingAssets[e].name, (this._loadingAssets[e].timeEnd - this._loadingAssets[e].timeStart) / 1e3 + "s"]);
            this._log.groupCollapsed("finished loading " + this._order + " assets in " + (Date.now() - this._startTime) / 1e3 + "s"), this._log.table(t), this._log.groupEnd()
        }, Ct.prototype.finished = function(t) {
            const e = this._loadingAssets[t];
            e && (e.finished && this._log.warn("loading job was already finished", e), e.op && e.op.setUiAttribs({
                loading: !1
            }), e.finished = !0, e.timeEnd = Date.now()), this.checkStatus(), this.emitEvent("finishedTask")
        }, Ct.prototype._startAssetTasks = function() {
            for (let t = 0; t < this._assetTasks.length; t++) this._assetTasks[t]();
            this._assetTasks.length = 0
        }, Ct.prototype.addAssetLoadingTask = function(t) {
            this._patch.isEditorMode() && !CABLES.UI.loaded ? (this._assetTasks.push(t), this._loadingAssetTaskCb || window.gui.addEventListener("uiloaded", this._startAssetTasks.bind(this)), this._loadingAssetTaskCb = !0) : t(), this.emitEvent("addAssetTask")
        }, Ct.prototype.existByName = function(t) {
            for (let e in this._loadingAssets)
                if (this._loadingAssets[e].name == t && !this._loadingAssets[e].finished) return !0
        }, Ct.prototype.start = function(t, e, i) {
            0 == this._startTime && (this._startTime = Date.now());
            const s = m();
            return i && i.setUiAttribs({
                loading: !0
            }), this._loadingAssets[s] = {
                id: s,
                op: i,
                type: t,
                name: e,
                finished: !1,
                timeStart: Date.now(),
                order: this._order
            }, this._order++, this.emitEvent("startTask"), s
        };
        const wt = function() {
            this._loops = [], this._indizes = [], this._index = 0
        };
        wt.prototype.pushLoop = function(t) {
            this._loops.push(Math.abs(Math.floor(t))), this._indizes.push(this._index)
        }, wt.prototype.popLoop = function() {
            this._loops.pop(), this._index = this._indizes.pop(), 0 === this._loops.length && (this._index = 0)
        }, wt.prototype.numLoops = function() {
            return this._loops.length
        }, wt.prototype.numCycles = function() {
            if (0 === this._loops.length) return 0;
            let t = this._loops[0];
            for (let e = 1; e < this._loops.length; e++) t *= this._loops[e];
            return t
        }, wt.prototype.inLoop = function() {
            return this._loops.length > 0
        }, wt.prototype.increment = function() {
            this._index++
        }, wt.prototype.index = function() {
            return this._index
        };
        class Mt {
            constructor(t) {
                this.startFrame = t.getFrameNum(), this.items = {}, this.currentId = null, this.currentStart = 0, this._patch = t
            }
            getItems() {
                return this.items
            }
            clear() {
                this.paused || (this.items = {})
            }
            togglePause() {
                this.paused = !this.paused, this.paused || (this.items = {}, this.currentStart = performance.now())
            }
            add(t, e) {
                this.paused || (null !== this.currentId && (e && e.id == this.currentId || this.items[this.currentId] && (this.items[this.currentId].timeUsed += performance.now() - this.currentStart, (!this.items[this.currentId].peakTime || rt() - this.items[this.currentId].peakTime > 5e3) && (this.items[this.currentId].peak = 0, this.items[this.currentId].peakTime = rt()), this.items[this.currentId].peak = Math.max(this.items[this.currentId].peak, performance.now() - this.currentStart))), null !== e ? (this.items[e.id] || (this.items[e.id] = {
                    numTriggers: 0,
                    timeUsed: 0
                }), this.items[e.id].lastFrame != this._patch.getFrameNum() && (this.items[e.id].numTriggers = 0), this.items[e.id].lastFrame = this._patch.getFrameNum(), this.items[e.id].numTriggers++, this.items[e.id].opid = e.op.id, this.items[e.id].title = e.op.name + "." + e.name, this.items[e.id].subPatch = e.op.uiAttribs.subPatch, this.currentId = e.id, this.currentStart = performance.now()) : this.currentId = null)
            }
            print() {
                console.log("--------");
                for (const t in this.items) console.log(items[t].title + ": " + this.items[t].numTriggers + " / " + this.items[t].timeUsed)
            }
        }
        const Bt = class extends z {
                constructor(t, e, i) {
                    super(), this._name = t, this.type = i, this.setValue(e)
                }
                addListener(t) {
                    this.on("change", t, "var")
                }
                getValue() {
                    return this._v
                }
                getName() {
                    return this._name
                }
                setValue(t) {
                    this._v = t, this.emitEvent("change", t, this)
                }
            },
            Ut = function(t) {
                z.apply(this), this._log = new r("core_patch"), this.ops = [], this.settings = {}, this.config = t || {
                        glCanvasResizeToWindow: !1,
                        prefixAssetPath: "",
                        prefixJsPath: "",
                        silent: !0,
                        onError: null,
                        onFinishedLoading: null,
                        onFirstFrameRendered: null,
                        onPatchLoaded: null,
                        fpsLimit: 0
                    }, this.timer = new nt, this.freeTimer = new nt, this.animFrameOps = [], this.animFrameCallbacks = [], this.gui = !1, CABLES.logSilent = this.silent = !0, this.profiler = null, this.aborted = !1, this._crashedOps = [], this._renderOneFrame = !1, this._animReq = null, this._opIdCache = {}, this._triggerStack = [], this.storeObjNames = !1, this.loading = new Ct(this), this._volumeListeners = [], this._paused = !1, this._frameNum = 0, this.instancing = new wt, this.onOneFrameRendered = null, this.namedTriggers = {}, this._origData = null, this._frameNext = 0, this._frameInterval = 0, this._lastFrameTime = 0, this._frameWasdelayed = !0, this.frameStore = {}, this.deSerialized = !1, this._lastReqAnimTimeStamp = 0,
                    function() {
                        return !this
                    }() || console.log("not in strict mode: core patch"), this._isLocal = 0 === document.location.href.indexOf("file:"), this.config.hasOwnProperty("silent") && (this.silent = CABLES.logSilent = this.config.silent), this.config.hasOwnProperty("doRequestAnimation") || (this.config.doRequestAnimation = !0), this.config.prefixAssetPath || (this.config.prefixAssetPath = ""), this.config.prefixJsPath || (this.config.prefixJsPath = ""), this.config.masterVolume || (this.config.masterVolume = 1), this._variables = {}, this._variableListeners = [], this.vars = {}, t && t.vars && (this.vars = t.vars), this.cgl = new St(this), this.cgp = null, this.cgl.setCanvas(this.config.glCanvasId || this.config.glCanvas || "glcanvas"), !0 === this.config.glCanvasResizeToWindow && this.cgl.setAutoResize("window"), !0 === this.config.glCanvasResizeToParent && this.cgl.setAutoResize("parent"), this.loading.setOnFinishedLoading(this.config.onFinishedLoading), this.cgl.aborted && (this.aborted = !0), this.cgl.silent && (this.silent = !0), this.freeTimer.play(), this.exec(), this.aborted || (this.config.patch ? this.deSerialize(this.config.patch) : this.config.patchFile && N(this.config.patchFile, ((t, e) => {
                        const i = JSON.parse(e);
                        if (t) return this._log.error("err", t), this._log.error("data", i), void this._log.error("data", i.msg);
                        this.deSerialize(i)
                    })), this.timer.play()), console.log("made with https://cables.gl")
            };
        Ut.prototype.isPlaying = function() {
            return !this._paused
        }, Ut.prototype.isRenderingOneFrame = function() {
            return this._renderOneFrame
        }, Ut.prototype.renderOneFrame = function() {
            this._paused = !0, this._renderOneFrame = !0, this.exec(), this._renderOneFrame = !1
        }, Ut.prototype.getFPS = function() {
            return console.log("deprecated getfps"), 0
        }, Ut.prototype.isEditorMode = function() {
            return !0 === this.config.editorMode
        }, Ut.prototype.pause = function() {
            cancelAnimationFrame(this._animReq), this.emitEvent("pause"), this._animReq = null, this._paused = !0, this.freeTimer.pause()
        }, Ut.prototype.resume = function() {
            this._paused && (cancelAnimationFrame(this._animReq), this._paused = !1, this.freeTimer.play(), this.emitEvent("resume"), this.exec())
        }, Ut.prototype.setVolume = function(t) {
            this.config.masterVolume = t;
            for (let e = 0; e < this._volumeListeners.length; e++) this._volumeListeners[e].onMasterVolumeChanged(t)
        }, Ut.prototype.getAssetPath = function(t = null) {
            if (this.isEditorMode()) return "/assets/" + (t || gui.project()._id) + "/";
            if (document.location.href.indexOf("cables.gl") > 0 || document.location.href.indexOf("cables.local") > 0) {
                const e = document.location.pathname.split("/");
                return "/assets/" + (t || e[e.length - 1]) + "/"
            }
            return this.config.hasOwnProperty("assetPath") ? this.config.assetPath : "assets/"
        }, Ut.prototype.getJsPath = function() {
            return this.config.hasOwnProperty("jsPath") ? this.config.jsPath : "js/"
        }, Ut.prototype.getFilePath = function(t) {
            return t ? 0 === (t = String(t)).indexOf("https:") || 0 === t.indexOf("http:") || 0 === t.indexOf("data:") ? t : (t = t.replace("//", "/"), this.config.prefixAssetPath + t + (this.config.suffixAssetPath || "")) : t
        }, Ut.prototype.clear = function() {
            for (this.emitEvent("patchClearStart"), this.cgl.TextureEffectMesh = null, this.animFrameOps.length = 0, this.timer = new nt; this.ops.length > 0;) this.deleteOp(this.ops[0].id);
            this.emitEvent("patchClearEnd")
        }, Ut.getOpClass = function(t) {
            const e = t.split(".");
            let i = null;
            try {
                return 2 == e.length ? i = window[e[0]][e[1]] : 3 == e.length ? i = window[e[0]][e[1]][e[2]] : 4 == e.length ? i = window[e[0]][e[1]][e[2]][e[3]] : 5 == e.length ? i = window[e[0]][e[1]][e[2]][e[3]][e[4]] : 6 == e.length ? i = window[e[0]][e[1]][e[2]][e[3]][e[4]][e[5]] : 7 == e.length ? i = window[e[0]][e[1]][e[2]][e[3]][e[4]][e[5]][e[6]] : 8 == e.length ? i = window[e[0]][e[1]][e[2]][e[3]][e[4]][e[5]][e[6]][e[7]] : 9 == e.length ? i = window[e[0]][e[1]][e[2]][e[3]][e[4]][e[5]][e[6]][e[7]][e[8]] : 10 == e.length && (i = window[e[0]][e[1]][e[2]][e[3]][e[4]][e[5]][e[6]][e[7]][e[8]][e[9]]), i
            } catch (t) {
                return null
            }
        }, Ut.prototype.createOp = function(t, e, i = null) {
            let s = null,
                r = "";
            try {
                if (-1 === t.indexOf("Ops.")) {
                    const n = t;
                    if (CABLES.OPS[n]) r = CABLES.OPS[n].objName, s = new CABLES.OPS[n].f(this, r, e, n), s.opId = n;
                    else {
                        if (!i) throw new Error("could not find op by id: " + n);
                        t = i, console.log("could not find op by id: " + n)
                    }
                }
                if (!s) {
                    r = t;
                    const i = t.split(".");
                    if (!Ut.getOpClass(r)) throw this.emitEvent("criticalError", {
                        title: "unknown op",
                        text: "unknown op: " + r
                    }), this._log.error("unknown op: " + r), new Error("unknown op: " + r);
                    if (2 == i.length ? s = new window[i[0]][i[1]](this, r, e) : 3 == i.length ? s = new window[i[0]][i[1]][i[2]](this, r, e) : 4 == i.length ? s = new window[i[0]][i[1]][i[2]][i[3]](this, r, e) : 5 == i.length ? s = new window[i[0]][i[1]][i[2]][i[3]][i[4]](this, r, e) : 6 == i.length ? s = new window[i[0]][i[1]][i[2]][i[3]][i[4]][i[5]](this, r, e) : 7 == i.length ? s = new window[i[0]][i[1]][i[2]][i[3]][i[4]][i[5]][i[6]](this, r, e) : 8 == i.length ? s = new window[i[0]][i[1]][i[2]][i[3]][i[4]][i[5]][i[6]][i[7]](this, r, e) : 9 == i.length ? s = new window[i[0]][i[1]][i[2]][i[3]][i[4]][i[5]][i[6]][i[7]][i[8]](this, r, e) : 10 == i.length ? s = new window[i[0]][i[1]][i[2]][i[3]][i[4]][i[5]][i[6]][i[7]][i[8]][i[9]](this, r, e) : console.log("parts.length", i.length), s) {
                        s.opId = null;
                        for (const t in CABLES.OPS) CABLES.OPS[t].objName == r && (s.opId = t)
                    }
                }
            } catch (t) {
                if (this._crashedOps.push(r), this.emitEvent("exceptionOp", t, r, s), !this.isEditorMode()) throw this._log.error(t), this._log.error("[instancing error] " + r, t), CABLES.api && CABLES.api.sendErrorReport(t), this.exitError("INSTANCE_ERR", "Instancing Error 1" + r, t), new Error("instancing error 1" + r)
            }
            return s ? (s._objName = r, s.patch = this) : this._log.log("no op was created!?", t, e), s
        }, Ut.prototype.addOp = function(t, e, i, s, r) {
            const n = this.createOp(t, i, r);
            if (n) {
                if ((e = e || {}).hasOwnProperty("errors") && delete e.errors, e.hasOwnProperty("error") && delete e.error, e.subPatch = e.subPatch || 0, n.uiAttr(e), n.onCreate && n.onCreate(), n.hasOwnProperty("onAnimFrame") && this.addOnAnimFrame(n), n.hasOwnProperty("onMasterVolumeChanged") && this._volumeListeners.push(n), this._opIdCache[n.id]) return void console.log("opid with id " + n.id + " already exists in patch!");
                this.ops.push(n), this._opIdCache[n.id] = n, this.emitEvent("onOpAdd", n, s), n.init && n.init(), n.emitEvent("init", s)
            } else this._log.error("addop: no op.....");
            return n
        }, Ut.prototype.addOnAnimFrame = function(t) {
            for (let e = 0; e < this.animFrameOps.length; e++)
                if (this.animFrameOps[e] == t) return;
            this.animFrameOps.push(t)
        }, Ut.prototype.removeOnAnimFrame = function(t) {
            for (let e = 0; e < this.animFrameOps.length; e++)
                if (this.animFrameOps[e] == t) return void this.animFrameOps.splice(e, 1)
        }, Ut.prototype.addOnAnimFrameCallback = function(t) {
            this.animFrameCallbacks.push(t)
        }, Ut.prototype.removeOnAnimCallback = function(t) {
            for (let e = 0; e < this.animFrameCallbacks.length; e++)
                if (this.animFrameCallbacks[e] == t) return void this.animFrameCallbacks.splice(e, 1)
        }, Ut.prototype.deleteOp = function(t, e, i) {
            let s = !1;
            for (const r in this.ops)
                if (this.ops[r].id == t) {
                    const n = this.ops[r];
                    let o = null,
                        a = null;
                    if (n) {
                        s = !0, e && n.portsIn.length > 0 && n.portsIn[0].isLinked() && n.portsOut.length > 0 && n.portsOut[0].isLinked() && n.portsIn[0].getType() == n.portsOut[0].getType() && n.portsIn[0].links[0] && (o = n.portsIn[0].links[0].getOtherPort(n.portsIn[0]), a = n.portsOut[0].links[0].getOtherPort(n.portsOut[0]));
                        const h = this.ops[r];
                        h.removeLinks(), this.onDelete && (console.log("deprecated this.onDelete", this.onDelete), this.onDelete(h)), this.ops.splice(r, 1), h.emitEvent("delete", this.ops[r]), this.emitEvent("onOpDelete", h, i), h.onDelete && h.onDelete(i), h.cleanUp(), null !== o && null !== a && this.link(o.op, o.getName(), a.op, a.getName()), delete this._opIdCache[t];
                        break
                    }
                } s || console.log("core patch deleteop: not found...", t)
        }, Ut.prototype.getFrameNum = function() {
            return this._frameNum
        }, Ut.prototype.emitOnAnimFrameEvent = function(t, e) {
            t = t || this.timer.getTime();
            for (let i = 0; i < this.animFrameCallbacks.length; ++i) this.animFrameCallbacks[i] && this.animFrameCallbacks[i](t, this._frameNum, e);
            for (let i = 0; i < this.animFrameOps.length; ++i) this.animFrameOps[i].onAnimFrame && this.animFrameOps[i].onAnimFrame(t, this._frameNum, e)
        }, Ut.prototype.renderFrame = function(t) {
            this.timer.update(), this.freeTimer.update();
            const e = this.timer.getTime(),
                i = performance.now(),
                s = t - this._lastReqAnimTimeStamp || t;
            this.emitOnAnimFrameEvent(null, s), this.cgl.profileData.profileFrameDelta = s, this._lastReqAnimTimeStamp = t, this.cgl.profileData.profileOnAnimFrameOps = performance.now() - i, this.emitEvent("onRenderFrame", e), this._frameNum++, 1 == this._frameNum && this.config.onFirstFrameRendered && this.config.onFirstFrameRendered()
        }, Ut.prototype.exec = function(t) {
            if (!this._renderOneFrame && (this._paused || this.aborted)) return;
            this.emitEvent("reqAnimFrame"), this.config.fpsLimit = this.config.fpsLimit || 0, this.config.fpsLimit && (this._frameInterval = 1e3 / this.config.fpsLimit);
            const e = CABLES.now(),
                i = e - this._frameNext;
            if (this.isEditorMode() && !this._renderOneFrame && e - this._lastFrameTime >= 500 && 0 !== this._lastFrameTime && !this._frameWasdelayed) return this._lastFrameTime = 0, setTimeout(this.exec.bind(this), 500), this.emitEvent("renderDelayStart"), void(this._frameWasdelayed = !0);
            (this._renderOneFrame || 0 === this.config.fpsLimit || i > this._frameInterval || this._frameWasdelayed) && (this.renderFrame(t), this._frameInterval && (this._frameNext = e - i % this._frameInterval)), this._frameWasdelayed && (this.emitEvent("renderDelayEnd"), this._frameWasdelayed = !1), this._renderOneFrame && (this.onOneFrameRendered && this.onOneFrameRendered(), this.emitEvent("renderedOneFrame"), this._renderOneFrame = !1), this.config.doRequestAnimation && (this._animReq = requestAnimationFrame(this.exec.bind(this)))
        }, Ut.prototype.link = function(t, e, i, s, r, n) {
            if (!t) return void console.log("link: op1 is null ");
            if (!i) return void console.log("link: op2 is null");
            const o = t.getPort(e, r),
                a = i.getPort(s, r);
            if (o)
                if (a) {
                    if (!o.shouldLink(o, a) || !a.shouldLink(o, a)) return !1;
                    if (Pt.canLink(o, a)) {
                        const t = new Pt(this);
                        return t.link(o, a), this.emitEvent("onLink", o, a, t, n), t
                    }
                } else console.log("port not found! " + s + " of " + i.name + "(" + i.objName + ")");
            else console.log("port not found! " + e + "(" + t.objName + ")")
        }, Ut.prototype.serialize = function(t) {
            const e = {};
            t = t || {}, e.ops = [], e.settings = this.settings;
            for (const t in this.ops) {
                const i = this.ops[t];
                e.ops.push(i.getSerialized())
            }
            return t.asObject ? e : JSON.stringify(e)
        }, Ut.prototype.getOpById = function(t) {
            return this._opIdCache[t]
        }, Ut.prototype.getOpsByName = function(t) {
            const e = [];
            for (const i in this.ops) this.ops[i].name == t && e.push(this.ops[i]);
            return e
        }, Ut.prototype.getOpsByObjName = function(t) {
            const e = [];
            for (const i in this.ops) this.ops[i].objName == t && e.push(this.ops[i]);
            return e
        }, Ut.prototype.loadLib = function(t) {
            F("/ui/libs/" + t + ".js", ((t, e) => {
                const i = document.createElement("script");
                i.type = "text/javascript", i.text = e, document.getElementsByTagName("head")[0].appendChild(i)
            }), "GET")
        }, Ut.prototype.reloadOp = function(t, e) {
            let i = 0;
            const s = [],
                r = [];
            for (const e in this.ops) this.ops[e].objName == t && r.push(this.ops[e]);
            for (let e = 0; e < r.length; e++) {
                i++;
                const n = r[e];
                n.deleted = !0;
                const o = this.addOp(t, n.uiAttribs);
                if (!o) continue;
                let a;
                n && n.storage && o.setStorage(JSON.parse(JSON.stringify(n.storage))), s.push(o);
                for (let t in n.portsIn)
                    if (0 === n.portsIn[t].links.length) {
                        const e = o.getPort(n.portsIn[t].name);
                        e ? (e.set(n.portsIn[t].get()), n.portsIn[t].getVariableName() && e.setVariable(n.portsIn[t].getVariableName())) : this._log.error("[reloadOp] could not set port " + n.portsIn[t].name + ", propably renamed port ?")
                    } else
                        for (; n.portsIn[t].links.length;) {
                            const e = n.portsIn[t].links[0].portIn.name,
                                i = n.portsIn[t].links[0].portOut.name,
                                s = n.portsIn[t].links[0].portOut.op;
                            n.portsIn[t].links[0].remove(), a = this.link(o, e, s, i), a ? a.setValue() : console.log("[reloadOp] relink after op reload not successfull for port " + i)
                        }
                for (let t in n.portsOut)
                    for (; n.portsOut[t].links.length;) {
                        const e = n.portsOut[t].links[0].portOut.name,
                            i = n.portsOut[t].links[0].portIn.name,
                            s = n.portsOut[t].links[0].portIn.op;
                        n.portsOut[t].links[0].remove(), a = this.link(o, e, s, i), a ? a.setValue() : console.log("relink after op reload not successfull for port " + i)
                    }
                this.deleteOp(n.id, !1, !0)
            }
            e(i, s)
        }, Ut.prototype.getSubPatchOps = function(t, e = !1) {
            let i = [];
            for (const e in this.ops) this.ops[e].uiAttribs && this.ops[e].uiAttribs.subPatch == t && i.push(this.ops[e]);
            if (e)
                for (const t in i)
                    if (i[t].storage && i[t].storage.subPatchVer) {
                        const e = i[t].portsIn.find((t => "patchId" === t.name));
                        e && (i = i.concat(this.getSubPatchOps(e.value, !0)))
                    } return i
        }, Ut.prototype.getSubPatchOp = function(t, e) {
            for (const i in this.ops)
                if (this.ops[i].uiAttribs && this.ops[i].uiAttribs.subPatch == t && this.ops[i].objName == e) return this.ops[i];
            return !1
        }, Ut.prototype.getSubPatchOuterOp = function(t) {
            const e = this.ops;
            for (let i = 0; i < e.length; i++) {
                const s = e[i];
                if (s.isSubPatchOp() && s.patchId.get() == t) return s
            }
        }, Ut.prototype._addLink = function(t, e, i, s) {
            this.link(this.getOpById(t), i, this.getOpById(e), s, !1, !0)
        }, Ut.prototype.deSerialize = function(t, e) {
            if (e = e || {
                    genIds: !1,
                    createRef: !1
                }, this.aborted) return;
            const i = [],
                s = this.loading.start("core", "deserialize");
            this.namespace = t.namespace || "", this.name = t.name || "", "string" == typeof t && (t = JSON.parse(t)), this.settings = t.settings, this.emitEvent("patchLoadStart"), window.logStartup && logStartup("add " + t.ops.length + " ops... ");
            for (let s = 0; s < t.ops.length; s++) {
                const r = CABLES.now(),
                    n = t.ops[s];
                let a = null;
                try {
                    a = n.opId ? this.addOp(n.opId, n.uiAttribs, n.id, !0, n.objName) : this.addOp(n.objName, n.uiAttribs, n.id, !0)
                } catch (t) {
                    throw console.log("[instancing error] op data:", n, t), new Error("could not create op by id: <b>" + (n.objName || n.opId) + "</b> (" + n.id + ")")
                }
                if (a) {
                    e.genIds && (a.id = f()), a.portsInData = n.portsIn, a._origData = n, a.storage = n.storage;
                    for (const t in n.portsIn) {
                        const e = n.portsIn[t],
                            i = a.getPort(e.name);
                        !i || "bool" != i.uiAttribs.display && "bool" != i.uiAttribs.type || isNaN(e.value) || (e.value = !0 === e.value), i && void 0 !== e.value && i.type != o.OP_PORT_TYPE_TEXTURE && i.set(e.value), i && i.deSerializeSettings(e)
                    }
                    for (const e in n.portsOut) {
                        const i = a.getPort(n.portsOut[e].name);
                        i && i.type != o.OP_PORT_TYPE_TEXTURE && n.portsOut[e].hasOwnProperty("value") && i.set(t.ops[s].portsOut[e].value), i && n.portsOut[e].expose && i.setUiAttribs({
                            expose: !0
                        })
                    }
                    i.push(a)
                }
                const h = Math.round(100 * (CABLES.now() - r)) / 100;
                !this.silent && h > 5 && console.log("long op init ", t.ops[s].objName, h)
            }
            window.logStartup && logStartup("add ops done");
            for (const t in this.ops) this.ops[t].onLoadedValueSet && (this.ops[t].onLoadedValueSet(this.ops[t]._origData), this.ops[t].onLoadedValueSet = null, this.ops[t]._origData = null), this.ops[t].emitEvent("loadedValueSet");
            if (window.logStartup && logStartup("creating links"), t.ops)
                for (let e = 0; e < t.ops.length; e++) {
                    if (t.ops[e].portsIn)
                        for (let i = 0; i < t.ops[e].portsIn.length; i++)
                            if (t.ops[e].portsIn[i].links)
                                for (let s = 0; s < t.ops[e].portsIn[i].links.length; s++) this._addLink(t.ops[e].portsIn[i].links[s].objIn, t.ops[e].portsIn[i].links[s].objOut, t.ops[e].portsIn[i].links[s].portIn, t.ops[e].portsIn[i].links[s].portOut);
                    if (t.ops[e].portsOut)
                        for (let i = 0; i < t.ops[e].portsOut.length; i++)
                            if (t.ops[e].portsOut[i].links)
                                for (let s = 0; s < t.ops[e].portsOut[i].links.length; s++)
                                    if (t.ops[e].portsOut[i].links[s])
                                        if (t.ops[e].portsOut[i].links[s].subOpRef) {
                                            const r = this.getOpById(t.ops[e].portsOut[i].links[s].objOut);
                                            let n = null,
                                                o = 0;
                                            for (let n = 0; n < this.ops.length; n++)
                                                if (this.ops[n].storage && this.ops[n].storage.ref == t.ops[e].portsOut[i].links[s].subOpRef && r.uiAttribs.subPatch == this.ops[n].uiAttribs.subPatch) {
                                                    o = this.ops[n].patchId.get();
                                                    break
                                                } for (let r = 0; r < this.ops.length; r++)
                                                if (this.ops[r].storage && this.ops[r].storage.ref == t.ops[e].portsOut[i].links[s].refOp && this.ops[r].uiAttribs.subPatch == o) {
                                                    n = this.ops[r];
                                                    break
                                                } n ? this._addLink(n.id, t.ops[e].portsOut[i].links[s].objOut, t.ops[e].portsOut[i].links[s].portIn, t.ops[e].portsOut[i].links[s].portOut) : this._log.warn("could not find op for lost link")
                                        } else this._addLink(t.ops[e].portsOut[i].links[s].objIn, t.ops[e].portsOut[i].links[s].objOut, t.ops[e].portsOut[i].links[s].portIn, t.ops[e].portsOut[i].links[s].portOut)
                }
            window.logStartup && logStartup("calling ops onloaded");
            for (const t in this.ops) this.ops[t].onLoaded && (this.ops[t].onLoaded(), this.ops[t].onLoaded = null);
            window.logStartup && logStartup("initializing ops...");
            for (const t in this.ops) this.ops[t].init && (this.ops[t].init(), this.ops[t].init = null);
            if (window.logStartup && logStartup("initializing vars..."), this.config.variables)
                for (const t in this.config.variables) this.setVarValue(t, this.config.variables[t]);
            window.logStartup && logStartup("initializing var ports");
            for (const t in this.ops) this.ops[t].initVarPorts(), delete this.ops[t].uiAttribs.pasted;
            setTimeout((() => {
                this.loading.finished(s)
            }), 100), window.logStartup && logStartup("calling onPatchLoaded/patchLoadEnd"), this.config.onPatchLoaded && this.config.onPatchLoaded(this), this.deSerialized = !0, this.emitEvent("patchLoadEnd", i, t, e.genIds)
        }, Ut.prototype.profile = function(t) {
            this.profiler = new Mt(this);
            for (const e in this.ops) this.ops[e].profile(t)
        }, Ut.prototype.setVariable = function(t, e) {
            void 0 !== this._variables[t] ? this._variables[t].setValue(e) : console.log("variable " + t + " not found!")
        }, Ut.prototype._sortVars = function() {
            if (!this.isEditorMode()) return;
            const t = {};
            Object.keys(this._variables).sort(((t, e) => t.localeCompare(e, "en", {
                sensitivity: "base"
            }))).forEach((e => {
                t[e] = this._variables[e]
            })), this._variables = t
        }, Ut.prototype.hasVar = function(t) {
            return void 0 !== this._variables[t]
        }, Ut.prototype.setVarValue = function(t, e, i) {
            return this.hasVar(t) ? this._variables[t].setValue(e) : (this._variables[t] = new Bt(t, e, i), this._sortVars(), this.emitEvent("variablesChanged")), this._variables[t]
        }, Ut.prototype.getVarValue = function(t, e) {
            if (this._variables.hasOwnProperty(t)) return this._variables[t].getValue()
        }, Ut.prototype.getVar = function(t) {
            if (this._variables.hasOwnProperty(t)) return this._variables[t]
        }, Ut.prototype.deleteVar = function(t) {
            for (let e = 0; e < this.ops.length; e++)
                for (let i = 0; i < this.ops[e].portsIn.length; i++) this.ops[e].portsIn[i].getVariableName() == t && this.ops[e].portsIn[i].setVariable(null);
            delete this._variables[t], this.emitEvent("variableDeleted", t), this.emitEvent("variablesChanged")
        }, Ut.prototype.getVars = function(t) {
            if (void 0 === t) return this._variables;
            const e = [];
            t == CABLES.OP_PORT_TYPE_STRING && (t = "string"), t == CABLES.OP_PORT_TYPE_VALUE && (t = "number"), t == CABLES.OP_PORT_TYPE_ARRAY && (t = "array"), t == CABLES.OP_PORT_TYPE_OBJECT && (t = "object");
            for (const i in this._variables) this._variables[i].type && this._variables[i].type != t || e.push(this._variables[i]);
            return e
        }, Ut.prototype.exitError = function(t, e, i) {
            if (this.aborted = !0, this && this.config && this.config.onError) this.config.onError(t, e);
            else if (!this.isEditorMode()) {
                const s = document.createElement("div"),
                    r = this.cgl.canvas.getBoundingClientRect();
                s.setAttribute("style", "position:absolute;border:5px solid red;padding:15px;background-color:black;color:white;font-family:monospace;"), s.style.top = r.top + "px", s.style.left = r.left + "px";
                let n = "cables - An error occured:<br/>";
                n += "[" + t + "] - " + e, i && (n += "<br/>Exception: " + i.message), s.innerHTML = n;
                const o = this.cgl.canvas.parentElement;
                for (; o.hasChildNodes();) o.removeChild(o.lastChild);
                document.body.appendChild(s)
            }
        }, Ut.prototype.preRenderOps = function() {
            this._log.log("prerendering...");
            for (let t = 0; t < this.ops.length; t++) this.ops[t].preRender && (this.ops[t].preRender(), this._log.log("prerender " + this.ops[t].objName))
        }, Ut.prototype.dispose = function() {
            this.pause(), this.clear()
        }, Ut.prototype.pushTriggerStack = function(t) {
            this._triggerStack.push(t)
        }, Ut.prototype.popTriggerStack = function() {
            this._triggerStack.pop()
        }, Ut.prototype.printTriggerStack = function() {
            if (0 == this._triggerStack.length) return void console.log("stack length", this._triggerStack.length);
            console.groupCollapsed("trigger port stack " + this._triggerStack[this._triggerStack.length - 1].op.name + "." + this._triggerStack[this._triggerStack.length - 1].name);
            const t = [];
            for (let e = 0; e < this._triggerStack.length; e++) t.push(e + ". " + this._triggerStack[e].op.name + " " + this._triggerStack[e].name);
            console.table(t), console.groupEnd()
        }, Ut.replaceOpIds = function(t, e) {
            const i = {};
            for (const e in t.ops) i[t.ops[e].id] = t.ops[e];
            for (const s in t.ops)
                for (const r in t.ops[s].portsOut) {
                    const n = t.ops[s].portsOut[r].links;
                    if (n) {
                        let t = n.length;
                        for (; t--;)
                            if (n[t] && (!i[n[t].objIn] || !i[n[t].objOut]))
                                if (e.doNotUnlinkLostLinks) {
                                    if (e.fixLostLinks) {
                                        const e = gui.corePatch().getOpById(n[t].objIn);
                                        if (e) {
                                            const i = gui.patchView.getSubPatchOuterOp(e.uiAttribs.subPatch);
                                            i && (e.storage = e.storage || {}, e.storage.ref = e.storage.ref || CABLES.shortId(), n[t].refOp = e.storage.ref, n[t].subOpRef = i.storage.ref)
                                        } else console.log("op not found!")
                                    }
                                } else n.splice(t, 1)
                    }
                }
            for (const i in t.ops) {
                const s = t.ops[i],
                    r = s.id;
                let n = CABLES.shortId();
                e.prefixHash ? n = E(e.prefixHash + r) : e.prefixId ? n = e.prefixId + r : e.refAsId && (s.storage && s.storage.ref ? (n = s.storage.ref, delete s.storage.ref) : (s.storage = s.storage || {}, s.storage.ref = n = CABLES.shortId()));
                const o = s.id = n;
                e.oldIdAsRef && (s.storage = s.storage || {}, s.storage.ref = r);
                for (const e in t.ops) {
                    if (t.ops[e].portsIn)
                        for (const i in t.ops[e].portsIn)
                            if (t.ops[e].portsIn[i].links) {
                                let s = t.ops[e].portsIn[i].links.length;
                                for (; s--;) null === t.ops[e].portsIn[i].links[s] && t.ops[e].portsIn[i].links.splice(s, 1);
                                for (s in t.ops[e].portsIn[i].links) t.ops[e].portsIn[i].links[s].objIn === r && (t.ops[e].portsIn[i].links[s].objIn = o), t.ops[e].portsIn[i].links[s].objOut === r && (t.ops[e].portsIn[i].links[s].objOut = o)
                            } if (t.ops[e].portsOut)
                        for (const i in t.ops[e].portsOut)
                            if (t.ops[e].portsOut[i].links) {
                                let s = t.ops[e].portsOut[i].links.length;
                                for (; s--;) null === t.ops[e].portsOut[i].links[s] && t.ops[e].portsOut[i].links.splice(s, 1);
                                for (s in t.ops[e].portsOut[i].links) t.ops[e].portsOut[i].links[s].objIn === r && (t.ops[e].portsOut[i].links[s].objIn = o), t.ops[e].portsOut[i].links[s].objOut === r && (t.ops[e].portsOut[i].links[s].objOut = o)
                            }
                }
            }
            const s = [],
                r = [];
            for (let i = 0; i < t.ops.length; i++)
                if (t.ops[i].storage && t.ops[i].storage.subPatchVer)
                    for (const n in t.ops[i].portsIn)
                        if ("patchId" === t.ops[i].portsIn[n].name) {
                            let o = f();
                            e.prefixHash && (o = E(e.prefixHash + t.ops[i].portsIn[n].value));
                            const a = t.ops[i].portsIn[n].value,
                                h = t.ops[i].portsIn[n].value = o;
                            s.push(h);
                            for (let e = 0; e < t.ops.length; e++) t.ops[e].uiAttribs && t.ops[e].uiAttribs.subPatch === a && (t.ops[e].uiAttribs.subPatch = h, r.push(t.ops[e].id))
                        } for (const i in t.ops) {
                let s = !1;
                for (let e = 0; e < r.length; e++)
                    if (t.ops[i].id === r[e]) {
                        s = !0;
                        break
                    }! s && t.ops[i].uiAttribs && null != e.parentSubPatchId && (t.ops[i].uiAttribs.subPatch = e.parentSubPatchId)
            }
            return t
        };
        const Lt = Ut,
            kt = {
                addPatch: function(t, e) {
                    let i = t,
                        s = m();
                    if ("string" == typeof t && (s = t, i = document.getElementById(s), !i)) return void console.error(s + " Polyshape Container Element not found!");
                    const r = document.createElement("canvas");
                    return r.id = "glcanvas_" + s, r.width = i.clientWidth, r.height = i.clientHeight, window.addEventListener("resize", function() {
                        this.setAttribute("width", i.clientWidth), this.height = i.clientHeight
                    }.bind(r)), i.appendChild(r), (e = e || {}).glCanvasId = r.id, e.onError || (e.onError = function(t) {
                        console.error(t)
                    }), CABLES.patch = new Lt(e), r
                }
            },
            Dt = {
                toneJsInitialized: !1,
                createAudioContext: function(t) {
                    if (window.AudioContext = window.AudioContext || window.webkitAudioContext, window.AudioContext) return window.audioContext || (window.audioContext = new AudioContext), window.Tone && !Dt.toneJsInitialized && (Tone.setContext(window.audioContext), Dt.toneJsInitialized = !0), window.audioContext;
                    t.patch.config.onError("NO_WEBAUDIO", "Web Audio is not supported in this browser.")
                },
                getAudioContext: function() {
                    return window.audioContext
                },
                createAudioInPort: function(t, e, i, s) {
                    if (!t || !e || !i) {
                        const e = "ERROR: createAudioInPort needs three parameters, op, portName and audioNode";
                        throw t.log(e), new Error(e)
                    }
                    s || (s = 0), t.webAudio = t.webAudio || {}, t.webAudio.audioInPorts = t.webAudio.audioInPorts || [];
                    const r = t.inObject(e);
                    return r.webAudio = {}, r.webAudio.previousAudioInNode = null, r.webAudio.audioNode = i, t.webAudio.audioInPorts[e] = r, r.onChange = function() {
                        const e = r.get();
                        if (e) try {
                            e.connect ? (e.connect(r.webAudio.audioNode, 0, s), t.setUiError("audioCtx", null)) : t.setUiError("audioCtx", "The passed input is not an audio context. Please make sure you connect an audio context to the input.", 2)
                        } catch (i) {
                            throw t.log("Error: Failed to connect web audio node!", i), t.log("port.webAudio.audioNode", r.webAudio.audioNode), t.log("audioInNode: ", e), t.log("inputChannelIndex:", s), t.log("audioInNode.connect: ", e.connect), i
                        } else if (r.webAudio.previousAudioInNode) try {
                            r.webAudio.previousAudioInNode.disconnect && r.webAudio.previousAudioInNode.disconnect(r.webAudio.audioNode, 0, s), t.setUiError("audioCtx", null)
                        } catch (e) {
                            try {
                                r.webAudio.previousAudioInNode.disconnect(r.webAudio.audioNode)
                            } catch (i) {
                                throw t.log("Disconnecting audio node with in/out port index, as well as without in/out-port-index did not work ", e), e.printStackTrace && e.printStackTrace(), e
                            }
                        }
                        r.webAudio.previousAudioInNode = e
                    }, r
                },
                replaceNodeInPort: function(t, e, i) {
                    const s = t.webAudio.previousAudioInNode;
                    if (s && s.disconnect) {
                        try {
                            s.disconnect(e)
                        } catch (t) {
                            throw t.printStackTrace && t.printStackTrace(), new Error("replaceNodeInPort: Could not disconnect old audio node. " + t.name + " " + t.message)
                        }
                        t.webAudio.audioNode = i;
                        try {
                            s.connect(i)
                        } catch (t) {
                            throw t.printStackTrace && t.printStackTrace(), new Error("replaceNodeInPort: Could not connect to new node. " + t.name + " " + t.message)
                        }
                    }
                },
                createAudioOutPort: function(t, e, i) {
                    if (!t || !e || !i) {
                        const e = "ERROR: createAudioOutPort needs three parameters, op, portName and audioNode";
                        throw t.log(e), new Error(e)
                    }
                    const s = t.outObject(e);
                    return s.set(i), s
                },
                createAudioParamInPort: function(t, e, i, s, r) {
                    if (!t || !e || !i) return t.log("ERROR: createAudioParamInPort needs three parameters, op, portName and audioNode"), t && t.name && t.log("opname: ", t.name), t.log("portName", e), void t.log("audioNode: ", i);
                    t.webAudio = t.webAudio || {}, t.webAudio.audioInPorts = t.webAudio.audioInPorts || [];
                    const n = t.inDynamic(e, [o.OP_PORT_TYPE_VALUE, o.OP_PORT_TYPE_OBJECT], s, r);
                    return n.webAudio = {}, n.webAudio.previousAudioInNode = null, n.webAudio.audioNode = i, t.webAudio.audioInPorts[e] = n, n.onChange = function() {
                        const e = n.get(),
                            i = n.webAudio.audioNode,
                            s = Dt.getAudioContext();
                        if (null != e)
                            if ("object" == typeof e && e.connect) {
                                try {
                                    e.connect(i)
                                } catch (e) {
                                    throw t.log("Could not connect audio node: ", e), e.printStackTrace && e.printStackTrace(), e
                                }
                                n.webAudio.previousAudioInNode = e
                            } else {
                                if (i._param && i._param.minValue && i._param.maxValue)
                                    if (e >= i._param.minValue && e <= i._param.maxValue) try {
                                        i.setValueAtTime ? i.setValueAtTime(e, s.currentTime) : i.value = e
                                    } catch (e) {
                                        throw t.log("Possible AudioParam problem with tone.js op: ", e), e.printStackTrace && e.printStackTrace(), e
                                    } else t.log("Warning: The value for an audio parameter is out of range!");
                                    else if (i.minValue && i.maxValue)
                                    if (e >= i.minValue && e <= i.maxValue) try {
                                        i.setValueAtTime ? i.setValueAtTime(e, s.currentTime) : i.value = e
                                    } catch (e) {
                                        throw t.log("AudioParam has minValue / maxValue defined, and value is in range, but setting the value failed! ", e), e.printStackTrace && e.printStackTrace(), e
                                    } else t.log("Warning: The value for an audio parameter is out of range!");
                                    else try {
                                        i.setValueAtTime ? i.setValueAtTime(e, s.currentTime) : i.value = e
                                    } catch (e) {
                                        throw t.log("Possible AudioParam problem (without minValue / maxValue): ", e), e.printStackTrace && e.printStackTrace(), e
                                    }
                                if (n.webAudio.previousAudioInNode && n.webAudio.previousAudioInNode.disconnect) {
                                    try {
                                        n.webAudio.previousAudioInNode.disconnect(i)
                                    } catch (e) {
                                        throw t.log("Could not disconnect previous audio node: ", e), e
                                    }
                                    n.webAudio.previousAudioInNode = void 0
                                }
                            }
                        else n.webAudio.previousAudioInNode
                    }, n
                },
                loadAudioFile: function(t, e, i, s, r) {
                    const n = Dt.createAudioContext();
                    let o = null;
                    (r || void 0 === r) && (o = t.loading.start("audio", e), t.isEditorMode() && gui.jobs().start({
                        id: "loadaudio" + o,
                        title: " loading audio (" + e + ")"
                    }));
                    const a = new XMLHttpRequest;
                    e && (a.open("GET", e, !0), a.responseType = "arraybuffer", a.onload = function() {
                        t.loading.finished(o), t.isEditorMode() && gui.jobs().finish("loadaudio" + o), n.decodeAudioData(a.response, i, s)
                    }, a.send())
                },
                isValidToneTime: function(t) {
                    try {
                        new Tone.Time(t)
                    } catch (t) {
                        return !1
                    }
                    return !0
                },
                isValidToneNote: function(t) {
                    try {
                        Tone.Frequency(t)
                    } catch (t) {
                        return !1
                    }
                    return !0
                }
            },
            Vt = function(t, e, i) {
                this._patch = t, this.connector = i, this._log = new r("PatchConnectionReceiver")
            };
        Vt.prototype._addOp = function(t) {
            let e = null;
            t.vars.uiAttribs && (e = t.vars.uiAttribs);
            const i = this._patch.addOp(t.vars.objName, e, t.vars.opId, !0);
            i && (i.id = t.vars.opId, t.vars.portsIn && t.vars.portsIn.forEach((t => {
                const e = i.getPortByName(t.name);
                e && e.set(t.value)
            })))
        }, Vt.prototype._receive = function(t) {
            let e = {};
            if (e = t.hasOwnProperty("event") ? t : JSON.parse(t.data), e.event == h.PACO_OP_CREATE) {
                if (this._patch.getOpById(e.vars.opId)) return;
                this._log.verbose("op create:", e.vars.objName), window.gui ? gui.serverOps.loadOpLibs(e.vars.objName, (() => {
                    this._addOp(e)
                })) : this._addOp(e)
            } else if (e.event == h.PACO_DESERIALIZE) e.vars.json && (window.gui ? gui.serverOps.loadProjectDependencies(e.vars.json, (() => {
                this._patch.deSerialize(e.vars.json, {
                    genIds: e.vars.genIds
                })
            })) : this._patch.deSerialize(e.vars.json, {
                genIds: e.vars.genIds
            }));
            else if (e.event == h.PACO_LOAD) this._log.verbose("PACO load patch....."), this._patch.clear(), window.gui ? gui.serverOps.loadProjectDependencies(JSON.parse(e.vars.patch), (() => {
                this._patch.deSerialize(e.vars.patch)
            })) : this._patch.deSerialize(e.vars.patch);
            else if (e.event == h.PACO_CLEAR) this._patch.clear(), this._log.log("clear");
            else if (e.event == h.PACO_OP_DELETE) this._log.verbose("op delete", e.vars.objName), this._patch.getOpById(e.vars.op), this._patch.deleteOp(e.vars.op, !0);
            else if (e.event == h.PACO_OP_ENABLE) {
                const t = this._patch.getOpById(e.vars.op);
                t && (t.enabled = !0)
            } else if (e.event == h.PACO_OP_DISABLE) {
                const t = this._patch.getOpById(e.vars.op);
                t && (t.enabled = !1)
            } else if (e.event == h.PACO_UIATTRIBS) {
                const t = this._patch.getOpById(e.vars.op);
                t?.setUiAttrib(e.vars.uiAttribs)
            } else if (e.event == h.PACO_UNLINK) {
                const t = this._patch.getOpById(e.vars.op1),
                    i = this._patch.getOpById(e.vars.op2),
                    s = t?.getPort(e.vars.port1),
                    r = i?.getPort(e.vars.port2);
                s && r ? s.removeLinkTo(r) : this._log.warn("paco unlink could not find port...")
            } else if (e.event == h.PACO_LINK) {
                const t = this._patch.getOpById(e.vars.op1),
                    i = this._patch.getOpById(e.vars.op2);
                t && i && this._patch.link(t, e.vars.port1, i, e.vars.port2)
            } else if (e.event == h.PACO_VALUECHANGE) {
                if ("+ create new one" === e.vars.v) return;
                const t = this._patch.getOpById(e.vars.op);
                if (t) {
                    const i = t.getPort(e.vars.port);
                    i && i.set(e.vars.v)
                }
            } else if (e.event == h.PACO_VARIABLES) {
                const t = this._patch.getOpById(e.vars.opId);
                t && t.varName && t.varName.set(e.vars.varName)
            } else if (e.event == h.PACO_TRIGGERS) {
                const t = this._patch.getOpById(e.vars.opId);
                t && t.varName && t.varName.set(e.vars.varName)
            } else if (e.event == h.PACO_PORT_SETVARIABLE) {
                const t = this._patch.getOpById(e.vars.opId);
                if (t) {
                    const i = t.getPortByName(e.vars.portName);
                    i && i.setVariable(e.vars.variableName)
                }
            } else if (e.event == h.PACO_PORT_SETANIMATED) {
                const t = this._patch.getOpById(e.vars.opId);
                t && t.portsIn[e.vars.portIndex] && e.vars.hasOwnProperty("targetState") && this._patch.emitEvent("pacoPortValueSetAnimated", t, e.vars.portIndex, e.vars.targetState, e.vars.defaultValue)
            } else if (e.event == h.PACO_PORT_ANIM_UPDATED) {
                const t = this._patch.getOpById(e.vars.opId);
                if (t) {
                    const i = t.getPortByName(e.vars.portName);
                    if (i) {
                        const t = i.getSerialized();
                        t.anim = e.vars.anim, i.anim = null, i.deSerializeSettings(t), this._patch.emitEvent("pacoPortAnimUpdated", i)
                    }
                }
            } else this._log.warn("unknown patchConnectionEvent!", t)
        };
        const Gt = function(t) {
            this.connectors = [], this.paused = !1, t.addEventListener("onOpDelete", (t => {
                this.send(CABLES.PACO_OP_DELETE, {
                    op: t.id,
                    objName: t.objName
                })
            })), t.addEventListener("patchClearStart", (() => {
                this.paused = !0
            })), t.addEventListener("patchClearEnd", (() => {
                this.paused = !1
            })), t.addEventListener("patchLoadStart", (() => {
                this.paused = !0
            })), t.addEventListener("patchLoadEnd", ((t, e, i) => {
                this.paused = !1, this.send(CABLES.PACO_DESERIALIZE, {
                    json: e,
                    genIds: i
                })
            })), t.addEventListener("onOpAdd", (t => {
                const e = [];
                t.portsIn.forEach((t => {
                    const i = {
                        id: t.id,
                        name: t.name,
                        value: t.get()
                    };
                    e.push(i)
                }));
                let i = {};
                t.uiAttribs && (i = {
                    ...t.uiAttribs
                }), this.send(CABLES.PACO_OP_CREATE, {
                    opId: t.id,
                    objName: t.objName,
                    uiAttribs: i,
                    portsIn: e
                })
            })), t.addEventListener("onUnLink", ((t, e) => {
                this.send(CABLES.PACO_UNLINK, {
                    op1: t.op.id,
                    op2: e.op.id,
                    port1: t.getName(),
                    port2: e.getName()
                })
            })), t.addEventListener("onUiAttribsChange", ((t, e) => {
                e && (delete e.extendTitle, delete e.history, delete e.translate, Object.keys(e).length > 0 && this.send(CABLES.PACO_UIATTRIBS, {
                    op: t.id,
                    uiAttribs: e
                }))
            })), t.addEventListener("opVariableNameChanged", ((t, e) => {
                const i = {
                    opId: t.id,
                    varName: e
                };
                this.send(CABLES.PACO_VARIABLES, i)
            })), t.addEventListener("opTriggerNameChanged", ((t, e) => {
                const i = {
                    opId: t.id,
                    varName: e
                };
                this.send(CABLES.PACO_TRIGGERS, i)
            })), t.addEventListener("onLink", ((t, e) => {
                this.send(CABLES.PACO_LINK, {
                    op1: t.op.id,
                    op2: e.op.id,
                    port1: t.name,
                    port2: e.name
                })
            })), t.addEventListener("portSetVariable", ((t, e, i) => {
                const s = {
                    opId: t.id,
                    portName: e.name,
                    variableName: i
                };
                this.send(CABLES.PACO_PORT_SETVARIABLE, s)
            })), t.addEventListener("portAnimUpdated", ((t, e, i) => {
                if (t && e) {
                    const s = {
                        opId: t.id,
                        portName: e.name,
                        anim: i.getSerialized()
                    };
                    this.send(CABLES.PACO_PORT_ANIM_UPDATED, s)
                }
            }))
        };
        Gt.prototype.send = function(t, e) {
            if (!this.paused && (t !== CABLES.PACO_VALUECHANGE || "+ create new one" !== e.v))
                for (let i = 0; i < this.connectors.length; i++) this.connectors[i].send(t, e)
        };
        const Ht = function() {
            window.BroadcastChannel && (this.bc = new BroadcastChannel("test_channel"))
        };
        Ht.prototype.receive = function(t) {
            this.bc && (this._log.log("init"), this.bc.onmessage = t._receive.bind(t))
        }, Ht.prototype.send = function(t, e) {
            if (!this.bc) return;
            const i = {};
            i.event = t, i.vars = e, this.bc.postMessage(JSON.stringify(i))
        };
        class zt {
            constructor(t) {
                this.name = t, this.dur = 0, this._startTime = 0, this.childs = []
            }
            start() {
                this._startTime = performance.now()
            }
            end() {
                this.dur = performance.now() - this._startTime
            }
            push(t) {
                const e = new zt(t);
                return this.childs.push(e), e.start(), e
            }
            print(t) {
                t = t || 0;
                let e = "";
                for (let i = 0; i < t; i++) e += "  ";
                for (let e = 0; e < this.childs.length; e++) this.childs[e].print(t + 1)
            }
        }
        window.CABLES = window.CABLES || {}, CABLES.CG = mt, CABLES.CGP = vt, CABLES.EventTarget = z, CABLES.EMBED = kt, CABLES.Link = Pt, CABLES.Port = X, CABLES.Op = Nt, CABLES.Profiler = Mt, CABLES.Patch = Lt, CABLES.Instancing = wt, CABLES.Timer = nt, CABLES.WEBAUDIO = Dt, CABLES.Variable = function() {
            let t = null;
            const e = [];
            this.onChanged = function(t) {
                e.push(t)
            }, this.getValue = function() {
                return t
            }, this.setValue = function(e) {
                t = e, this.emitChanged()
            }, this.emitChanged = function() {
                for (let t = 0; t < e.length; t++) e[t]()
            }
        }, CABLES.LoadingStatus = Ct, CABLES.now = rt, CABLES.internalNow = st, CABLES.BranchStack = class {
            constructor() {}
            start() {
                this.root = new zt("Root"), this.root.start(), this.current = this.root
            }
            push(t) {
                this.current || this.start();
                const e = this.current;
                return this.current = this.current.push(t), this.current.prev = e, this.current.start(), this.current
            }
            pop() {
                this.current && (this.current.end(), this.current = this.current.prev)
            }
            finish() {
                this.current.end(), this.root.print(), this.current = null
            }
        }, CABLES.Branch = zt;
        const Wt = CABLES = Object.assign(CABLES, e, t, i, s, a, h, n, o);
        (function() {
            return !this
        })() || console.warn("not in strict mode: index core")
    })(), CABLES = __webpack_exports__.default
})();
//# originalSourceMappingURL=cables.min.js.map

var CABLES = CABLES || {};
CABLES.build = {
    "timestamp": 1695294497050,
    "created": "2023-09-21T11:08:17.050Z",
    "git": {
        "branch": "master",
        "commit": "2577d0ec3e00ecb48fef52a0280a3c9069cf3fd5",
        "date": "2023-09-14T10:27:49.000Z",
        "message": "release - update docs"
    }
};
/*!
@fileoverview gl-matrix - High performance matrix and vector operations
@author Brandon Jones
@author Colin MacKenzie IV
@version 3.1.0

Copyright (c) 2015-2019, Brandon Jones, Colin MacKenzie IV.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.

*/
! function(t, n) {
    "object" == typeof exports && "undefined" != typeof module ? n(exports) : "function" == typeof define && define.amd ? define(["exports"], n) : n((t = t || self).glMatrix = {})
}(this, function(t) {
    "use strict";
    var n = 1e-6,
        a = "undefined" != typeof Float32Array ? Float32Array : Array,
        r = Math.random;
    var u = Math.PI / 180;
    Math.hypot || (Math.hypot = function() {
        for (var t = 0, n = arguments.length; n--;) t += arguments[n] * arguments[n];
        return Math.sqrt(t)
    });
    var e = Object.freeze({
        EPSILON: n,
        get ARRAY_TYPE() {
            return a
        },
        RANDOM: r,
        setMatrixArrayType: function(t) {
            a = t
        },
        toRadian: function(t) {
            return t * u
        },
        equals: function(t, a) {
            return Math.abs(t - a) <= n * Math.max(1, Math.abs(t), Math.abs(a))
        }
    });

    function o(t, n, a) {
        var r = n[0],
            u = n[1],
            e = n[2],
            o = n[3],
            i = a[0],
            c = a[1],
            h = a[2],
            s = a[3];
        return t[0] = r * i + e * c, t[1] = u * i + o * c, t[2] = r * h + e * s, t[3] = u * h + o * s, t
    }

    function i(t, n, a) {
        return t[0] = n[0] - a[0], t[1] = n[1] - a[1], t[2] = n[2] - a[2], t[3] = n[3] - a[3], t
    }
    var c = o,
        h = i,
        s = Object.freeze({
            create: function() {
                var t = new a(4);
                return a != Float32Array && (t[1] = 0, t[2] = 0), t[0] = 1, t[3] = 1, t
            },
            clone: function(t) {
                var n = new a(4);
                return n[0] = t[0], n[1] = t[1], n[2] = t[2], n[3] = t[3], n
            },
            copy: function(t, n) {
                return t[0] = n[0], t[1] = n[1], t[2] = n[2], t[3] = n[3], t
            },
            identity: function(t) {
                return t[0] = 1, t[1] = 0, t[2] = 0, t[3] = 1, t
            },
            fromValues: function(t, n, r, u) {
                var e = new a(4);
                return e[0] = t, e[1] = n, e[2] = r, e[3] = u, e
            },
            set: function(t, n, a, r, u) {
                return t[0] = n, t[1] = a, t[2] = r, t[3] = u, t
            },
            transpose: function(t, n) {
                if (t === n) {
                    var a = n[1];
                    t[1] = n[2], t[2] = a
                } else t[0] = n[0], t[1] = n[2], t[2] = n[1], t[3] = n[3];
                return t
            },
            invert: function(t, n) {
                var a = n[0],
                    r = n[1],
                    u = n[2],
                    e = n[3],
                    o = a * e - u * r;
                return o ? (o = 1 / o, t[0] = e * o, t[1] = -r * o, t[2] = -u * o, t[3] = a * o, t) : null
            },
            adjoint: function(t, n) {
                var a = n[0];
                return t[0] = n[3], t[1] = -n[1], t[2] = -n[2], t[3] = a, t
            },
            determinant: function(t) {
                return t[0] * t[3] - t[2] * t[1]
            },
            multiply: o,
            rotate: function(t, n, a) {
                var r = n[0],
                    u = n[1],
                    e = n[2],
                    o = n[3],
                    i = Math.sin(a),
                    c = Math.cos(a);
                return t[0] = r * c + e * i, t[1] = u * c + o * i, t[2] = r * -i + e * c, t[3] = u * -i + o * c, t
            },
            scale: function(t, n, a) {
                var r = n[0],
                    u = n[1],
                    e = n[2],
                    o = n[3],
                    i = a[0],
                    c = a[1];
                return t[0] = r * i, t[1] = u * i, t[2] = e * c, t[3] = o * c, t
            },
            fromRotation: function(t, n) {
                var a = Math.sin(n),
                    r = Math.cos(n);
                return t[0] = r, t[1] = a, t[2] = -a, t[3] = r, t
            },
            fromScaling: function(t, n) {
                return t[0] = n[0], t[1] = 0, t[2] = 0, t[3] = n[1], t
            },
            str: function(t) {
                return "mat2(" + t[0] + ", " + t[1] + ", " + t[2] + ", " + t[3] + ")"
            },
            frob: function(t) {
                return Math.hypot(t[0], t[1], t[2], t[3])
            },
            LDU: function(t, n, a, r) {
                return t[2] = r[2] / r[0], a[0] = r[0], a[1] = r[1], a[3] = r[3] - t[2] * a[1], [t, n, a]
            },
            add: function(t, n, a) {
                return t[0] = n[0] + a[0], t[1] = n[1] + a[1], t[2] = n[2] + a[2], t[3] = n[3] + a[3], t
            },
            subtract: i,
            exactEquals: function(t, n) {
                return t[0] === n[0] && t[1] === n[1] && t[2] === n[2] && t[3] === n[3]
            },
            equals: function(t, a) {
                var r = t[0],
                    u = t[1],
                    e = t[2],
                    o = t[3],
                    i = a[0],
                    c = a[1],
                    h = a[2],
                    s = a[3];
                return Math.abs(r - i) <= n * Math.max(1, Math.abs(r), Math.abs(i)) && Math.abs(u - c) <= n * Math.max(1, Math.abs(u), Math.abs(c)) && Math.abs(e - h) <= n * Math.max(1, Math.abs(e), Math.abs(h)) && Math.abs(o - s) <= n * Math.max(1, Math.abs(o), Math.abs(s))
            },
            multiplyScalar: function(t, n, a) {
                return t[0] = n[0] * a, t[1] = n[1] * a, t[2] = n[2] * a, t[3] = n[3] * a, t
            },
            multiplyScalarAndAdd: function(t, n, a, r) {
                return t[0] = n[0] + a[0] * r, t[1] = n[1] + a[1] * r, t[2] = n[2] + a[2] * r, t[3] = n[3] + a[3] * r, t
            },
            mul: c,
            sub: h
        });

    function M(t, n, a) {
        var r = n[0],
            u = n[1],
            e = n[2],
            o = n[3],
            i = n[4],
            c = n[5],
            h = a[0],
            s = a[1],
            M = a[2],
            f = a[3],
            l = a[4],
            v = a[5];
        return t[0] = r * h + e * s, t[1] = u * h + o * s, t[2] = r * M + e * f, t[3] = u * M + o * f, t[4] = r * l + e * v + i, t[5] = u * l + o * v + c, t
    }

    function f(t, n, a) {
        return t[0] = n[0] - a[0], t[1] = n[1] - a[1], t[2] = n[2] - a[2], t[3] = n[3] - a[3], t[4] = n[4] - a[4], t[5] = n[5] - a[5], t
    }
    var l = M,
        v = f,
        b = Object.freeze({
            create: function() {
                var t = new a(6);
                return a != Float32Array && (t[1] = 0, t[2] = 0, t[4] = 0, t[5] = 0), t[0] = 1, t[3] = 1, t
            },
            clone: function(t) {
                var n = new a(6);
                return n[0] = t[0], n[1] = t[1], n[2] = t[2], n[3] = t[3], n[4] = t[4], n[5] = t[5], n
            },
            copy: function(t, n) {
                return t[0] = n[0], t[1] = n[1], t[2] = n[2], t[3] = n[3], t[4] = n[4], t[5] = n[5], t
            },
            identity: function(t) {
                return t[0] = 1, t[1] = 0, t[2] = 0, t[3] = 1, t[4] = 0, t[5] = 0, t
            },
            fromValues: function(t, n, r, u, e, o) {
                var i = new a(6);
                return i[0] = t, i[1] = n, i[2] = r, i[3] = u, i[4] = e, i[5] = o, i
            },
            set: function(t, n, a, r, u, e, o) {
                return t[0] = n, t[1] = a, t[2] = r, t[3] = u, t[4] = e, t[5] = o, t
            },
            invert: function(t, n) {
                var a = n[0],
                    r = n[1],
                    u = n[2],
                    e = n[3],
                    o = n[4],
                    i = n[5],
                    c = a * e - r * u;
                return c ? (c = 1 / c, t[0] = e * c, t[1] = -r * c, t[2] = -u * c, t[3] = a * c, t[4] = (u * i - e * o) * c, t[5] = (r * o - a * i) * c, t) : null
            },
            determinant: function(t) {
                return t[0] * t[3] - t[1] * t[2]
            },
            multiply: M,
            rotate: function(t, n, a) {
                var r = n[0],
                    u = n[1],
                    e = n[2],
                    o = n[3],
                    i = n[4],
                    c = n[5],
                    h = Math.sin(a),
                    s = Math.cos(a);
                return t[0] = r * s + e * h, t[1] = u * s + o * h, t[2] = r * -h + e * s, t[3] = u * -h + o * s, t[4] = i, t[5] = c, t
            },
            scale: function(t, n, a) {
                var r = n[0],
                    u = n[1],
                    e = n[2],
                    o = n[3],
                    i = n[4],
                    c = n[5],
                    h = a[0],
                    s = a[1];
                return t[0] = r * h, t[1] = u * h, t[2] = e * s, t[3] = o * s, t[4] = i, t[5] = c, t
            },
            translate: function(t, n, a) {
                var r = n[0],
                    u = n[1],
                    e = n[2],
                    o = n[3],
                    i = n[4],
                    c = n[5],
                    h = a[0],
                    s = a[1];
                return t[0] = r, t[1] = u, t[2] = e, t[3] = o, t[4] = r * h + e * s + i, t[5] = u * h + o * s + c, t
            },
            fromRotation: function(t, n) {
                var a = Math.sin(n),
                    r = Math.cos(n);
                return t[0] = r, t[1] = a, t[2] = -a, t[3] = r, t[4] = 0, t[5] = 0, t
            },
            fromScaling: function(t, n) {
                return t[0] = n[0], t[1] = 0, t[2] = 0, t[3] = n[1], t[4] = 0, t[5] = 0, t
            },
            fromTranslation: function(t, n) {
                return t[0] = 1, t[1] = 0, t[2] = 0, t[3] = 1, t[4] = n[0], t[5] = n[1], t
            },
            str: function(t) {
                return "mat2d(" + t[0] + ", " + t[1] + ", " + t[2] + ", " + t[3] + ", " + t[4] + ", " + t[5] + ")"
            },
            frob: function(t) {
                return Math.hypot(t[0], t[1], t[2], t[3], t[4], t[5], 1)
            },
            add: function(t, n, a) {
                return t[0] = n[0] + a[0], t[1] = n[1] + a[1], t[2] = n[2] + a[2], t[3] = n[3] + a[3], t[4] = n[4] + a[4], t[5] = n[5] + a[5], t
            },
            subtract: f,
            multiplyScalar: function(t, n, a) {
                return t[0] = n[0] * a, t[1] = n[1] * a, t[2] = n[2] * a, t[3] = n[3] * a, t[4] = n[4] * a, t[5] = n[5] * a, t
            },
            multiplyScalarAndAdd: function(t, n, a, r) {
                return t[0] = n[0] + a[0] * r, t[1] = n[1] + a[1] * r, t[2] = n[2] + a[2] * r, t[3] = n[3] + a[3] * r, t[4] = n[4] + a[4] * r, t[5] = n[5] + a[5] * r, t
            },
            exactEquals: function(t, n) {
                return t[0] === n[0] && t[1] === n[1] && t[2] === n[2] && t[3] === n[3] && t[4] === n[4] && t[5] === n[5]
            },
            equals: function(t, a) {
                var r = t[0],
                    u = t[1],
                    e = t[2],
                    o = t[3],
                    i = t[4],
                    c = t[5],
                    h = a[0],
                    s = a[1],
                    M = a[2],
                    f = a[3],
                    l = a[4],
                    v = a[5];
                return Math.abs(r - h) <= n * Math.max(1, Math.abs(r), Math.abs(h)) && Math.abs(u - s) <= n * Math.max(1, Math.abs(u), Math.abs(s)) && Math.abs(e - M) <= n * Math.max(1, Math.abs(e), Math.abs(M)) && Math.abs(o - f) <= n * Math.max(1, Math.abs(o), Math.abs(f)) && Math.abs(i - l) <= n * Math.max(1, Math.abs(i), Math.abs(l)) && Math.abs(c - v) <= n * Math.max(1, Math.abs(c), Math.abs(v))
            },
            mul: l,
            sub: v
        });

    function m() {
        var t = new a(9);
        return a != Float32Array && (t[1] = 0, t[2] = 0, t[3] = 0, t[5] = 0, t[6] = 0, t[7] = 0), t[0] = 1, t[4] = 1, t[8] = 1, t
    }

    function d(t, n, a) {
        var r = n[0],
            u = n[1],
            e = n[2],
            o = n[3],
            i = n[4],
            c = n[5],
            h = n[6],
            s = n[7],
            M = n[8],
            f = a[0],
            l = a[1],
            v = a[2],
            b = a[3],
            m = a[4],
            d = a[5],
            x = a[6],
            p = a[7],
            y = a[8];
        return t[0] = f * r + l * o + v * h, t[1] = f * u + l * i + v * s, t[2] = f * e + l * c + v * M, t[3] = b * r + m * o + d * h, t[4] = b * u + m * i + d * s, t[5] = b * e + m * c + d * M, t[6] = x * r + p * o + y * h, t[7] = x * u + p * i + y * s, t[8] = x * e + p * c + y * M, t
    }

    function x(t, n, a) {
        return t[0] = n[0] - a[0], t[1] = n[1] - a[1], t[2] = n[2] - a[2], t[3] = n[3] - a[3], t[4] = n[4] - a[4], t[5] = n[5] - a[5], t[6] = n[6] - a[6], t[7] = n[7] - a[7], t[8] = n[8] - a[8], t
    }
    var p = d,
        y = x,
        q = Object.freeze({
            create: m,
            fromMat4: function(t, n) {
                return t[0] = n[0], t[1] = n[1], t[2] = n[2], t[3] = n[4], t[4] = n[5], t[5] = n[6], t[6] = n[8], t[7] = n[9], t[8] = n[10], t
            },
            clone: function(t) {
                var n = new a(9);
                return n[0] = t[0], n[1] = t[1], n[2] = t[2], n[3] = t[3], n[4] = t[4], n[5] = t[5], n[6] = t[6], n[7] = t[7], n[8] = t[8], n
            },
            copy: function(t, n) {
                return t[0] = n[0], t[1] = n[1], t[2] = n[2], t[3] = n[3], t[4] = n[4], t[5] = n[5], t[6] = n[6], t[7] = n[7], t[8] = n[8], t
            },
            fromValues: function(t, n, r, u, e, o, i, c, h) {
                var s = new a(9);
                return s[0] = t, s[1] = n, s[2] = r, s[3] = u, s[4] = e, s[5] = o, s[6] = i, s[7] = c, s[8] = h, s
            },
            set: function(t, n, a, r, u, e, o, i, c, h) {
                return t[0] = n, t[1] = a, t[2] = r, t[3] = u, t[4] = e, t[5] = o, t[6] = i, t[7] = c, t[8] = h, t
            },
            identity: function(t) {
                return t[0] = 1, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 1, t[5] = 0, t[6] = 0, t[7] = 0, t[8] = 1, t
            },
            transpose: function(t, n) {
                if (t === n) {
                    var a = n[1],
                        r = n[2],
                        u = n[5];
                    t[1] = n[3], t[2] = n[6], t[3] = a, t[5] = n[7], t[6] = r, t[7] = u
                } else t[0] = n[0], t[1] = n[3], t[2] = n[6], t[3] = n[1], t[4] = n[4], t[5] = n[7], t[6] = n[2], t[7] = n[5], t[8] = n[8];
                return t
            },
            invert: function(t, n) {
                var a = n[0],
                    r = n[1],
                    u = n[2],
                    e = n[3],
                    o = n[4],
                    i = n[5],
                    c = n[6],
                    h = n[7],
                    s = n[8],
                    M = s * o - i * h,
                    f = -s * e + i * c,
                    l = h * e - o * c,
                    v = a * M + r * f + u * l;
                return v ? (v = 1 / v, t[0] = M * v, t[1] = (-s * r + u * h) * v, t[2] = (i * r - u * o) * v, t[3] = f * v, t[4] = (s * a - u * c) * v, t[5] = (-i * a + u * e) * v, t[6] = l * v, t[7] = (-h * a + r * c) * v, t[8] = (o * a - r * e) * v, t) : null
            },
            adjoint: function(t, n) {
                var a = n[0],
                    r = n[1],
                    u = n[2],
                    e = n[3],
                    o = n[4],
                    i = n[5],
                    c = n[6],
                    h = n[7],
                    s = n[8];
                return t[0] = o * s - i * h, t[1] = u * h - r * s, t[2] = r * i - u * o, t[3] = i * c - e * s, t[4] = a * s - u * c, t[5] = u * e - a * i, t[6] = e * h - o * c, t[7] = r * c - a * h, t[8] = a * o - r * e, t
            },
            determinant: function(t) {
                var n = t[0],
                    a = t[1],
                    r = t[2],
                    u = t[3],
                    e = t[4],
                    o = t[5],
                    i = t[6],
                    c = t[7],
                    h = t[8];
                return n * (h * e - o * c) + a * (-h * u + o * i) + r * (c * u - e * i)
            },
            multiply: d,
            translate: function(t, n, a) {
                var r = n[0],
                    u = n[1],
                    e = n[2],
                    o = n[3],
                    i = n[4],
                    c = n[5],
                    h = n[6],
                    s = n[7],
                    M = n[8],
                    f = a[0],
                    l = a[1];
                return t[0] = r, t[1] = u, t[2] = e, t[3] = o, t[4] = i, t[5] = c, t[6] = f * r + l * o + h, t[7] = f * u + l * i + s, t[8] = f * e + l * c + M, t
            },
            rotate: function(t, n, a) {
                var r = n[0],
                    u = n[1],
                    e = n[2],
                    o = n[3],
                    i = n[4],
                    c = n[5],
                    h = n[6],
                    s = n[7],
                    M = n[8],
                    f = Math.sin(a),
                    l = Math.cos(a);
                return t[0] = l * r + f * o, t[1] = l * u + f * i, t[2] = l * e + f * c, t[3] = l * o - f * r, t[4] = l * i - f * u, t[5] = l * c - f * e, t[6] = h, t[7] = s, t[8] = M, t
            },
            scale: function(t, n, a) {
                var r = a[0],
                    u = a[1];
                return t[0] = r * n[0], t[1] = r * n[1], t[2] = r * n[2], t[3] = u * n[3], t[4] = u * n[4], t[5] = u * n[5], t[6] = n[6], t[7] = n[7], t[8] = n[8], t
            },
            fromTranslation: function(t, n) {
                return t[0] = 1, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 1, t[5] = 0, t[6] = n[0], t[7] = n[1], t[8] = 1, t
            },
            fromRotation: function(t, n) {
                var a = Math.sin(n),
                    r = Math.cos(n);
                return t[0] = r, t[1] = a, t[2] = 0, t[3] = -a, t[4] = r, t[5] = 0, t[6] = 0, t[7] = 0, t[8] = 1, t
            },
            fromScaling: function(t, n) {
                return t[0] = n[0], t[1] = 0, t[2] = 0, t[3] = 0, t[4] = n[1], t[5] = 0, t[6] = 0, t[7] = 0, t[8] = 1, t
            },
            fromMat2d: function(t, n) {
                return t[0] = n[0], t[1] = n[1], t[2] = 0, t[3] = n[2], t[4] = n[3], t[5] = 0, t[6] = n[4], t[7] = n[5], t[8] = 1, t
            },
            fromQuat: function(t, n) {
                var a = n[0],
                    r = n[1],
                    u = n[2],
                    e = n[3],
                    o = a + a,
                    i = r + r,
                    c = u + u,
                    h = a * o,
                    s = r * o,
                    M = r * i,
                    f = u * o,
                    l = u * i,
                    v = u * c,
                    b = e * o,
                    m = e * i,
                    d = e * c;
                return t[0] = 1 - M - v, t[3] = s - d, t[6] = f + m, t[1] = s + d, t[4] = 1 - h - v, t[7] = l - b, t[2] = f - m, t[5] = l + b, t[8] = 1 - h - M, t
            },
            normalFromMat4: function(t, n) {
                var a = n[0],
                    r = n[1],
                    u = n[2],
                    e = n[3],
                    o = n[4],
                    i = n[5],
                    c = n[6],
                    h = n[7],
                    s = n[8],
                    M = n[9],
                    f = n[10],
                    l = n[11],
                    v = n[12],
                    b = n[13],
                    m = n[14],
                    d = n[15],
                    x = a * i - r * o,
                    p = a * c - u * o,
                    y = a * h - e * o,
                    q = r * c - u * i,
                    g = r * h - e * i,
                    A = u * h - e * c,
                    w = s * b - M * v,
                    R = s * m - f * v,
                    z = s * d - l * v,
                    P = M * m - f * b,
                    j = M * d - l * b,
                    I = f * d - l * m,
                    S = x * I - p * j + y * P + q * z - g * R + A * w;
                return S ? (S = 1 / S, t[0] = (i * I - c * j + h * P) * S, t[1] = (c * z - o * I - h * R) * S, t[2] = (o * j - i * z + h * w) * S, t[3] = (u * j - r * I - e * P) * S, t[4] = (a * I - u * z + e * R) * S, t[5] = (r * z - a * j - e * w) * S, t[6] = (b * A - m * g + d * q) * S, t[7] = (m * y - v * A - d * p) * S, t[8] = (v * g - b * y + d * x) * S, t) : null
            },
            projection: function(t, n, a) {
                return t[0] = 2 / n, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = -2 / a, t[5] = 0, t[6] = -1, t[7] = 1, t[8] = 1, t
            },
            str: function(t) {
                return "mat3(" + t[0] + ", " + t[1] + ", " + t[2] + ", " + t[3] + ", " + t[4] + ", " + t[5] + ", " + t[6] + ", " + t[7] + ", " + t[8] + ")"
            },
            frob: function(t) {
                return Math.hypot(t[0], t[1], t[2], t[3], t[4], t[5], t[6], t[7], t[8])
            },
            add: function(t, n, a) {
                return t[0] = n[0] + a[0], t[1] = n[1] + a[1], t[2] = n[2] + a[2], t[3] = n[3] + a[3], t[4] = n[4] + a[4], t[5] = n[5] + a[5], t[6] = n[6] + a[6], t[7] = n[7] + a[7], t[8] = n[8] + a[8], t
            },
            subtract: x,
            multiplyScalar: function(t, n, a) {
                return t[0] = n[0] * a, t[1] = n[1] * a, t[2] = n[2] * a, t[3] = n[3] * a, t[4] = n[4] * a, t[5] = n[5] * a, t[6] = n[6] * a, t[7] = n[7] * a, t[8] = n[8] * a, t
            },
            multiplyScalarAndAdd: function(t, n, a, r) {
                return t[0] = n[0] + a[0] * r, t[1] = n[1] + a[1] * r, t[2] = n[2] + a[2] * r, t[3] = n[3] + a[3] * r, t[4] = n[4] + a[4] * r, t[5] = n[5] + a[5] * r, t[6] = n[6] + a[6] * r, t[7] = n[7] + a[7] * r, t[8] = n[8] + a[8] * r, t
            },
            exactEquals: function(t, n) {
                return t[0] === n[0] && t[1] === n[1] && t[2] === n[2] && t[3] === n[3] && t[4] === n[4] && t[5] === n[5] && t[6] === n[6] && t[7] === n[7] && t[8] === n[8]
            },
            equals: function(t, a) {
                var r = t[0],
                    u = t[1],
                    e = t[2],
                    o = t[3],
                    i = t[4],
                    c = t[5],
                    h = t[6],
                    s = t[7],
                    M = t[8],
                    f = a[0],
                    l = a[1],
                    v = a[2],
                    b = a[3],
                    m = a[4],
                    d = a[5],
                    x = a[6],
                    p = a[7],
                    y = a[8];
                return Math.abs(r - f) <= n * Math.max(1, Math.abs(r), Math.abs(f)) && Math.abs(u - l) <= n * Math.max(1, Math.abs(u), Math.abs(l)) && Math.abs(e - v) <= n * Math.max(1, Math.abs(e), Math.abs(v)) && Math.abs(o - b) <= n * Math.max(1, Math.abs(o), Math.abs(b)) && Math.abs(i - m) <= n * Math.max(1, Math.abs(i), Math.abs(m)) && Math.abs(c - d) <= n * Math.max(1, Math.abs(c), Math.abs(d)) && Math.abs(h - x) <= n * Math.max(1, Math.abs(h), Math.abs(x)) && Math.abs(s - p) <= n * Math.max(1, Math.abs(s), Math.abs(p)) && Math.abs(M - y) <= n * Math.max(1, Math.abs(M), Math.abs(y))
            },
            mul: p,
            sub: y
        });

    function g(t) {
        return t[0] = 1, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[5] = 1, t[6] = 0, t[7] = 0, t[8] = 0, t[9] = 0, t[10] = 1, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, t
    }

    function A(t, n, a) {
        var r = n[0],
            u = n[1],
            e = n[2],
            o = n[3],
            i = n[4],
            c = n[5],
            h = n[6],
            s = n[7],
            M = n[8],
            f = n[9],
            l = n[10],
            v = n[11],
            b = n[12],
            m = n[13],
            d = n[14],
            x = n[15],
            p = a[0],
            y = a[1],
            q = a[2],
            g = a[3];
        return t[0] = p * r + y * i + q * M + g * b, t[1] = p * u + y * c + q * f + g * m, t[2] = p * e + y * h + q * l + g * d, t[3] = p * o + y * s + q * v + g * x, p = a[4], y = a[5], q = a[6], g = a[7], t[4] = p * r + y * i + q * M + g * b, t[5] = p * u + y * c + q * f + g * m, t[6] = p * e + y * h + q * l + g * d, t[7] = p * o + y * s + q * v + g * x, p = a[8], y = a[9], q = a[10], g = a[11], t[8] = p * r + y * i + q * M + g * b, t[9] = p * u + y * c + q * f + g * m, t[10] = p * e + y * h + q * l + g * d, t[11] = p * o + y * s + q * v + g * x, p = a[12], y = a[13], q = a[14], g = a[15], t[12] = p * r + y * i + q * M + g * b, t[13] = p * u + y * c + q * f + g * m, t[14] = p * e + y * h + q * l + g * d, t[15] = p * o + y * s + q * v + g * x, t
    }

    function w(t, n, a) {
        var r = n[0],
            u = n[1],
            e = n[2],
            o = n[3],
            i = r + r,
            c = u + u,
            h = e + e,
            s = r * i,
            M = r * c,
            f = r * h,
            l = u * c,
            v = u * h,
            b = e * h,
            m = o * i,
            d = o * c,
            x = o * h;
        return t[0] = 1 - (l + b), t[1] = M + x, t[2] = f - d, t[3] = 0, t[4] = M - x, t[5] = 1 - (s + b), t[6] = v + m, t[7] = 0, t[8] = f + d, t[9] = v - m, t[10] = 1 - (s + l), t[11] = 0, t[12] = a[0], t[13] = a[1], t[14] = a[2], t[15] = 1, t
    }

    function R(t, n) {
        return t[0] = n[12], t[1] = n[13], t[2] = n[14], t
    }

    function z(t, n) {
        var a = n[0],
            r = n[1],
            u = n[2],
            e = n[4],
            o = n[5],
            i = n[6],
            c = n[8],
            h = n[9],
            s = n[10];
        return t[0] = Math.hypot(a, r, u), t[1] = Math.hypot(e, o, i), t[2] = Math.hypot(c, h, s), t
    }

    function P(t, n) {
        var r = new a(3);
        z(r, n);
        var u = 1 / r[0],
            e = 1 / r[1],
            o = 1 / r[2],
            i = n[0] * u,
            c = n[1] * e,
            h = n[2] * o,
            s = n[4] * u,
            M = n[5] * e,
            f = n[6] * o,
            l = n[8] * u,
            v = n[9] * e,
            b = n[10] * o,
            m = i + M + b,
            d = 0;
        return m > 0 ? (d = 2 * Math.sqrt(m + 1), t[3] = .25 * d, t[0] = (f - v) / d, t[1] = (l - h) / d, t[2] = (c - s) / d) : i > M && i > b ? (d = 2 * Math.sqrt(1 + i - M - b), t[3] = (f - v) / d, t[0] = .25 * d, t[1] = (c + s) / d, t[2] = (l + h) / d) : M > b ? (d = 2 * Math.sqrt(1 + M - i - b), t[3] = (l - h) / d, t[0] = (c + s) / d, t[1] = .25 * d, t[2] = (f + v) / d) : (d = 2 * Math.sqrt(1 + b - i - M), t[3] = (c - s) / d, t[0] = (l + h) / d, t[1] = (f + v) / d, t[2] = .25 * d), t
    }

    function j(t, n, a) {
        return t[0] = n[0] - a[0], t[1] = n[1] - a[1], t[2] = n[2] - a[2], t[3] = n[3] - a[3], t[4] = n[4] - a[4], t[5] = n[5] - a[5], t[6] = n[6] - a[6], t[7] = n[7] - a[7], t[8] = n[8] - a[8], t[9] = n[9] - a[9], t[10] = n[10] - a[10], t[11] = n[11] - a[11], t[12] = n[12] - a[12], t[13] = n[13] - a[13], t[14] = n[14] - a[14], t[15] = n[15] - a[15], t
    }
    var I = A,
        S = j,
        E = Object.freeze({
            create: function() {
                var t = new a(16);
                return a != Float32Array && (t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[6] = 0, t[7] = 0, t[8] = 0, t[9] = 0, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0), t[0] = 1, t[5] = 1, t[10] = 1, t[15] = 1, t
            },
            clone: function(t) {
                var n = new a(16);
                return n[0] = t[0], n[1] = t[1], n[2] = t[2], n[3] = t[3], n[4] = t[4], n[5] = t[5], n[6] = t[6], n[7] = t[7], n[8] = t[8], n[9] = t[9], n[10] = t[10], n[11] = t[11], n[12] = t[12], n[13] = t[13], n[14] = t[14], n[15] = t[15], n
            },
            copy: function(t, n) {
                return t[0] = n[0], t[1] = n[1], t[2] = n[2], t[3] = n[3], t[4] = n[4], t[5] = n[5], t[6] = n[6], t[7] = n[7], t[8] = n[8], t[9] = n[9], t[10] = n[10], t[11] = n[11], t[12] = n[12], t[13] = n[13], t[14] = n[14], t[15] = n[15], t
            },
            fromValues: function(t, n, r, u, e, o, i, c, h, s, M, f, l, v, b, m) {
                var d = new a(16);
                return d[0] = t, d[1] = n, d[2] = r, d[3] = u, d[4] = e, d[5] = o, d[6] = i, d[7] = c, d[8] = h, d[9] = s, d[10] = M, d[11] = f, d[12] = l, d[13] = v, d[14] = b, d[15] = m, d
            },
            set: function(t, n, a, r, u, e, o, i, c, h, s, M, f, l, v, b, m) {
                return t[0] = n, t[1] = a, t[2] = r, t[3] = u, t[4] = e, t[5] = o, t[6] = i, t[7] = c, t[8] = h, t[9] = s, t[10] = M, t[11] = f, t[12] = l, t[13] = v, t[14] = b, t[15] = m, t
            },
            identity: g,
            transpose: function(t, n) {
                if (t === n) {
                    var a = n[1],
                        r = n[2],
                        u = n[3],
                        e = n[6],
                        o = n[7],
                        i = n[11];
                    t[1] = n[4], t[2] = n[8], t[3] = n[12], t[4] = a, t[6] = n[9], t[7] = n[13], t[8] = r, t[9] = e, t[11] = n[14], t[12] = u, t[13] = o, t[14] = i
                } else t[0] = n[0], t[1] = n[4], t[2] = n[8], t[3] = n[12], t[4] = n[1], t[5] = n[5], t[6] = n[9], t[7] = n[13], t[8] = n[2], t[9] = n[6], t[10] = n[10], t[11] = n[14], t[12] = n[3], t[13] = n[7], t[14] = n[11], t[15] = n[15];
                return t
            },
            invert: function(t, n) {
                var a = n[0],
                    r = n[1],
                    u = n[2],
                    e = n[3],
                    o = n[4],
                    i = n[5],
                    c = n[6],
                    h = n[7],
                    s = n[8],
                    M = n[9],
                    f = n[10],
                    l = n[11],
                    v = n[12],
                    b = n[13],
                    m = n[14],
                    d = n[15],
                    x = a * i - r * o,
                    p = a * c - u * o,
                    y = a * h - e * o,
                    q = r * c - u * i,
                    g = r * h - e * i,
                    A = u * h - e * c,
                    w = s * b - M * v,
                    R = s * m - f * v,
                    z = s * d - l * v,
                    P = M * m - f * b,
                    j = M * d - l * b,
                    I = f * d - l * m,
                    S = x * I - p * j + y * P + q * z - g * R + A * w;
                return S ? (S = 1 / S, t[0] = (i * I - c * j + h * P) * S, t[1] = (u * j - r * I - e * P) * S, t[2] = (b * A - m * g + d * q) * S, t[3] = (f * g - M * A - l * q) * S, t[4] = (c * z - o * I - h * R) * S, t[5] = (a * I - u * z + e * R) * S, t[6] = (m * y - v * A - d * p) * S, t[7] = (s * A - f * y + l * p) * S, t[8] = (o * j - i * z + h * w) * S, t[9] = (r * z - a * j - e * w) * S, t[10] = (v * g - b * y + d * x) * S, t[11] = (M * y - s * g - l * x) * S, t[12] = (i * R - o * P - c * w) * S, t[13] = (a * P - r * R + u * w) * S, t[14] = (b * p - v * q - m * x) * S, t[15] = (s * q - M * p + f * x) * S, t) : null
            },
            adjoint: function(t, n) {
                var a = n[0],
                    r = n[1],
                    u = n[2],
                    e = n[3],
                    o = n[4],
                    i = n[5],
                    c = n[6],
                    h = n[7],
                    s = n[8],
                    M = n[9],
                    f = n[10],
                    l = n[11],
                    v = n[12],
                    b = n[13],
                    m = n[14],
                    d = n[15];
                return t[0] = i * (f * d - l * m) - M * (c * d - h * m) + b * (c * l - h * f), t[1] = -(r * (f * d - l * m) - M * (u * d - e * m) + b * (u * l - e * f)), t[2] = r * (c * d - h * m) - i * (u * d - e * m) + b * (u * h - e * c), t[3] = -(r * (c * l - h * f) - i * (u * l - e * f) + M * (u * h - e * c)), t[4] = -(o * (f * d - l * m) - s * (c * d - h * m) + v * (c * l - h * f)), t[5] = a * (f * d - l * m) - s * (u * d - e * m) + v * (u * l - e * f), t[6] = -(a * (c * d - h * m) - o * (u * d - e * m) + v * (u * h - e * c)), t[7] = a * (c * l - h * f) - o * (u * l - e * f) + s * (u * h - e * c), t[8] = o * (M * d - l * b) - s * (i * d - h * b) + v * (i * l - h * M), t[9] = -(a * (M * d - l * b) - s * (r * d - e * b) + v * (r * l - e * M)), t[10] = a * (i * d - h * b) - o * (r * d - e * b) + v * (r * h - e * i), t[11] = -(a * (i * l - h * M) - o * (r * l - e * M) + s * (r * h - e * i)), t[12] = -(o * (M * m - f * b) - s * (i * m - c * b) + v * (i * f - c * M)), t[13] = a * (M * m - f * b) - s * (r * m - u * b) + v * (r * f - u * M), t[14] = -(a * (i * m - c * b) - o * (r * m - u * b) + v * (r * c - u * i)), t[15] = a * (i * f - c * M) - o * (r * f - u * M) + s * (r * c - u * i), t
            },
            determinant: function(t) {
                var n = t[0],
                    a = t[1],
                    r = t[2],
                    u = t[3],
                    e = t[4],
                    o = t[5],
                    i = t[6],
                    c = t[7],
                    h = t[8],
                    s = t[9],
                    M = t[10],
                    f = t[11],
                    l = t[12],
                    v = t[13],
                    b = t[14],
                    m = t[15];
                return (n * o - a * e) * (M * m - f * b) - (n * i - r * e) * (s * m - f * v) + (n * c - u * e) * (s * b - M * v) + (a * i - r * o) * (h * m - f * l) - (a * c - u * o) * (h * b - M * l) + (r * c - u * i) * (h * v - s * l)
            },
            multiply: A,
            translate: function(t, n, a) {
                var r, u, e, o, i, c, h, s, M, f, l, v, b = a[0],
                    m = a[1],
                    d = a[2];
                return n === t ? (t[12] = n[0] * b + n[4] * m + n[8] * d + n[12], t[13] = n[1] * b + n[5] * m + n[9] * d + n[13], t[14] = n[2] * b + n[6] * m + n[10] * d + n[14], t[15] = n[3] * b + n[7] * m + n[11] * d + n[15]) : (r = n[0], u = n[1], e = n[2], o = n[3], i = n[4], c = n[5], h = n[6], s = n[7], M = n[8], f = n[9], l = n[10], v = n[11], t[0] = r, t[1] = u, t[2] = e, t[3] = o, t[4] = i, t[5] = c, t[6] = h, t[7] = s, t[8] = M, t[9] = f, t[10] = l, t[11] = v, t[12] = r * b + i * m + M * d + n[12], t[13] = u * b + c * m + f * d + n[13], t[14] = e * b + h * m + l * d + n[14], t[15] = o * b + s * m + v * d + n[15]), t
            },
            scale: function(t, n, a) {
                var r = a[0],
                    u = a[1],
                    e = a[2];
                return t[0] = n[0] * r, t[1] = n[1] * r, t[2] = n[2] * r, t[3] = n[3] * r, t[4] = n[4] * u, t[5] = n[5] * u, t[6] = n[6] * u, t[7] = n[7] * u, t[8] = n[8] * e, t[9] = n[9] * e, t[10] = n[10] * e, t[11] = n[11] * e, t[12] = n[12], t[13] = n[13], t[14] = n[14], t[15] = n[15], t
            },
            rotate: function(t, a, r, u) {
                var e, o, i, c, h, s, M, f, l, v, b, m, d, x, p, y, q, g, A, w, R, z, P, j, I = u[0],
                    S = u[1],
                    E = u[2],
                    O = Math.hypot(I, S, E);
                return O < n ? null : (I *= O = 1 / O, S *= O, E *= O, e = Math.sin(r), i = 1 - (o = Math.cos(r)), c = a[0], h = a[1], s = a[2], M = a[3], f = a[4], l = a[5], v = a[6], b = a[7], m = a[8], d = a[9], x = a[10], p = a[11], y = I * I * i + o, q = S * I * i + E * e, g = E * I * i - S * e, A = I * S * i - E * e, w = S * S * i + o, R = E * S * i + I * e, z = I * E * i + S * e, P = S * E * i - I * e, j = E * E * i + o, t[0] = c * y + f * q + m * g, t[1] = h * y + l * q + d * g, t[2] = s * y + v * q + x * g, t[3] = M * y + b * q + p * g, t[4] = c * A + f * w + m * R, t[5] = h * A + l * w + d * R, t[6] = s * A + v * w + x * R, t[7] = M * A + b * w + p * R, t[8] = c * z + f * P + m * j, t[9] = h * z + l * P + d * j, t[10] = s * z + v * P + x * j, t[11] = M * z + b * P + p * j, a !== t && (t[12] = a[12], t[13] = a[13], t[14] = a[14], t[15] = a[15]), t)
            },
            rotateX: function(t, n, a) {
                var r = Math.sin(a),
                    u = Math.cos(a),
                    e = n[4],
                    o = n[5],
                    i = n[6],
                    c = n[7],
                    h = n[8],
                    s = n[9],
                    M = n[10],
                    f = n[11];
                return n !== t && (t[0] = n[0], t[1] = n[1], t[2] = n[2], t[3] = n[3], t[12] = n[12], t[13] = n[13], t[14] = n[14], t[15] = n[15]), t[4] = e * u + h * r, t[5] = o * u + s * r, t[6] = i * u + M * r, t[7] = c * u + f * r, t[8] = h * u - e * r, t[9] = s * u - o * r, t[10] = M * u - i * r, t[11] = f * u - c * r, t
            },
            rotateY: function(t, n, a) {
                var r = Math.sin(a),
                    u = Math.cos(a),
                    e = n[0],
                    o = n[1],
                    i = n[2],
                    c = n[3],
                    h = n[8],
                    s = n[9],
                    M = n[10],
                    f = n[11];
                return n !== t && (t[4] = n[4], t[5] = n[5], t[6] = n[6], t[7] = n[7], t[12] = n[12], t[13] = n[13], t[14] = n[14], t[15] = n[15]), t[0] = e * u - h * r, t[1] = o * u - s * r, t[2] = i * u - M * r, t[3] = c * u - f * r, t[8] = e * r + h * u, t[9] = o * r + s * u, t[10] = i * r + M * u, t[11] = c * r + f * u, t
            },
            rotateZ: function(t, n, a) {
                var r = Math.sin(a),
                    u = Math.cos(a),
                    e = n[0],
                    o = n[1],
                    i = n[2],
                    c = n[3],
                    h = n[4],
                    s = n[5],
                    M = n[6],
                    f = n[7];
                return n !== t && (t[8] = n[8], t[9] = n[9], t[10] = n[10], t[11] = n[11], t[12] = n[12], t[13] = n[13], t[14] = n[14], t[15] = n[15]), t[0] = e * u + h * r, t[1] = o * u + s * r, t[2] = i * u + M * r, t[3] = c * u + f * r, t[4] = h * u - e * r, t[5] = s * u - o * r, t[6] = M * u - i * r, t[7] = f * u - c * r, t
            },
            fromTranslation: function(t, n) {
                return t[0] = 1, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[5] = 1, t[6] = 0, t[7] = 0, t[8] = 0, t[9] = 0, t[10] = 1, t[11] = 0, t[12] = n[0], t[13] = n[1], t[14] = n[2], t[15] = 1, t
            },
            fromScaling: function(t, n) {
                return t[0] = n[0], t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[5] = n[1], t[6] = 0, t[7] = 0, t[8] = 0, t[9] = 0, t[10] = n[2], t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, t
            },
            fromRotation: function(t, a, r) {
                var u, e, o, i = r[0],
                    c = r[1],
                    h = r[2],
                    s = Math.hypot(i, c, h);
                return s < n ? null : (i *= s = 1 / s, c *= s, h *= s, u = Math.sin(a), o = 1 - (e = Math.cos(a)), t[0] = i * i * o + e, t[1] = c * i * o + h * u, t[2] = h * i * o - c * u, t[3] = 0, t[4] = i * c * o - h * u, t[5] = c * c * o + e, t[6] = h * c * o + i * u, t[7] = 0, t[8] = i * h * o + c * u, t[9] = c * h * o - i * u, t[10] = h * h * o + e, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, t)
            },
            fromXRotation: function(t, n) {
                var a = Math.sin(n),
                    r = Math.cos(n);
                return t[0] = 1, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[5] = r, t[6] = a, t[7] = 0, t[8] = 0, t[9] = -a, t[10] = r, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, t
            },
            fromYRotation: function(t, n) {
                var a = Math.sin(n),
                    r = Math.cos(n);
                return t[0] = r, t[1] = 0, t[2] = -a, t[3] = 0, t[4] = 0, t[5] = 1, t[6] = 0, t[7] = 0, t[8] = a, t[9] = 0, t[10] = r, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, t
            },
            fromZRotation: function(t, n) {
                var a = Math.sin(n),
                    r = Math.cos(n);
                return t[0] = r, t[1] = a, t[2] = 0, t[3] = 0, t[4] = -a, t[5] = r, t[6] = 0, t[7] = 0, t[8] = 0, t[9] = 0, t[10] = 1, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, t
            },
            fromRotationTranslation: w,
            fromQuat2: function(t, n) {
                var r = new a(3),
                    u = -n[0],
                    e = -n[1],
                    o = -n[2],
                    i = n[3],
                    c = n[4],
                    h = n[5],
                    s = n[6],
                    M = n[7],
                    f = u * u + e * e + o * o + i * i;
                return f > 0 ? (r[0] = 2 * (c * i + M * u + h * o - s * e) / f, r[1] = 2 * (h * i + M * e + s * u - c * o) / f, r[2] = 2 * (s * i + M * o + c * e - h * u) / f) : (r[0] = 2 * (c * i + M * u + h * o - s * e), r[1] = 2 * (h * i + M * e + s * u - c * o), r[2] = 2 * (s * i + M * o + c * e - h * u)), w(t, n, r), t
            },
            getTranslation: R,
            getScaling: z,
            getRotation: P,
            fromRotationTranslationScale: function(t, n, a, r) {
                var u = n[0],
                    e = n[1],
                    o = n[2],
                    i = n[3],
                    c = u + u,
                    h = e + e,
                    s = o + o,
                    M = u * c,
                    f = u * h,
                    l = u * s,
                    v = e * h,
                    b = e * s,
                    m = o * s,
                    d = i * c,
                    x = i * h,
                    p = i * s,
                    y = r[0],
                    q = r[1],
                    g = r[2];
                return t[0] = (1 - (v + m)) * y, t[1] = (f + p) * y, t[2] = (l - x) * y, t[3] = 0, t[4] = (f - p) * q, t[5] = (1 - (M + m)) * q, t[6] = (b + d) * q, t[7] = 0, t[8] = (l + x) * g, t[9] = (b - d) * g, t[10] = (1 - (M + v)) * g, t[11] = 0, t[12] = a[0], t[13] = a[1], t[14] = a[2], t[15] = 1, t
            },
            fromRotationTranslationScaleOrigin: function(t, n, a, r, u) {
                var e = n[0],
                    o = n[1],
                    i = n[2],
                    c = n[3],
                    h = e + e,
                    s = o + o,
                    M = i + i,
                    f = e * h,
                    l = e * s,
                    v = e * M,
                    b = o * s,
                    m = o * M,
                    d = i * M,
                    x = c * h,
                    p = c * s,
                    y = c * M,
                    q = r[0],
                    g = r[1],
                    A = r[2],
                    w = u[0],
                    R = u[1],
                    z = u[2],
                    P = (1 - (b + d)) * q,
                    j = (l + y) * q,
                    I = (v - p) * q,
                    S = (l - y) * g,
                    E = (1 - (f + d)) * g,
                    O = (m + x) * g,
                    T = (v + p) * A,
                    D = (m - x) * A,
                    F = (1 - (f + b)) * A;
                return t[0] = P, t[1] = j, t[2] = I, t[3] = 0, t[4] = S, t[5] = E, t[6] = O, t[7] = 0, t[8] = T, t[9] = D, t[10] = F, t[11] = 0, t[12] = a[0] + w - (P * w + S * R + T * z), t[13] = a[1] + R - (j * w + E * R + D * z), t[14] = a[2] + z - (I * w + O * R + F * z), t[15] = 1, t
            },
            fromQuat: function(t, n) {
                var a = n[0],
                    r = n[1],
                    u = n[2],
                    e = n[3],
                    o = a + a,
                    i = r + r,
                    c = u + u,
                    h = a * o,
                    s = r * o,
                    M = r * i,
                    f = u * o,
                    l = u * i,
                    v = u * c,
                    b = e * o,
                    m = e * i,
                    d = e * c;
                return t[0] = 1 - M - v, t[1] = s + d, t[2] = f - m, t[3] = 0, t[4] = s - d, t[5] = 1 - h - v, t[6] = l + b, t[7] = 0, t[8] = f + m, t[9] = l - b, t[10] = 1 - h - M, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, t
            },
            frustum: function(t, n, a, r, u, e, o) {
                var i = 1 / (a - n),
                    c = 1 / (u - r),
                    h = 1 / (e - o);
                return t[0] = 2 * e * i, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[5] = 2 * e * c, t[6] = 0, t[7] = 0, t[8] = (a + n) * i, t[9] = (u + r) * c, t[10] = (o + e) * h, t[11] = -1, t[12] = 0, t[13] = 0, t[14] = o * e * 2 * h, t[15] = 0, t
            },
            perspective: function(t, n, a, r, u) {
                var e, o = 1 / Math.tan(n / 2);
                return t[0] = o / a, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[5] = o, t[6] = 0, t[7] = 0, t[8] = 0, t[9] = 0, t[11] = -1, t[12] = 0, t[13] = 0, t[15] = 0, null != u && u !== 1 / 0 ? (e = 1 / (r - u), t[10] = (u + r) * e, t[14] = 2 * u * r * e) : (t[10] = -1, t[14] = -2 * r), t
            },
            perspectiveFromFieldOfView: function(t, n, a, r) {
                var u = Math.tan(n.upDegrees * Math.PI / 180),
                    e = Math.tan(n.downDegrees * Math.PI / 180),
                    o = Math.tan(n.leftDegrees * Math.PI / 180),
                    i = Math.tan(n.rightDegrees * Math.PI / 180),
                    c = 2 / (o + i),
                    h = 2 / (u + e);
                return t[0] = c, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[5] = h, t[6] = 0, t[7] = 0, t[8] = -(o - i) * c * .5, t[9] = (u - e) * h * .5, t[10] = r / (a - r), t[11] = -1, t[12] = 0, t[13] = 0, t[14] = r * a / (a - r), t[15] = 0, t
            },
            ortho: function(t, n, a, r, u, e, o) {
                var i = 1 / (n - a),
                    c = 1 / (r - u),
                    h = 1 / (e - o);
                return t[0] = -2 * i, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[5] = -2 * c, t[6] = 0, t[7] = 0, t[8] = 0, t[9] = 0, t[10] = 2 * h, t[11] = 0, t[12] = (n + a) * i, t[13] = (u + r) * c, t[14] = (o + e) * h, t[15] = 1, t
            },
            lookAt: function(t, a, r, u) {
                var e, o, i, c, h, s, M, f, l, v, b = a[0],
                    m = a[1],
                    d = a[2],
                    x = u[0],
                    p = u[1],
                    y = u[2],
                    q = r[0],
                    A = r[1],
                    w = r[2];
                return Math.abs(b - q) < n && Math.abs(m - A) < n && Math.abs(d - w) < n ? g(t) : (M = b - q, f = m - A, l = d - w, e = p * (l *= v = 1 / Math.hypot(M, f, l)) - y * (f *= v), o = y * (M *= v) - x * l, i = x * f - p * M, (v = Math.hypot(e, o, i)) ? (e *= v = 1 / v, o *= v, i *= v) : (e = 0, o = 0, i = 0), c = f * i - l * o, h = l * e - M * i, s = M * o - f * e, (v = Math.hypot(c, h, s)) ? (c *= v = 1 / v, h *= v, s *= v) : (c = 0, h = 0, s = 0), t[0] = e, t[1] = c, t[2] = M, t[3] = 0, t[4] = o, t[5] = h, t[6] = f, t[7] = 0, t[8] = i, t[9] = s, t[10] = l, t[11] = 0, t[12] = -(e * b + o * m + i * d), t[13] = -(c * b + h * m + s * d), t[14] = -(M * b + f * m + l * d), t[15] = 1, t)
            },
            targetTo: function(t, n, a, r) {
                var u = n[0],
                    e = n[1],
                    o = n[2],
                    i = r[0],
                    c = r[1],
                    h = r[2],
                    s = u - a[0],
                    M = e - a[1],
                    f = o - a[2],
                    l = s * s + M * M + f * f;
                l > 0 && (s *= l = 1 / Math.sqrt(l), M *= l, f *= l);
                var v = c * f - h * M,
                    b = h * s - i * f,
                    m = i * M - c * s;
                return (l = v * v + b * b + m * m) > 0 && (v *= l = 1 / Math.sqrt(l), b *= l, m *= l), t[0] = v, t[1] = b, t[2] = m, t[3] = 0, t[4] = M * m - f * b, t[5] = f * v - s * m, t[6] = s * b - M * v, t[7] = 0, t[8] = s, t[9] = M, t[10] = f, t[11] = 0, t[12] = u, t[13] = e, t[14] = o, t[15] = 1, t
            },
            str: function(t) {
                return "mat4(" + t[0] + ", " + t[1] + ", " + t[2] + ", " + t[3] + ", " + t[4] + ", " + t[5] + ", " + t[6] + ", " + t[7] + ", " + t[8] + ", " + t[9] + ", " + t[10] + ", " + t[11] + ", " + t[12] + ", " + t[13] + ", " + t[14] + ", " + t[15] + ")"
            },
            frob: function(t) {
                return Math.hypot(t[0], t[1], t[3], t[4], t[5], t[6], t[7], t[8], t[9], t[10], t[11], t[12], t[13], t[14], t[15])
            },
            add: function(t, n, a) {
                return t[0] = n[0] + a[0], t[1] = n[1] + a[1], t[2] = n[2] + a[2], t[3] = n[3] + a[3], t[4] = n[4] + a[4], t[5] = n[5] + a[5], t[6] = n[6] + a[6], t[7] = n[7] + a[7], t[8] = n[8] + a[8], t[9] = n[9] + a[9], t[10] = n[10] + a[10], t[11] = n[11] + a[11], t[12] = n[12] + a[12], t[13] = n[13] + a[13], t[14] = n[14] + a[14], t[15] = n[15] + a[15], t
            },
            subtract: j,
            multiplyScalar: function(t, n, a) {
                return t[0] = n[0] * a, t[1] = n[1] * a, t[2] = n[2] * a, t[3] = n[3] * a, t[4] = n[4] * a, t[5] = n[5] * a, t[6] = n[6] * a, t[7] = n[7] * a, t[8] = n[8] * a, t[9] = n[9] * a, t[10] = n[10] * a, t[11] = n[11] * a, t[12] = n[12] * a, t[13] = n[13] * a, t[14] = n[14] * a, t[15] = n[15] * a, t
            },
            multiplyScalarAndAdd: function(t, n, a, r) {
                return t[0] = n[0] + a[0] * r, t[1] = n[1] + a[1] * r, t[2] = n[2] + a[2] * r, t[3] = n[3] + a[3] * r, t[4] = n[4] + a[4] * r, t[5] = n[5] + a[5] * r, t[6] = n[6] + a[6] * r, t[7] = n[7] + a[7] * r, t[8] = n[8] + a[8] * r, t[9] = n[9] + a[9] * r, t[10] = n[10] + a[10] * r, t[11] = n[11] + a[11] * r, t[12] = n[12] + a[12] * r, t[13] = n[13] + a[13] * r, t[14] = n[14] + a[14] * r, t[15] = n[15] + a[15] * r, t
            },
            exactEquals: function(t, n) {
                return t[0] === n[0] && t[1] === n[1] && t[2] === n[2] && t[3] === n[3] && t[4] === n[4] && t[5] === n[5] && t[6] === n[6] && t[7] === n[7] && t[8] === n[8] && t[9] === n[9] && t[10] === n[10] && t[11] === n[11] && t[12] === n[12] && t[13] === n[13] && t[14] === n[14] && t[15] === n[15]
            },
            equals: function(t, a) {
                var r = t[0],
                    u = t[1],
                    e = t[2],
                    o = t[3],
                    i = t[4],
                    c = t[5],
                    h = t[6],
                    s = t[7],
                    M = t[8],
                    f = t[9],
                    l = t[10],
                    v = t[11],
                    b = t[12],
                    m = t[13],
                    d = t[14],
                    x = t[15],
                    p = a[0],
                    y = a[1],
                    q = a[2],
                    g = a[3],
                    A = a[4],
                    w = a[5],
                    R = a[6],
                    z = a[7],
                    P = a[8],
                    j = a[9],
                    I = a[10],
                    S = a[11],
                    E = a[12],
                    O = a[13],
                    T = a[14],
                    D = a[15];
                return Math.abs(r - p) <= n * Math.max(1, Math.abs(r), Math.abs(p)) && Math.abs(u - y) <= n * Math.max(1, Math.abs(u), Math.abs(y)) && Math.abs(e - q) <= n * Math.max(1, Math.abs(e), Math.abs(q)) && Math.abs(o - g) <= n * Math.max(1, Math.abs(o), Math.abs(g)) && Math.abs(i - A) <= n * Math.max(1, Math.abs(i), Math.abs(A)) && Math.abs(c - w) <= n * Math.max(1, Math.abs(c), Math.abs(w)) && Math.abs(h - R) <= n * Math.max(1, Math.abs(h), Math.abs(R)) && Math.abs(s - z) <= n * Math.max(1, Math.abs(s), Math.abs(z)) && Math.abs(M - P) <= n * Math.max(1, Math.abs(M), Math.abs(P)) && Math.abs(f - j) <= n * Math.max(1, Math.abs(f), Math.abs(j)) && Math.abs(l - I) <= n * Math.max(1, Math.abs(l), Math.abs(I)) && Math.abs(v - S) <= n * Math.max(1, Math.abs(v), Math.abs(S)) && Math.abs(b - E) <= n * Math.max(1, Math.abs(b), Math.abs(E)) && Math.abs(m - O) <= n * Math.max(1, Math.abs(m), Math.abs(O)) && Math.abs(d - T) <= n * Math.max(1, Math.abs(d), Math.abs(T)) && Math.abs(x - D) <= n * Math.max(1, Math.abs(x), Math.abs(D))
            },
            mul: I,
            sub: S
        });

    function O() {
        var t = new a(3);
        return a != Float32Array && (t[0] = 0, t[1] = 0, t[2] = 0), t
    }

    function T(t) {
        var n = t[0],
            a = t[1],
            r = t[2];
        return Math.hypot(n, a, r)
    }

    function D(t, n, r) {
        var u = new a(3);
        return u[0] = t, u[1] = n, u[2] = r, u
    }

    function F(t, n, a) {
        return t[0] = n[0] - a[0], t[1] = n[1] - a[1], t[2] = n[2] - a[2], t
    }

    function L(t, n, a) {
        return t[0] = n[0] * a[0], t[1] = n[1] * a[1], t[2] = n[2] * a[2], t
    }

    function V(t, n, a) {
        return t[0] = n[0] / a[0], t[1] = n[1] / a[1], t[2] = n[2] / a[2], t
    }

    function Q(t, n) {
        var a = n[0] - t[0],
            r = n[1] - t[1],
            u = n[2] - t[2];
        return Math.hypot(a, r, u)
    }

    function Y(t, n) {
        var a = n[0] - t[0],
            r = n[1] - t[1],
            u = n[2] - t[2];
        return a * a + r * r + u * u
    }

    function X(t) {
        var n = t[0],
            a = t[1],
            r = t[2];
        return n * n + a * a + r * r
    }

    function Z(t, n) {
        var a = n[0],
            r = n[1],
            u = n[2],
            e = a * a + r * r + u * u;
        return e > 0 && (e = 1 / Math.sqrt(e)), t[0] = n[0] * e, t[1] = n[1] * e, t[2] = n[2] * e, t
    }

    function _(t, n) {
        return t[0] * n[0] + t[1] * n[1] + t[2] * n[2]
    }

    function B(t, n, a) {
        var r = n[0],
            u = n[1],
            e = n[2],
            o = a[0],
            i = a[1],
            c = a[2];
        return t[0] = u * c - e * i, t[1] = e * o - r * c, t[2] = r * i - u * o, t
    }
    var N, k = F,
        U = L,
        W = V,
        C = Q,
        G = Y,
        H = T,
        J = X,
        K = (N = O(), function(t, n, a, r, u, e) {
            var o, i;
            for (n || (n = 3), a || (a = 0), i = r ? Math.min(r * n + a, t.length) : t.length, o = a; o < i; o += n) N[0] = t[o], N[1] = t[o + 1], N[2] = t[o + 2], u(N, N, e), t[o] = N[0], t[o + 1] = N[1], t[o + 2] = N[2];
            return t
        }),
        $ = Object.freeze({
            create: O,
            clone: function(t) {
                var n = new a(3);
                return n[0] = t[0], n[1] = t[1], n[2] = t[2], n
            },
            length: T,
            fromValues: D,
            copy: function(t, n) {
                return t[0] = n[0], t[1] = n[1], t[2] = n[2], t
            },
            set: function(t, n, a, r) {
                return t[0] = n, t[1] = a, t[2] = r, t
            },
            add: function(t, n, a) {
                return t[0] = n[0] + a[0], t[1] = n[1] + a[1], t[2] = n[2] + a[2], t
            },
            subtract: F,
            multiply: L,
            divide: V,
            ceil: function(t, n) {
                return t[0] = Math.ceil(n[0]), t[1] = Math.ceil(n[1]), t[2] = Math.ceil(n[2]), t
            },
            floor: function(t, n) {
                return t[0] = Math.floor(n[0]), t[1] = Math.floor(n[1]), t[2] = Math.floor(n[2]), t
            },
            min: function(t, n, a) {
                return t[0] = Math.min(n[0], a[0]), t[1] = Math.min(n[1], a[1]), t[2] = Math.min(n[2], a[2]), t
            },
            max: function(t, n, a) {
                return t[0] = Math.max(n[0], a[0]), t[1] = Math.max(n[1], a[1]), t[2] = Math.max(n[2], a[2]), t
            },
            round: function(t, n) {
                return t[0] = Math.round(n[0]), t[1] = Math.round(n[1]), t[2] = Math.round(n[2]), t
            },
            scale: function(t, n, a) {
                return t[0] = n[0] * a, t[1] = n[1] * a, t[2] = n[2] * a, t
            },
            scaleAndAdd: function(t, n, a, r) {
                return t[0] = n[0] + a[0] * r, t[1] = n[1] + a[1] * r, t[2] = n[2] + a[2] * r, t
            },
            distance: Q,
            squaredDistance: Y,
            squaredLength: X,
            negate: function(t, n) {
                return t[0] = -n[0], t[1] = -n[1], t[2] = -n[2], t
            },
            inverse: function(t, n) {
                return t[0] = 1 / n[0], t[1] = 1 / n[1], t[2] = 1 / n[2], t
            },
            normalize: Z,
            dot: _,
            cross: B,
            lerp: function(t, n, a, r) {
                var u = n[0],
                    e = n[1],
                    o = n[2];
                return t[0] = u + r * (a[0] - u), t[1] = e + r * (a[1] - e), t[2] = o + r * (a[2] - o), t
            },
            hermite: function(t, n, a, r, u, e) {
                var o = e * e,
                    i = o * (2 * e - 3) + 1,
                    c = o * (e - 2) + e,
                    h = o * (e - 1),
                    s = o * (3 - 2 * e);
                return t[0] = n[0] * i + a[0] * c + r[0] * h + u[0] * s, t[1] = n[1] * i + a[1] * c + r[1] * h + u[1] * s, t[2] = n[2] * i + a[2] * c + r[2] * h + u[2] * s, t
            },
            bezier: function(t, n, a, r, u, e) {
                var o = 1 - e,
                    i = o * o,
                    c = e * e,
                    h = i * o,
                    s = 3 * e * i,
                    M = 3 * c * o,
                    f = c * e;
                return t[0] = n[0] * h + a[0] * s + r[0] * M + u[0] * f, t[1] = n[1] * h + a[1] * s + r[1] * M + u[1] * f, t[2] = n[2] * h + a[2] * s + r[2] * M + u[2] * f, t
            },
            random: function(t, n) {
                n = n || 1;
                var a = 2 * r() * Math.PI,
                    u = 2 * r() - 1,
                    e = Math.sqrt(1 - u * u) * n;
                return t[0] = Math.cos(a) * e, t[1] = Math.sin(a) * e, t[2] = u * n, t
            },
            transformMat4: function(t, n, a) {
                var r = n[0],
                    u = n[1],
                    e = n[2],
                    o = a[3] * r + a[7] * u + a[11] * e + a[15];
                return o = o || 1, t[0] = (a[0] * r + a[4] * u + a[8] * e + a[12]) / o, t[1] = (a[1] * r + a[5] * u + a[9] * e + a[13]) / o, t[2] = (a[2] * r + a[6] * u + a[10] * e + a[14]) / o, t
            },
            transformMat3: function(t, n, a) {
                var r = n[0],
                    u = n[1],
                    e = n[2];
                return t[0] = r * a[0] + u * a[3] + e * a[6], t[1] = r * a[1] + u * a[4] + e * a[7], t[2] = r * a[2] + u * a[5] + e * a[8], t
            },
            transformQuat: function(t, n, a) {
                var r = a[0],
                    u = a[1],
                    e = a[2],
                    o = a[3],
                    i = n[0],
                    c = n[1],
                    h = n[2],
                    s = u * h - e * c,
                    M = e * i - r * h,
                    f = r * c - u * i,
                    l = u * f - e * M,
                    v = e * s - r * f,
                    b = r * M - u * s,
                    m = 2 * o;
                return s *= m, M *= m, f *= m, l *= 2, v *= 2, b *= 2, t[0] = i + s + l, t[1] = c + M + v, t[2] = h + f + b, t
            },
            rotateX: function(t, n, a, r) {
                var u = [],
                    e = [];
                return u[0] = n[0] - a[0], u[1] = n[1] - a[1], u[2] = n[2] - a[2], e[0] = u[0], e[1] = u[1] * Math.cos(r) - u[2] * Math.sin(r), e[2] = u[1] * Math.sin(r) + u[2] * Math.cos(r), t[0] = e[0] + a[0], t[1] = e[1] + a[1], t[2] = e[2] + a[2], t
            },
            rotateY: function(t, n, a, r) {
                var u = [],
                    e = [];
                return u[0] = n[0] - a[0], u[1] = n[1] - a[1], u[2] = n[2] - a[2], e[0] = u[2] * Math.sin(r) + u[0] * Math.cos(r), e[1] = u[1], e[2] = u[2] * Math.cos(r) - u[0] * Math.sin(r), t[0] = e[0] + a[0], t[1] = e[1] + a[1], t[2] = e[2] + a[2], t
            },
            rotateZ: function(t, n, a, r) {
                var u = [],
                    e = [];
                return u[0] = n[0] - a[0], u[1] = n[1] - a[1], u[2] = n[2] - a[2], e[0] = u[0] * Math.cos(r) - u[1] * Math.sin(r), e[1] = u[0] * Math.sin(r) + u[1] * Math.cos(r), e[2] = u[2], t[0] = e[0] + a[0], t[1] = e[1] + a[1], t[2] = e[2] + a[2], t
            },
            angle: function(t, n) {
                var a = D(t[0], t[1], t[2]),
                    r = D(n[0], n[1], n[2]);
                Z(a, a), Z(r, r);
                var u = _(a, r);
                return u > 1 ? 0 : u < -1 ? Math.PI : Math.acos(u)
            },
            zero: function(t) {
                return t[0] = 0, t[1] = 0, t[2] = 0, t
            },
            str: function(t) {
                return "vec3(" + t[0] + ", " + t[1] + ", " + t[2] + ")"
            },
            exactEquals: function(t, n) {
                return t[0] === n[0] && t[1] === n[1] && t[2] === n[2]
            },
            equals: function(t, a) {
                var r = t[0],
                    u = t[1],
                    e = t[2],
                    o = a[0],
                    i = a[1],
                    c = a[2];
                return Math.abs(r - o) <= n * Math.max(1, Math.abs(r), Math.abs(o)) && Math.abs(u - i) <= n * Math.max(1, Math.abs(u), Math.abs(i)) && Math.abs(e - c) <= n * Math.max(1, Math.abs(e), Math.abs(c))
            },
            sub: k,
            mul: U,
            div: W,
            dist: C,
            sqrDist: G,
            len: H,
            sqrLen: J,
            forEach: K
        });

    function tt() {
        var t = new a(4);
        return a != Float32Array && (t[0] = 0, t[1] = 0, t[2] = 0, t[3] = 0), t
    }

    function nt(t) {
        var n = new a(4);
        return n[0] = t[0], n[1] = t[1], n[2] = t[2], n[3] = t[3], n
    }

    function at(t, n, r, u) {
        var e = new a(4);
        return e[0] = t, e[1] = n, e[2] = r, e[3] = u, e
    }

    function rt(t, n) {
        return t[0] = n[0], t[1] = n[1], t[2] = n[2], t[3] = n[3], t
    }

    function ut(t, n, a, r, u) {
        return t[0] = n, t[1] = a, t[2] = r, t[3] = u, t
    }

    function et(t, n, a) {
        return t[0] = n[0] + a[0], t[1] = n[1] + a[1], t[2] = n[2] + a[2], t[3] = n[3] + a[3], t
    }

    function ot(t, n, a) {
        return t[0] = n[0] - a[0], t[1] = n[1] - a[1], t[2] = n[2] - a[2], t[3] = n[3] - a[3], t
    }

    function it(t, n, a) {
        return t[0] = n[0] * a[0], t[1] = n[1] * a[1], t[2] = n[2] * a[2], t[3] = n[3] * a[3], t
    }

    function ct(t, n, a) {
        return t[0] = n[0] / a[0], t[1] = n[1] / a[1], t[2] = n[2] / a[2], t[3] = n[3] / a[3], t
    }

    function ht(t, n, a) {
        return t[0] = n[0] * a, t[1] = n[1] * a, t[2] = n[2] * a, t[3] = n[3] * a, t
    }

    function st(t, n) {
        var a = n[0] - t[0],
            r = n[1] - t[1],
            u = n[2] - t[2],
            e = n[3] - t[3];
        return Math.hypot(a, r, u, e)
    }

    function Mt(t, n) {
        var a = n[0] - t[0],
            r = n[1] - t[1],
            u = n[2] - t[2],
            e = n[3] - t[3];
        return a * a + r * r + u * u + e * e
    }

    function ft(t) {
        var n = t[0],
            a = t[1],
            r = t[2],
            u = t[3];
        return Math.hypot(n, a, r, u)
    }

    function lt(t) {
        var n = t[0],
            a = t[1],
            r = t[2],
            u = t[3];
        return n * n + a * a + r * r + u * u
    }

    function vt(t, n) {
        var a = n[0],
            r = n[1],
            u = n[2],
            e = n[3],
            o = a * a + r * r + u * u + e * e;
        return o > 0 && (o = 1 / Math.sqrt(o)), t[0] = a * o, t[1] = r * o, t[2] = u * o, t[3] = e * o, t
    }

    function bt(t, n) {
        return t[0] * n[0] + t[1] * n[1] + t[2] * n[2] + t[3] * n[3]
    }

    function mt(t, n, a, r) {
        var u = n[0],
            e = n[1],
            o = n[2],
            i = n[3];
        return t[0] = u + r * (a[0] - u), t[1] = e + r * (a[1] - e), t[2] = o + r * (a[2] - o), t[3] = i + r * (a[3] - i), t
    }

    function dt(t, n) {
        return t[0] === n[0] && t[1] === n[1] && t[2] === n[2] && t[3] === n[3]
    }

    function xt(t, a) {
        var r = t[0],
            u = t[1],
            e = t[2],
            o = t[3],
            i = a[0],
            c = a[1],
            h = a[2],
            s = a[3];
        return Math.abs(r - i) <= n * Math.max(1, Math.abs(r), Math.abs(i)) && Math.abs(u - c) <= n * Math.max(1, Math.abs(u), Math.abs(c)) && Math.abs(e - h) <= n * Math.max(1, Math.abs(e), Math.abs(h)) && Math.abs(o - s) <= n * Math.max(1, Math.abs(o), Math.abs(s))
    }
    var pt = ot,
        yt = it,
        qt = ct,
        gt = st,
        At = Mt,
        wt = ft,
        Rt = lt,
        zt = function() {
            var t = tt();
            return function(n, a, r, u, e, o) {
                var i, c;
                for (a || (a = 4), r || (r = 0), c = u ? Math.min(u * a + r, n.length) : n.length, i = r; i < c; i += a) t[0] = n[i], t[1] = n[i + 1], t[2] = n[i + 2], t[3] = n[i + 3], e(t, t, o), n[i] = t[0], n[i + 1] = t[1], n[i + 2] = t[2], n[i + 3] = t[3];
                return n
            }
        }(),
        Pt = Object.freeze({
            create: tt,
            clone: nt,
            fromValues: at,
            copy: rt,
            set: ut,
            add: et,
            subtract: ot,
            multiply: it,
            divide: ct,
            ceil: function(t, n) {
                return t[0] = Math.ceil(n[0]), t[1] = Math.ceil(n[1]), t[2] = Math.ceil(n[2]), t[3] = Math.ceil(n[3]), t
            },
            floor: function(t, n) {
                return t[0] = Math.floor(n[0]), t[1] = Math.floor(n[1]), t[2] = Math.floor(n[2]), t[3] = Math.floor(n[3]), t
            },
            min: function(t, n, a) {
                return t[0] = Math.min(n[0], a[0]), t[1] = Math.min(n[1], a[1]), t[2] = Math.min(n[2], a[2]), t[3] = Math.min(n[3], a[3]), t
            },
            max: function(t, n, a) {
                return t[0] = Math.max(n[0], a[0]), t[1] = Math.max(n[1], a[1]), t[2] = Math.max(n[2], a[2]), t[3] = Math.max(n[3], a[3]), t
            },
            round: function(t, n) {
                return t[0] = Math.round(n[0]), t[1] = Math.round(n[1]), t[2] = Math.round(n[2]), t[3] = Math.round(n[3]), t
            },
            scale: ht,
            scaleAndAdd: function(t, n, a, r) {
                return t[0] = n[0] + a[0] * r, t[1] = n[1] + a[1] * r, t[2] = n[2] + a[2] * r, t[3] = n[3] + a[3] * r, t
            },
            distance: st,
            squaredDistance: Mt,
            length: ft,
            squaredLength: lt,
            negate: function(t, n) {
                return t[0] = -n[0], t[1] = -n[1], t[2] = -n[2], t[3] = -n[3], t
            },
            inverse: function(t, n) {
                return t[0] = 1 / n[0], t[1] = 1 / n[1], t[2] = 1 / n[2], t[3] = 1 / n[3], t
            },
            normalize: vt,
            dot: bt,
            cross: function(t, n, a, r) {
                var u = a[0] * r[1] - a[1] * r[0],
                    e = a[0] * r[2] - a[2] * r[0],
                    o = a[0] * r[3] - a[3] * r[0],
                    i = a[1] * r[2] - a[2] * r[1],
                    c = a[1] * r[3] - a[3] * r[1],
                    h = a[2] * r[3] - a[3] * r[2],
                    s = n[0],
                    M = n[1],
                    f = n[2],
                    l = n[3];
                return t[0] = M * h - f * c + l * i, t[1] = -s * h + f * o - l * e, t[2] = s * c - M * o + l * u, t[3] = -s * i + M * e - f * u, t
            },
            lerp: mt,
            random: function(t, n) {
                var a, u, e, o, i, c;
                n = n || 1;
                do {
                    i = (a = 2 * r() - 1) * a + (u = 2 * r() - 1) * u
                } while (i >= 1);
                do {
                    c = (e = 2 * r() - 1) * e + (o = 2 * r() - 1) * o
                } while (c >= 1);
                var h = Math.sqrt((1 - i) / c);
                return t[0] = n * a, t[1] = n * u, t[2] = n * e * h, t[3] = n * o * h, t
            },
            transformMat4: function(t, n, a) {
                var r = n[0],
                    u = n[1],
                    e = n[2],
                    o = n[3];
                return t[0] = a[0] * r + a[4] * u + a[8] * e + a[12] * o, t[1] = a[1] * r + a[5] * u + a[9] * e + a[13] * o, t[2] = a[2] * r + a[6] * u + a[10] * e + a[14] * o, t[3] = a[3] * r + a[7] * u + a[11] * e + a[15] * o, t
            },
            transformQuat: function(t, n, a) {
                var r = n[0],
                    u = n[1],
                    e = n[2],
                    o = a[0],
                    i = a[1],
                    c = a[2],
                    h = a[3],
                    s = h * r + i * e - c * u,
                    M = h * u + c * r - o * e,
                    f = h * e + o * u - i * r,
                    l = -o * r - i * u - c * e;
                return t[0] = s * h + l * -o + M * -c - f * -i, t[1] = M * h + l * -i + f * -o - s * -c, t[2] = f * h + l * -c + s * -i - M * -o, t[3] = n[3], t
            },
            zero: function(t) {
                return t[0] = 0, t[1] = 0, t[2] = 0, t[3] = 0, t
            },
            str: function(t) {
                return "vec4(" + t[0] + ", " + t[1] + ", " + t[2] + ", " + t[3] + ")"
            },
            exactEquals: dt,
            equals: xt,
            sub: pt,
            mul: yt,
            div: qt,
            dist: gt,
            sqrDist: At,
            len: wt,
            sqrLen: Rt,
            forEach: zt
        });

    function jt() {
        var t = new a(4);
        return a != Float32Array && (t[0] = 0, t[1] = 0, t[2] = 0), t[3] = 1, t
    }

    function It(t, n, a) {
        a *= .5;
        var r = Math.sin(a);
        return t[0] = r * n[0], t[1] = r * n[1], t[2] = r * n[2], t[3] = Math.cos(a), t
    }

    function St(t, n, a) {
        var r = n[0],
            u = n[1],
            e = n[2],
            o = n[3],
            i = a[0],
            c = a[1],
            h = a[2],
            s = a[3];
        return t[0] = r * s + o * i + u * h - e * c, t[1] = u * s + o * c + e * i - r * h, t[2] = e * s + o * h + r * c - u * i, t[3] = o * s - r * i - u * c - e * h, t
    }

    function Et(t, n, a) {
        a *= .5;
        var r = n[0],
            u = n[1],
            e = n[2],
            o = n[3],
            i = Math.sin(a),
            c = Math.cos(a);
        return t[0] = r * c + o * i, t[1] = u * c + e * i, t[2] = e * c - u * i, t[3] = o * c - r * i, t
    }

    function Ot(t, n, a) {
        a *= .5;
        var r = n[0],
            u = n[1],
            e = n[2],
            o = n[3],
            i = Math.sin(a),
            c = Math.cos(a);
        return t[0] = r * c - e * i, t[1] = u * c + o * i, t[2] = e * c + r * i, t[3] = o * c - u * i, t
    }

    function Tt(t, n, a) {
        a *= .5;
        var r = n[0],
            u = n[1],
            e = n[2],
            o = n[3],
            i = Math.sin(a),
            c = Math.cos(a);
        return t[0] = r * c + u * i, t[1] = u * c - r * i, t[2] = e * c + o * i, t[3] = o * c - e * i, t
    }

    function Dt(t, n) {
        var a = n[0],
            r = n[1],
            u = n[2],
            e = n[3],
            o = Math.sqrt(a * a + r * r + u * u),
            i = Math.exp(e),
            c = o > 0 ? i * Math.sin(o) / o : 0;
        return t[0] = a * c, t[1] = r * c, t[2] = u * c, t[3] = i * Math.cos(o), t
    }

    function Ft(t, n) {
        var a = n[0],
            r = n[1],
            u = n[2],
            e = n[3],
            o = Math.sqrt(a * a + r * r + u * u),
            i = o > 0 ? Math.atan2(o, e) / o : 0;
        return t[0] = a * i, t[1] = r * i, t[2] = u * i, t[3] = .5 * Math.log(a * a + r * r + u * u + e * e), t
    }

    function Lt(t, a, r, u) {
        var e, o, i, c, h, s = a[0],
            M = a[1],
            f = a[2],
            l = a[3],
            v = r[0],
            b = r[1],
            m = r[2],
            d = r[3];
        return (o = s * v + M * b + f * m + l * d) < 0 && (o = -o, v = -v, b = -b, m = -m, d = -d), 1 - o > n ? (e = Math.acos(o), i = Math.sin(e), c = Math.sin((1 - u) * e) / i, h = Math.sin(u * e) / i) : (c = 1 - u, h = u), t[0] = c * s + h * v, t[1] = c * M + h * b, t[2] = c * f + h * m, t[3] = c * l + h * d, t
    }

    function Vt(t, n) {
        var a, r = n[0] + n[4] + n[8];
        if (r > 0) a = Math.sqrt(r + 1), t[3] = .5 * a, a = .5 / a, t[0] = (n[5] - n[7]) * a, t[1] = (n[6] - n[2]) * a, t[2] = (n[1] - n[3]) * a;
        else {
            var u = 0;
            n[4] > n[0] && (u = 1), n[8] > n[3 * u + u] && (u = 2);
            var e = (u + 1) % 3,
                o = (u + 2) % 3;
            a = Math.sqrt(n[3 * u + u] - n[3 * e + e] - n[3 * o + o] + 1), t[u] = .5 * a, a = .5 / a, t[3] = (n[3 * e + o] - n[3 * o + e]) * a, t[e] = (n[3 * e + u] + n[3 * u + e]) * a, t[o] = (n[3 * o + u] + n[3 * u + o]) * a
        }
        return t
    }
    var Qt, Yt, Xt, Zt, _t, Bt, Nt = nt,
        kt = at,
        Ut = rt,
        Wt = ut,
        Ct = et,
        Gt = St,
        Ht = ht,
        Jt = bt,
        Kt = mt,
        $t = ft,
        tn = $t,
        nn = lt,
        an = nn,
        rn = vt,
        un = dt,
        en = xt,
        on = (Qt = O(), Yt = D(1, 0, 0), Xt = D(0, 1, 0), function(t, n, a) {
            var r = _(n, a);
            return r < -.999999 ? (B(Qt, Yt, n), H(Qt) < 1e-6 && B(Qt, Xt, n), Z(Qt, Qt), It(t, Qt, Math.PI), t) : r > .999999 ? (t[0] = 0, t[1] = 0, t[2] = 0, t[3] = 1, t) : (B(Qt, n, a), t[0] = Qt[0], t[1] = Qt[1], t[2] = Qt[2], t[3] = 1 + r, rn(t, t))
        }),
        cn = (Zt = jt(), _t = jt(), function(t, n, a, r, u, e) {
            return Lt(Zt, n, u, e), Lt(_t, a, r, e), Lt(t, Zt, _t, 2 * e * (1 - e)), t
        }),
        hn = (Bt = m(), function(t, n, a, r) {
            return Bt[0] = a[0], Bt[3] = a[1], Bt[6] = a[2], Bt[1] = r[0], Bt[4] = r[1], Bt[7] = r[2], Bt[2] = -n[0], Bt[5] = -n[1], Bt[8] = -n[2], rn(t, Vt(t, Bt))
        }),
        sn = Object.freeze({
            create: jt,
            identity: function(t) {
                return t[0] = 0, t[1] = 0, t[2] = 0, t[3] = 1, t
            },
            setAxisAngle: It,
            getAxisAngle: function(t, a) {
                var r = 2 * Math.acos(a[3]),
                    u = Math.sin(r / 2);
                return u > n ? (t[0] = a[0] / u, t[1] = a[1] / u, t[2] = a[2] / u) : (t[0] = 1, t[1] = 0, t[2] = 0), r
            },
            getAngle: function(t, n) {
                var a = Jt(t, n);
                return Math.acos(2 * a * a - 1)
            },
            multiply: St,
            rotateX: Et,
            rotateY: Ot,
            rotateZ: Tt,
            calculateW: function(t, n) {
                var a = n[0],
                    r = n[1],
                    u = n[2];
                return t[0] = a, t[1] = r, t[2] = u, t[3] = Math.sqrt(Math.abs(1 - a * a - r * r - u * u)), t
            },
            exp: Dt,
            ln: Ft,
            pow: function(t, n, a) {
                return Ft(t, n), Ht(t, t, a), Dt(t, t), t
            },
            slerp: Lt,
            random: function(t) {
                var n = r(),
                    a = r(),
                    u = r(),
                    e = Math.sqrt(1 - n),
                    o = Math.sqrt(n);
                return t[0] = e * Math.sin(2 * Math.PI * a), t[1] = e * Math.cos(2 * Math.PI * a), t[2] = o * Math.sin(2 * Math.PI * u), t[3] = o * Math.cos(2 * Math.PI * u), t
            },
            invert: function(t, n) {
                var a = n[0],
                    r = n[1],
                    u = n[2],
                    e = n[3],
                    o = a * a + r * r + u * u + e * e,
                    i = o ? 1 / o : 0;
                return t[0] = -a * i, t[1] = -r * i, t[2] = -u * i, t[3] = e * i, t
            },
            conjugate: function(t, n) {
                return t[0] = -n[0], t[1] = -n[1], t[2] = -n[2], t[3] = n[3], t
            },
            fromMat3: Vt,
            fromEuler: function(t, n, a, r) {
                var u = .5 * Math.PI / 180;
                n *= u, a *= u, r *= u;
                var e = Math.sin(n),
                    o = Math.cos(n),
                    i = Math.sin(a),
                    c = Math.cos(a),
                    h = Math.sin(r),
                    s = Math.cos(r);
                return t[0] = e * c * s - o * i * h, t[1] = o * i * s + e * c * h, t[2] = o * c * h - e * i * s, t[3] = o * c * s + e * i * h, t
            },
            str: function(t) {
                return "quat(" + t[0] + ", " + t[1] + ", " + t[2] + ", " + t[3] + ")"
            },
            clone: Nt,
            fromValues: kt,
            copy: Ut,
            set: Wt,
            add: Ct,
            mul: Gt,
            scale: Ht,
            dot: Jt,
            lerp: Kt,
            length: $t,
            len: tn,
            squaredLength: nn,
            sqrLen: an,
            normalize: rn,
            exactEquals: un,
            equals: en,
            rotationTo: on,
            sqlerp: cn,
            setAxes: hn
        });

    function Mn(t, n, a) {
        var r = .5 * a[0],
            u = .5 * a[1],
            e = .5 * a[2],
            o = n[0],
            i = n[1],
            c = n[2],
            h = n[3];
        return t[0] = o, t[1] = i, t[2] = c, t[3] = h, t[4] = r * h + u * c - e * i, t[5] = u * h + e * o - r * c, t[6] = e * h + r * i - u * o, t[7] = -r * o - u * i - e * c, t
    }

    function fn(t, n) {
        return t[0] = n[0], t[1] = n[1], t[2] = n[2], t[3] = n[3], t[4] = n[4], t[5] = n[5], t[6] = n[6], t[7] = n[7], t
    }
    var ln = Ut;
    var vn = Ut;

    function bn(t, n, a) {
        var r = n[0],
            u = n[1],
            e = n[2],
            o = n[3],
            i = a[4],
            c = a[5],
            h = a[6],
            s = a[7],
            M = n[4],
            f = n[5],
            l = n[6],
            v = n[7],
            b = a[0],
            m = a[1],
            d = a[2],
            x = a[3];
        return t[0] = r * x + o * b + u * d - e * m, t[1] = u * x + o * m + e * b - r * d, t[2] = e * x + o * d + r * m - u * b, t[3] = o * x - r * b - u * m - e * d, t[4] = r * s + o * i + u * h - e * c + M * x + v * b + f * d - l * m, t[5] = u * s + o * c + e * i - r * h + f * x + v * m + l * b - M * d, t[6] = e * s + o * h + r * c - u * i + l * x + v * d + M * m - f * b, t[7] = o * s - r * i - u * c - e * h + v * x - M * b - f * m - l * d, t
    }
    var mn = bn;
    var dn = Jt;
    var xn = $t,
        pn = xn,
        yn = nn,
        qn = yn;
    var gn = Object.freeze({
        create: function() {
            var t = new a(8);
            return a != Float32Array && (t[0] = 0, t[1] = 0, t[2] = 0, t[4] = 0, t[5] = 0, t[6] = 0, t[7] = 0), t[3] = 1, t
        },
        clone: function(t) {
            var n = new a(8);
            return n[0] = t[0], n[1] = t[1], n[2] = t[2], n[3] = t[3], n[4] = t[4], n[5] = t[5], n[6] = t[6], n[7] = t[7], n
        },
        fromValues: function(t, n, r, u, e, o, i, c) {
            var h = new a(8);
            return h[0] = t, h[1] = n, h[2] = r, h[3] = u, h[4] = e, h[5] = o, h[6] = i, h[7] = c, h
        },
        fromRotationTranslationValues: function(t, n, r, u, e, o, i) {
            var c = new a(8);
            c[0] = t, c[1] = n, c[2] = r, c[3] = u;
            var h = .5 * e,
                s = .5 * o,
                M = .5 * i;
            return c[4] = h * u + s * r - M * n, c[5] = s * u + M * t - h * r, c[6] = M * u + h * n - s * t, c[7] = -h * t - s * n - M * r, c
        },
        fromRotationTranslation: Mn,
        fromTranslation: function(t, n) {
            return t[0] = 0, t[1] = 0, t[2] = 0, t[3] = 1, t[4] = .5 * n[0], t[5] = .5 * n[1], t[6] = .5 * n[2], t[7] = 0, t
        },
        fromRotation: function(t, n) {
            return t[0] = n[0], t[1] = n[1], t[2] = n[2], t[3] = n[3], t[4] = 0, t[5] = 0, t[6] = 0, t[7] = 0, t
        },
        fromMat4: function(t, n) {
            var r = jt();
            P(r, n);
            var u = new a(3);
            return R(u, n), Mn(t, r, u), t
        },
        copy: fn,
        identity: function(t) {
            return t[0] = 0, t[1] = 0, t[2] = 0, t[3] = 1, t[4] = 0, t[5] = 0, t[6] = 0, t[7] = 0, t
        },
        set: function(t, n, a, r, u, e, o, i, c) {
            return t[0] = n, t[1] = a, t[2] = r, t[3] = u, t[4] = e, t[5] = o, t[6] = i, t[7] = c, t
        },
        getReal: ln,
        getDual: function(t, n) {
            return t[0] = n[4], t[1] = n[5], t[2] = n[6], t[3] = n[7], t
        },
        setReal: vn,
        setDual: function(t, n) {
            return t[4] = n[0], t[5] = n[1], t[6] = n[2], t[7] = n[3], t
        },
        getTranslation: function(t, n) {
            var a = n[4],
                r = n[5],
                u = n[6],
                e = n[7],
                o = -n[0],
                i = -n[1],
                c = -n[2],
                h = n[3];
            return t[0] = 2 * (a * h + e * o + r * c - u * i), t[1] = 2 * (r * h + e * i + u * o - a * c), t[2] = 2 * (u * h + e * c + a * i - r * o), t
        },
        translate: function(t, n, a) {
            var r = n[0],
                u = n[1],
                e = n[2],
                o = n[3],
                i = .5 * a[0],
                c = .5 * a[1],
                h = .5 * a[2],
                s = n[4],
                M = n[5],
                f = n[6],
                l = n[7];
            return t[0] = r, t[1] = u, t[2] = e, t[3] = o, t[4] = o * i + u * h - e * c + s, t[5] = o * c + e * i - r * h + M, t[6] = o * h + r * c - u * i + f, t[7] = -r * i - u * c - e * h + l, t
        },
        rotateX: function(t, n, a) {
            var r = -n[0],
                u = -n[1],
                e = -n[2],
                o = n[3],
                i = n[4],
                c = n[5],
                h = n[6],
                s = n[7],
                M = i * o + s * r + c * e - h * u,
                f = c * o + s * u + h * r - i * e,
                l = h * o + s * e + i * u - c * r,
                v = s * o - i * r - c * u - h * e;
            return Et(t, n, a), r = t[0], u = t[1], e = t[2], o = t[3], t[4] = M * o + v * r + f * e - l * u, t[5] = f * o + v * u + l * r - M * e, t[6] = l * o + v * e + M * u - f * r, t[7] = v * o - M * r - f * u - l * e, t
        },
        rotateY: function(t, n, a) {
            var r = -n[0],
                u = -n[1],
                e = -n[2],
                o = n[3],
                i = n[4],
                c = n[5],
                h = n[6],
                s = n[7],
                M = i * o + s * r + c * e - h * u,
                f = c * o + s * u + h * r - i * e,
                l = h * o + s * e + i * u - c * r,
                v = s * o - i * r - c * u - h * e;
            return Ot(t, n, a), r = t[0], u = t[1], e = t[2], o = t[3], t[4] = M * o + v * r + f * e - l * u, t[5] = f * o + v * u + l * r - M * e, t[6] = l * o + v * e + M * u - f * r, t[7] = v * o - M * r - f * u - l * e, t
        },
        rotateZ: function(t, n, a) {
            var r = -n[0],
                u = -n[1],
                e = -n[2],
                o = n[3],
                i = n[4],
                c = n[5],
                h = n[6],
                s = n[7],
                M = i * o + s * r + c * e - h * u,
                f = c * o + s * u + h * r - i * e,
                l = h * o + s * e + i * u - c * r,
                v = s * o - i * r - c * u - h * e;
            return Tt(t, n, a), r = t[0], u = t[1], e = t[2], o = t[3], t[4] = M * o + v * r + f * e - l * u, t[5] = f * o + v * u + l * r - M * e, t[6] = l * o + v * e + M * u - f * r, t[7] = v * o - M * r - f * u - l * e, t
        },
        rotateByQuatAppend: function(t, n, a) {
            var r = a[0],
                u = a[1],
                e = a[2],
                o = a[3],
                i = n[0],
                c = n[1],
                h = n[2],
                s = n[3];
            return t[0] = i * o + s * r + c * e - h * u, t[1] = c * o + s * u + h * r - i * e, t[2] = h * o + s * e + i * u - c * r, t[3] = s * o - i * r - c * u - h * e, i = n[4], c = n[5], h = n[6], s = n[7], t[4] = i * o + s * r + c * e - h * u, t[5] = c * o + s * u + h * r - i * e, t[6] = h * o + s * e + i * u - c * r, t[7] = s * o - i * r - c * u - h * e, t
        },
        rotateByQuatPrepend: function(t, n, a) {
            var r = n[0],
                u = n[1],
                e = n[2],
                o = n[3],
                i = a[0],
                c = a[1],
                h = a[2],
                s = a[3];
            return t[0] = r * s + o * i + u * h - e * c, t[1] = u * s + o * c + e * i - r * h, t[2] = e * s + o * h + r * c - u * i, t[3] = o * s - r * i - u * c - e * h, i = a[4], c = a[5], h = a[6], s = a[7], t[4] = r * s + o * i + u * h - e * c, t[5] = u * s + o * c + e * i - r * h, t[6] = e * s + o * h + r * c - u * i, t[7] = o * s - r * i - u * c - e * h, t
        },
        rotateAroundAxis: function(t, a, r, u) {
            if (Math.abs(u) < n) return fn(t, a);
            var e = Math.hypot(r[0], r[1], r[2]);
            u *= .5;
            var o = Math.sin(u),
                i = o * r[0] / e,
                c = o * r[1] / e,
                h = o * r[2] / e,
                s = Math.cos(u),
                M = a[0],
                f = a[1],
                l = a[2],
                v = a[3];
            t[0] = M * s + v * i + f * h - l * c, t[1] = f * s + v * c + l * i - M * h, t[2] = l * s + v * h + M * c - f * i, t[3] = v * s - M * i - f * c - l * h;
            var b = a[4],
                m = a[5],
                d = a[6],
                x = a[7];
            return t[4] = b * s + x * i + m * h - d * c, t[5] = m * s + x * c + d * i - b * h, t[6] = d * s + x * h + b * c - m * i, t[7] = x * s - b * i - m * c - d * h, t
        },
        add: function(t, n, a) {
            return t[0] = n[0] + a[0], t[1] = n[1] + a[1], t[2] = n[2] + a[2], t[3] = n[3] + a[3], t[4] = n[4] + a[4], t[5] = n[5] + a[5], t[6] = n[6] + a[6], t[7] = n[7] + a[7], t
        },
        multiply: bn,
        mul: mn,
        scale: function(t, n, a) {
            return t[0] = n[0] * a, t[1] = n[1] * a, t[2] = n[2] * a, t[3] = n[3] * a, t[4] = n[4] * a, t[5] = n[5] * a, t[6] = n[6] * a, t[7] = n[7] * a, t
        },
        dot: dn,
        lerp: function(t, n, a, r) {
            var u = 1 - r;
            return dn(n, a) < 0 && (r = -r), t[0] = n[0] * u + a[0] * r, t[1] = n[1] * u + a[1] * r, t[2] = n[2] * u + a[2] * r, t[3] = n[3] * u + a[3] * r, t[4] = n[4] * u + a[4] * r, t[5] = n[5] * u + a[5] * r, t[6] = n[6] * u + a[6] * r, t[7] = n[7] * u + a[7] * r, t
        },
        invert: function(t, n) {
            var a = yn(n);
            return t[0] = -n[0] / a, t[1] = -n[1] / a, t[2] = -n[2] / a, t[3] = n[3] / a, t[4] = -n[4] / a, t[5] = -n[5] / a, t[6] = -n[6] / a, t[7] = n[7] / a, t
        },
        conjugate: function(t, n) {
            return t[0] = -n[0], t[1] = -n[1], t[2] = -n[2], t[3] = n[3], t[4] = -n[4], t[5] = -n[5], t[6] = -n[6], t[7] = n[7], t
        },
        length: xn,
        len: pn,
        squaredLength: yn,
        sqrLen: qn,
        normalize: function(t, n) {
            var a = yn(n);
            if (a > 0) {
                a = Math.sqrt(a);
                var r = n[0] / a,
                    u = n[1] / a,
                    e = n[2] / a,
                    o = n[3] / a,
                    i = n[4],
                    c = n[5],
                    h = n[6],
                    s = n[7],
                    M = r * i + u * c + e * h + o * s;
                t[0] = r, t[1] = u, t[2] = e, t[3] = o, t[4] = (i - r * M) / a, t[5] = (c - u * M) / a, t[6] = (h - e * M) / a, t[7] = (s - o * M) / a
            }
            return t
        },
        str: function(t) {
            return "quat2(" + t[0] + ", " + t[1] + ", " + t[2] + ", " + t[3] + ", " + t[4] + ", " + t[5] + ", " + t[6] + ", " + t[7] + ")"
        },
        exactEquals: function(t, n) {
            return t[0] === n[0] && t[1] === n[1] && t[2] === n[2] && t[3] === n[3] && t[4] === n[4] && t[5] === n[5] && t[6] === n[6] && t[7] === n[7]
        },
        equals: function(t, a) {
            var r = t[0],
                u = t[1],
                e = t[2],
                o = t[3],
                i = t[4],
                c = t[5],
                h = t[6],
                s = t[7],
                M = a[0],
                f = a[1],
                l = a[2],
                v = a[3],
                b = a[4],
                m = a[5],
                d = a[6],
                x = a[7];
            return Math.abs(r - M) <= n * Math.max(1, Math.abs(r), Math.abs(M)) && Math.abs(u - f) <= n * Math.max(1, Math.abs(u), Math.abs(f)) && Math.abs(e - l) <= n * Math.max(1, Math.abs(e), Math.abs(l)) && Math.abs(o - v) <= n * Math.max(1, Math.abs(o), Math.abs(v)) && Math.abs(i - b) <= n * Math.max(1, Math.abs(i), Math.abs(b)) && Math.abs(c - m) <= n * Math.max(1, Math.abs(c), Math.abs(m)) && Math.abs(h - d) <= n * Math.max(1, Math.abs(h), Math.abs(d)) && Math.abs(s - x) <= n * Math.max(1, Math.abs(s), Math.abs(x))
        }
    });

    function An() {
        var t = new a(2);
        return a != Float32Array && (t[0] = 0, t[1] = 0), t
    }

    function wn(t, n, a) {
        return t[0] = n[0] - a[0], t[1] = n[1] - a[1], t
    }

    function Rn(t, n, a) {
        return t[0] = n[0] * a[0], t[1] = n[1] * a[1], t
    }

    function zn(t, n, a) {
        return t[0] = n[0] / a[0], t[1] = n[1] / a[1], t
    }

    function Pn(t, n) {
        var a = n[0] - t[0],
            r = n[1] - t[1];
        return Math.hypot(a, r)
    }

    function jn(t, n) {
        var a = n[0] - t[0],
            r = n[1] - t[1];
        return a * a + r * r
    }

    function In(t) {
        var n = t[0],
            a = t[1];
        return Math.hypot(n, a)
    }

    function Sn(t) {
        var n = t[0],
            a = t[1];
        return n * n + a * a
    }
    var En = In,
        On = wn,
        Tn = Rn,
        Dn = zn,
        Fn = Pn,
        Ln = jn,
        Vn = Sn,
        Qn = function() {
            var t = An();
            return function(n, a, r, u, e, o) {
                var i, c;
                for (a || (a = 2), r || (r = 0), c = u ? Math.min(u * a + r, n.length) : n.length, i = r; i < c; i += a) t[0] = n[i], t[1] = n[i + 1], e(t, t, o), n[i] = t[0], n[i + 1] = t[1];
                return n
            }
        }(),
        Yn = Object.freeze({
            create: An,
            clone: function(t) {
                var n = new a(2);
                return n[0] = t[0], n[1] = t[1], n
            },
            fromValues: function(t, n) {
                var r = new a(2);
                return r[0] = t, r[1] = n, r
            },
            copy: function(t, n) {
                return t[0] = n[0], t[1] = n[1], t
            },
            set: function(t, n, a) {
                return t[0] = n, t[1] = a, t
            },
            add: function(t, n, a) {
                return t[0] = n[0] + a[0], t[1] = n[1] + a[1], t
            },
            subtract: wn,
            multiply: Rn,
            divide: zn,
            ceil: function(t, n) {
                return t[0] = Math.ceil(n[0]), t[1] = Math.ceil(n[1]), t
            },
            floor: function(t, n) {
                return t[0] = Math.floor(n[0]), t[1] = Math.floor(n[1]), t
            },
            min: function(t, n, a) {
                return t[0] = Math.min(n[0], a[0]), t[1] = Math.min(n[1], a[1]), t
            },
            max: function(t, n, a) {
                return t[0] = Math.max(n[0], a[0]), t[1] = Math.max(n[1], a[1]), t
            },
            round: function(t, n) {
                return t[0] = Math.round(n[0]), t[1] = Math.round(n[1]), t
            },
            scale: function(t, n, a) {
                return t[0] = n[0] * a, t[1] = n[1] * a, t
            },
            scaleAndAdd: function(t, n, a, r) {
                return t[0] = n[0] + a[0] * r, t[1] = n[1] + a[1] * r, t
            },
            distance: Pn,
            squaredDistance: jn,
            length: In,
            squaredLength: Sn,
            negate: function(t, n) {
                return t[0] = -n[0], t[1] = -n[1], t
            },
            inverse: function(t, n) {
                return t[0] = 1 / n[0], t[1] = 1 / n[1], t
            },
            normalize: function(t, n) {
                var a = n[0],
                    r = n[1],
                    u = a * a + r * r;
                return u > 0 && (u = 1 / Math.sqrt(u)), t[0] = n[0] * u, t[1] = n[1] * u, t
            },
            dot: function(t, n) {
                return t[0] * n[0] + t[1] * n[1]
            },
            cross: function(t, n, a) {
                var r = n[0] * a[1] - n[1] * a[0];
                return t[0] = t[1] = 0, t[2] = r, t
            },
            lerp: function(t, n, a, r) {
                var u = n[0],
                    e = n[1];
                return t[0] = u + r * (a[0] - u), t[1] = e + r * (a[1] - e), t
            },
            random: function(t, n) {
                n = n || 1;
                var a = 2 * r() * Math.PI;
                return t[0] = Math.cos(a) * n, t[1] = Math.sin(a) * n, t
            },
            transformMat2: function(t, n, a) {
                var r = n[0],
                    u = n[1];
                return t[0] = a[0] * r + a[2] * u, t[1] = a[1] * r + a[3] * u, t
            },
            transformMat2d: function(t, n, a) {
                var r = n[0],
                    u = n[1];
                return t[0] = a[0] * r + a[2] * u + a[4], t[1] = a[1] * r + a[3] * u + a[5], t
            },
            transformMat3: function(t, n, a) {
                var r = n[0],
                    u = n[1];
                return t[0] = a[0] * r + a[3] * u + a[6], t[1] = a[1] * r + a[4] * u + a[7], t
            },
            transformMat4: function(t, n, a) {
                var r = n[0],
                    u = n[1];
                return t[0] = a[0] * r + a[4] * u + a[12], t[1] = a[1] * r + a[5] * u + a[13], t
            },
            rotate: function(t, n, a, r) {
                var u = n[0] - a[0],
                    e = n[1] - a[1],
                    o = Math.sin(r),
                    i = Math.cos(r);
                return t[0] = u * i - e * o + a[0], t[1] = u * o + e * i + a[1], t
            },
            angle: function(t, n) {
                var a = t[0],
                    r = t[1],
                    u = n[0],
                    e = n[1],
                    o = a * a + r * r;
                o > 0 && (o = 1 / Math.sqrt(o));
                var i = u * u + e * e;
                i > 0 && (i = 1 / Math.sqrt(i));
                var c = (a * u + r * e) * o * i;
                return c > 1 ? 0 : c < -1 ? Math.PI : Math.acos(c)
            },
            zero: function(t) {
                return t[0] = 0, t[1] = 0, t
            },
            str: function(t) {
                return "vec2(" + t[0] + ", " + t[1] + ")"
            },
            exactEquals: function(t, n) {
                return t[0] === n[0] && t[1] === n[1]
            },
            equals: function(t, a) {
                var r = t[0],
                    u = t[1],
                    e = a[0],
                    o = a[1];
                return Math.abs(r - e) <= n * Math.max(1, Math.abs(r), Math.abs(e)) && Math.abs(u - o) <= n * Math.max(1, Math.abs(u), Math.abs(o))
            },
            len: En,
            sub: On,
            mul: Tn,
            div: Dn,
            dist: Fn,
            sqrDist: Ln,
            sqrLen: Vn,
            forEach: Qn
        });
    t.glMatrix = e, t.mat2 = s, t.mat2d = b, t.mat3 = q, t.mat4 = E, t.quat = sn, t.quat2 = gn, t.vec2 = Yn, t.vec3 = $, t.vec4 = Pt, Object.defineProperty(t, "__esModule", {
        value: !0
    })
});

// ["glMatrix", "mat2", "mat2d", "mat3", "mat4", "quat", "quat2", "vec2", "vec3", "vec4"]
window.glMatrix = glMatrix;
window.mat2 = glMatrix.mat2;
window.mat2d = glMatrix.mat2d;
window.mat3 = glMatrix.mat3;
window.mat4 = glMatrix.mat4;
window.quat = glMatrix.quat;
window.quat2 = glMatrix.quat2;
window.vec2 = glMatrix.vec2;
window.vec3 = glMatrix.vec3;
window.vec4 = glMatrix.vec4;



var CABLES = CABLES || {};
CABLES.build = {
    "timestamp": 1695294497050,
    "created": "2023-09-21T11:08:17.050Z",
    "git": {
        "branch": "master",
        "commit": "2577d0ec3e00ecb48fef52a0280a3c9069cf3fd5",
        "date": "2023-09-14T10:27:49.000Z",
        "message": "release - update docs"
    }
};
if (!CABLES.exportedPatches) CABLES.exportedPatches = {};
CABLES.exportedPatches["kgLqgI"] = {
    ops: [{
        id: "92d0de56-4ac5-44da-9cd7-e9954600115e",
        uiAttribs: {},
        portsIn: [{
            name: "FPS Limit",
            value: 60
        }, {
            name: "Reduce FPS not focussed",
            value: true
        }, {
            name: "Reduce FPS loading",
            value: false
        }, {
            name: "Clear",
            value: true
        }, {
            name: "ClearAlpha",
            value: true
        }, {
            name: "Fullscreen Button",
            value: false
        }, {
            name: "Active",
            value: true
        }, {
            name: "Hires Displays",
            value: false
        }, {
            name: "Pixel Unit index",
            value: 0
        }, {
            name: "Pixel Unit",
            value: "Display"
        }],
        portsOut: [{
            name: "trigger",
            links: [{
                portIn: "Execute",
                portOut: "trigger",
                objIn: "549252ab-8cd8-4eb2-8234-21267d7e39e0",
                objOut: "92d0de56-4ac5-44da-9cd7-e9954600115e"
            }, {
                portIn: "render",
                portOut: "trigger",
                objIn: "3c1fe7ab-4b1a-4880-8c64-423abcf25cd0",
                objOut: "92d0de56-4ac5-44da-9cd7-e9954600115e"
            }, {
                portIn: "Render",
                portOut: "trigger",
                objIn: "83ba7487-ccae-4ff8-a28f-16223e01d4f6",
                objOut: "92d0de56-4ac5-44da-9cd7-e9954600115e"
            }, {
                portIn: "Exec",
                portOut: "trigger",
                objIn: "d275cb61-bb03-404e-877f-cf48bccce099",
                objOut: "92d0de56-4ac5-44da-9cd7-e9954600115e"
            }, {
                portIn: "Render",
                portOut: "trigger",
                objIn: "07504819-e523-4aee-b261-15e6871047d0",
                objOut: "92d0de56-4ac5-44da-9cd7-e9954600115e"
            }, {
                portIn: "Render",
                portOut: "trigger",
                objIn: "d1dcb3c6-5ee1-4a70-bac5-2b012acc16e8",
                objOut: "92d0de56-4ac5-44da-9cd7-e9954600115e"
            }, {
                portIn: "Render",
                portOut: "trigger",
                objIn: "c6b656bf-1431-43e0-87a7-8b9784d5a4c8",
                objOut: "92d0de56-4ac5-44da-9cd7-e9954600115e"
            }]
        }, {
            name: "width",
            value: 721
        }, {
            name: "height",
            value: 320
        }],
        objName: "Ops.Gl.MainLoop"
    }, {
        id: "1d772810-f301-4f14-b0f5-8e1a35f370b6",
        uiAttribs: {},
        portsIn: [{
            name: "value",
            value: "https://api.coinbase.com/v2/exchange-rates?currency=BTC"
        }, {
            name: "Syntax index",
            value: 0
        }, {
            name: "Syntax",
            value: "text"
        }],
        portsOut: [{
            name: "Result",
            links: [{
                portIn: "file",
                portOut: "Result",
                objIn: "6a1ba9b2-4d54-4b3b-8be2-8eb31a2b57af",
                objOut: "1d772810-f301-4f14-b0f5-8e1a35f370b6"
            }]
        }],
        objName: "Ops.String.StringEditor"
    }, {
        id: "3c1fe7ab-4b1a-4880-8c64-423abcf25cd0",
        uiAttribs: {},
        portsIn: [{
            name: "render"
        }, {
            name: "min distance",
            value: .05
        }, {
            name: "max distance",
            value: 99999
        }, {
            name: "min rot y",
            value: 0
        }, {
            name: "max rot y",
            value: 0
        }, {
            name: "initial radius",
            value: .05
        }, {
            name: "initial axis y",
            value: .5
        }, {
            name: "initial axis x",
            value: .25
        }, {
            name: "mul",
            value: 1
        }, {
            name: "Smoothness",
            value: 1
        }, {
            name: "Speed X",
            value: 1
        }, {
            name: "Speed Y",
            value: 1
        }, {
            name: "Active",
            value: true
        }, {
            name: "Allow Panning",
            value: true
        }, {
            name: "Allow Zooming",
            value: true
        }, {
            name: "Allow Rotation",
            value: true
        }, {
            name: "restricted",
            value: true
        }, {
            name: "Reset",
            value: 0
        }],
        portsOut: [{
            name: "trigger",
            links: [{
                portIn: "Render",
                portOut: "trigger",
                objIn: "37417441-63b4-493a-85c3-ff146cda4e1b",
                objOut: "3c1fe7ab-4b1a-4880-8c64-423abcf25cd0"
            }, {
                portIn: "Render",
                portOut: "trigger",
                objIn: "f54bfdbb-12ae-4da8-8248-b74b4476dd15",
                objOut: "3c1fe7ab-4b1a-4880-8c64-423abcf25cd0"
            }]
        }, {
            name: "radius",
            value: .05
        }, {
            name: "Rot X",
            value: -54.97469538829355
        }, {
            name: "Rot Y",
            value: 85.98856475830075
        }],
        objName: "Ops.Gl.Matrix.OrbitControls"
    }, {
        id: "8d445008-5a5f-42d0-88fd-428da06d8f27",
        uiAttribs: {},
        portsIn: [{
            name: "Render",
            value: null
        }, {
            name: "Render Mesh",
            value: true
        }, {
            name: "Width"
        }, {
            name: "Length",
            value: 1
        }, {
            name: "Height",
            value: 1
        }, {
            name: "Center",
            value: true
        }, {
            name: "Mapping index",
            value: 0
        }, {
            name: "Mapping",
            value: "Side"
        }, {
            name: "Bias",
            value: 0
        }, {
            name: "Flip X",
            value: true
        }, {
            name: "Top",
            value: true
        }, {
            name: "Bottom",
            value: true
        }, {
            name: "Left",
            value: true
        }, {
            name: "Right",
            value: true
        }, {
            name: "Front",
            value: true
        }, {
            name: "Back",
            value: true
        }],
        portsOut: [{
            name: "Next",
            value: 0
        }, {
            name: "geometry"
        }],
        objName: "Ops.Gl.Meshes.Cube_v2"
    }, {
        id: "6a1ba9b2-4d54-4b3b-8be2-8eb31a2b57af",
        uiAttribs: {},
        portsIn: [{
            name: "file",
            display: "file",
            title: "URL"
        }, {
            name: "JsonP",
            value: false
        }, {
            name: "headers"
        }, {
            name: "body",
            value: '$ ACCESSKEY="<Your Access Key>"\r\n$ SECRETKEY="<Your Secret Key>"\r\n$ curl -G \\\r\n    --data-urlencode "version=3" \\\r\n    --data-urlencode "prettyprint=1" \\\r\n    --data-urlencode "Z00cPXBERq" \\\r\n    --data-urlencode "Z00cPXBERq" \\\r\n    --data-urlencode "placeid=norway/oslo" \\\r\n    https://api.xmltime.com/timeservice'
        }, {
            name: "HTTP Method index",
            value: 0
        }, {
            name: "HTTP Method",
            value: "GET"
        }, {
            name: "Content-Type",
            value: "application/json"
        }, {
            name: "parse json",
            value: true
        }, {
            name: "Auto request",
            value: true
        }, {
            name: "reload"
        }],
        portsOut: [{
            name: "data",
            links: [{
                portIn: "Object",
                portOut: "data",
                objIn: "c1185cd3-1d55-47ac-bf72-1dcbe9c403ea",
                objOut: "6a1ba9b2-4d54-4b3b-8be2-8eb31a2b57af"
            }]
        }, {
            name: "response"
        }, {
            name: "Duration MS",
            value: 333
        }, {
            name: "Status Code",
            value: 200
        }, {
            name: "Is Loading",
            value: 0
        }, {
            name: "Loaded",
            value: 0
        }],
        objName: "Ops.Json.AjaxRequest_v2"
    }, {
        id: "f52c5976-b009-4a2b-94f2-0602956dcb8c",
        uiAttribs: {},
        portsIn: [{
            name: "String"
        }],
        portsOut: [{
            name: "Number",
            links: [{
                portIn: "number 0",
                portOut: "Number",
                objIn: "34e79ca7-ac4c-466d-8e04-1519e13c6291",
                objOut: "f52c5976-b009-4a2b-94f2-0602956dcb8c"
            }]
        }],
        objName: "Ops.String.ParseFloat"
    }, {
        id: "34e79ca7-ac4c-466d-8e04-1519e13c6291",
        uiAttribs: {},
        portsIn: [{
            name: "number 0"
        }, {
            name: "number 1",
            value: 1e4
        }, {
            name: "math mode index",
            value: 0
        }, {
            name: "math mode",
            value: "/"
        }],
        portsOut: [{
            name: "result",
            links: [{
                portIn: "Width",
                portOut: "result",
                objIn: "8d445008-5a5f-42d0-88fd-428da06d8f27",
                objOut: "34e79ca7-ac4c-466d-8e04-1519e13c6291"
            }]
        }],
        objName: "Ops.Math.Math"
    }, {
        id: "c6b656bf-1431-43e0-87a7-8b9784d5a4c8",
        uiAttribs: {},
        portsIn: [{
            name: "Render"
        }, {
            name: "Text"
        }, {
            name: "Scale",
            value: .4
        }, {
            name: "Font",
            value: "Arial"
        }, {
            name: "align index",
            value: 1
        }, {
            name: "align",
            value: "center"
        }, {
            name: "vertical align index",
            value: 1
        }, {
            name: "vertical align",
            value: "Middle"
        }, {
            name: "Line Height",
            value: 1
        }, {
            name: "Letter Spacing",
            value: 0
        }, {
            name: "filter index",
            value: 2
        }, {
            name: "filter",
            value: "mipmap"
        }, {
            name: "Anisotropic index",
            value: 0
        }, {
            name: "Anisotropic",
            value: 0
        }, {
            name: "Texture Color"
        }, {
            name: "Texture Mask"
        }, {
            name: "r",
            value: 1
        }, {
            name: "g",
            value: 1
        }, {
            name: "b",
            value: 1
        }, {
            name: "a",
            value: 1
        }],
        portsOut: [{
            name: "Next",
            value: 0
        }, {
            name: "texture"
        }, {
            name: "Total Lines",
            value: 1
        }, {
            name: "Width",
            value: .45582275390625
        }, {
            name: "Font Available",
            value: 0
        }],
        objName: "Ops.Gl.Meshes.TextMesh_v2"
    }, {
        id: "c1185cd3-1d55-47ac-bf72-1dcbe9c403ea",
        uiAttribs: {},
        portsIn: [{
            name: "Object"
        }, {
            name: "Path",
            value: "data.rates.USD"
        }, {
            name: "Output path if missing",
            value: false
        }],
        portsOut: [{
            name: "Output",
            links: [{
                portIn: "Text",
                portOut: "Output",
                objIn: "c6b656bf-1431-43e0-87a7-8b9784d5a4c8",
                objOut: "c1185cd3-1d55-47ac-bf72-1dcbe9c403ea"
            }, {
                portIn: "String",
                portOut: "Output",
                objIn: "f52c5976-b009-4a2b-94f2-0602956dcb8c",
                objOut: "c1185cd3-1d55-47ac-bf72-1dcbe9c403ea"
            }]
        }, {
            name: "Found",
            value: true
        }],
        objName: "Ops.Json.ObjectGetStringByPath"
    }, {
        id: "549252ab-8cd8-4eb2-8234-21267d7e39e0",
        uiAttribs: {},
        portsIn: [{
            name: "Execute"
        }, {
            name: "Nth",
            value: 1
        }],
        portsOut: [{
            name: "Next",
            links: [{
                portIn: "reload",
                portOut: "Next",
                objIn: "6a1ba9b2-4d54-4b3b-8be2-8eb31a2b57af",
                objOut: "549252ab-8cd8-4eb2-8234-21267d7e39e0"
            }]
        }],
        objName: "Ops.Trigger.NthTrigger_v2"
    }, {
        id: "83ba7487-ccae-4ff8-a28f-16223e01d4f6",
        uiAttribs: {},
        portsIn: [{
            name: "Render"
        }, {
            name: "Text"
        }, {
            name: "Scale",
            value: .38
        }, {
            name: "Font",
            value: "Arial"
        }, {
            name: "align index",
            value: 1
        }, {
            name: "align",
            value: "center"
        }, {
            name: "vertical align index",
            value: 1
        }, {
            name: "vertical align",
            value: "Top"
        }, {
            name: "Line Height",
            value: 1
        }, {
            name: "Letter Spacing",
            value: 0
        }, {
            name: "filter index",
            value: 2
        }, {
            name: "filter",
            value: "mipmap"
        }, {
            name: "Anisotropic index",
            value: 0
        }, {
            name: "Anisotropic",
            value: 0
        }, {
            name: "Texture Color"
        }, {
            name: "Texture Mask"
        }, {
            name: "r",
            value: 1
        }, {
            name: "g",
            value: 1
        }, {
            name: "b",
            value: 1
        }, {
            name: "a",
            value: 1
        }],
        portsOut: [{
            name: "Next",
            links: [{
                portIn: "render",
                portOut: "Next",
                objIn: "23acb7cc-74f2-40b9-926d-f15d899744d7",
                objOut: "83ba7487-ccae-4ff8-a28f-16223e01d4f6"
            }]
        }, {
            name: "texture"
        }, {
            name: "Total Lines",
            value: 1
        }, {
            name: "Width",
            value: .79970703125
        }, {
            name: "Font Available",
            value: 1
        }],
        objName: "Ops.Gl.Meshes.TextMesh_v2"
    }, {
        id: "3fcf9d4f-a9f0-4408-8a3f-a8a204b4587c",
        uiAttribs: {},
        portsIn: [{
            name: "Render",
            value: 0
        }, {
            name: "data",
            value: ""
        }, {
            name: "glb File",
            value: "assets/to_rhino.glb",
            display: "file"
        }, {
            name: "Draw",
            value: true
        }, {
            name: "Camera index",
            value: 0
        }, {
            name: "Camera",
            value: "None"
        }, {
            name: "Animation",
            value: ""
        }, {
            name: "Show Structure",
            value: 0
        }, {
            name: "Center index",
            value: 1
        }, {
            name: "Center",
            value: "XYZ"
        }, {
            name: "Rescale",
            value: true
        }, {
            name: "Rescale Size",
            value: 2.5
        }, {
            name: "Time",
            value: 0
        }, {
            name: "Sync to timeline",
            value: false
        }, {
            name: "Loop",
            value: true
        }, {
            name: "Normals Format index",
            value: 0
        }, {
            name: "Normals Format",
            value: "XYZ"
        }, {
            name: "Vertices Format index",
            value: 0
        }, {
            name: "Vertices Format",
            value: "XYZ"
        }, {
            name: "Calc Normals index",
            value: 0
        }, {
            name: "Calc Normals",
            value: "Auto"
        }, {
            name: "Materials"
        }, {
            name: "Hide Nodes",
            value: 0
        }, {
            name: "Use Material Properties",
            value: true
        }, {
            name: "Active",
            value: true
        }],
        portsOut: [{
            name: "Render Before",
            value: 0
        }, {
            name: "Next",
            value: 0
        }, {
            name: "Generator",
            value: "3D Builder"
        }, {
            name: "GLTF Version",
            value: 2
        }, {
            name: "GLTF Extensions Used"
        }, {
            name: "Anim Length",
            value: 0
        }, {
            name: "Anim Time",
            value: 0
        }, {
            name: "Json"
        }, {
            name: "Anims"
        }, {
            name: "BoundingPoints"
        }, {
            name: "Bounds"
        }, {
            name: "Finished",
            value: 0
        }, {
            name: "Loading",
            value: false
        }],
        objName: "Ops.Gl.GLTF.GltfScene_v4"
    }, {
        id: "367c0fc6-726f-4a0d-acb1-cde9b37b3bf5",
        uiAttribs: {},
        portsIn: [{
            name: "Render",
            value: 0
        }, {
            name: "data",
            value: ""
        }, {
            name: "glb File",
            value: "assets/to_rhino.glb",
            display: "file"
        }, {
            name: "Draw",
            value: true
        }, {
            name: "Camera index",
            value: 0
        }, {
            name: "Camera",
            value: "None"
        }, {
            name: "Animation",
            value: ""
        }, {
            name: "Show Structure",
            value: 0
        }, {
            name: "Center index",
            value: 1
        }, {
            name: "Center",
            value: "XYZ"
        }, {
            name: "Rescale",
            value: true
        }, {
            name: "Rescale Size",
            value: 2.5
        }, {
            name: "Time",
            value: 0
        }, {
            name: "Sync to timeline",
            value: false
        }, {
            name: "Loop",
            value: true
        }, {
            name: "Normals Format index",
            value: 0
        }, {
            name: "Normals Format",
            value: "XYZ"
        }, {
            name: "Vertices Format index",
            value: 0
        }, {
            name: "Vertices Format",
            value: "XYZ"
        }, {
            name: "Calc Normals index",
            value: 0
        }, {
            name: "Calc Normals",
            value: "Auto"
        }, {
            name: "Materials"
        }, {
            name: "Hide Nodes",
            value: 0
        }, {
            name: "Use Material Properties",
            value: true
        }, {
            name: "Active",
            value: true
        }],
        portsOut: [{
            name: "Render Before",
            value: 0
        }, {
            name: "Next",
            value: 0
        }, {
            name: "Generator",
            value: "3D Builder"
        }, {
            name: "GLTF Version",
            value: 2
        }, {
            name: "GLTF Extensions Used"
        }, {
            name: "Anim Length",
            value: 0
        }, {
            name: "Anim Time",
            value: 0
        }, {
            name: "Json"
        }, {
            name: "Anims"
        }, {
            name: "BoundingPoints"
        }, {
            name: "Bounds"
        }, {
            name: "Finished",
            value: 0
        }, {
            name: "Loading",
            value: false
        }],
        objName: "Ops.Gl.GLTF.GltfScene_v4"
    }, {
        id: "37417441-63b4-493a-85c3-ff146cda4e1b",
        uiAttribs: {},
        portsIn: [{
            name: "Render"
        }, {
            name: "data",
            value: ""
        }, {
            name: "glb File",
            value: "assets/to_rhino2.glb",
            display: "file"
        }, {
            name: "Draw",
            value: true
        }, {
            name: "Camera index",
            value: 0
        }, {
            name: "Camera",
            value: "None"
        }, {
            name: "Animation",
            value: ""
        }, {
            name: "Show Structure",
            value: null
        }, {
            name: "Center index",
            value: 1
        }, {
            name: "Center",
            value: "XYZ"
        }, {
            name: "Rescale",
            value: true
        }, {
            name: "Rescale Size",
            value: 2.5
        }, {
            name: "Time",
            value: 0
        }, {
            name: "Sync to timeline",
            value: false
        }, {
            name: "Loop",
            value: true
        }, {
            name: "Normals Format index",
            value: 0
        }, {
            name: "Normals Format",
            value: "XYZ"
        }, {
            name: "Vertices Format index",
            value: 0
        }, {
            name: "Vertices Format",
            value: "XYZ"
        }, {
            name: "Calc Normals index",
            value: 0
        }, {
            name: "Calc Normals",
            value: "Auto"
        }, {
            name: "Materials"
        }, {
            name: "Hide Nodes",
            value: 0
        }, {
            name: "Use Material Properties",
            value: true
        }, {
            name: "Active",
            value: true
        }],
        portsOut: [{
            name: "Render Before",
            value: 0
        }, {
            name: "Next",
            value: 0
        }, {
            name: "Generator",
            value: "3D Builder"
        }, {
            name: "GLTF Version",
            value: 2
        }, {
            name: "GLTF Extensions Used"
        }, {
            name: "Anim Length",
            value: 0
        }, {
            name: "Anim Time",
            value: 0
        }, {
            name: "Json"
        }, {
            name: "Anims"
        }, {
            name: "BoundingPoints"
        }, {
            name: "Bounds"
        }, {
            name: "Finished",
            value: 0
        }, {
            name: "Loading",
            value: false
        }],
        objName: "Ops.Gl.GLTF.GltfScene_v4"
    }, {
        id: "26e89b6c-98e8-43fc-af33-50286ecf7538",
        uiAttribs: {},
        portsIn: [{
            name: "Visible",
            value: true
        }, {
            name: "Opacity",
            value: 1
        }, {
            name: "Default Minimized",
            value: false
        }, {
            name: "Minimized Opacity",
            value: .5
        }, {
            name: "Show undo button",
            value: false
        }, {
            name: "Show Minimize",
            value: false
        }, {
            name: "Title",
            value: "Data art"
        }, {
            name: "Side",
            value: false
        }],
        portsOut: [{
            name: "childs",
            title: "Children",
            links: [{
                portIn: "Link",
                portOut: "childs",
                objIn: "e10902fc-8e44-451a-99c5-03f31d71e223",
                objOut: "26e89b6c-98e8-43fc-af33-50286ecf7538"
            }]
        }, {
            name: "Opfened",
            value: true,
            title: "Opened"
        }],
        objName: "Ops.Sidebar.Sidebar"
    }, {
        id: "e10902fc-8e44-451a-99c5-03f31d71e223",
        uiAttribs: {},
        portsIn: [{
            name: "Link"
        }, {
            name: "Text",
            value: "Name"
        }, {
            name: "Default",
            value: "Ameen Insan"
        }, {
            name: "Placeholder",
            value: ""
        }, {
            name: "Type index",
            value: 0
        }, {
            name: "Type",
            value: "text"
        }, {
            name: "TextArea",
            value: false
        }, {
            name: "Grey Out",
            value: false
        }, {
            name: "Visible",
            value: true
        }, {
            name: "Clear",
            value: null
        }],
        portsOut: [{
            name: "Children",
            links: [{
                portIn: "link",
                portOut: "Children",
                objIn: "5b454a1a-6452-439b-a776-ed836b5c4bdc",
                objOut: "e10902fc-8e44-451a-99c5-03f31d71e223"
            }]
        }, {
            name: "Result",
            links: [{
                portIn: "Text",
                portOut: "Result",
                objIn: "83ba7487-ccae-4ff8-a28f-16223e01d4f6",
                objOut: "e10902fc-8e44-451a-99c5-03f31d71e223"
            }]
        }, {
            name: "Focus",
            value: false
        }],
        objName: "Ops.Sidebar.TextInput_v2"
    }, {
        id: "e1a0d2f8-145c-46cf-a5cc-dfe09c886b3e",
        uiAttribs: {},
        portsIn: [{
            name: "Year",
            value: 0
        }, {
            name: "Month",
            value: 0
        }, {
            name: "Day",
            value: 0
        }, {
            name: "Hour",
            value: 0
        }, {
            name: "Minute",
            value: 0
        }],
        portsOut: [{
            name: "Timestamp",
            value: 0
        }],
        objName: "Ops.Date.DateTimestamp"
    }, {
        id: "5b454a1a-6452-439b-a776-ed836b5c4bdc",
        uiAttribs: {},
        portsIn: [{
            name: "link"
        }, {
            name: "Width",
            value: 212
        }, {
            name: "Round Corners",
            value: -9.33
        }, {
            name: "Special Color",
            value: "#rgb(90,183,241)"
        }],
        portsOut: [{
            name: "childs",
            links: [{
                portIn: "link",
                portOut: "childs",
                objIn: "ea6d30a2-4d5b-4c48-8683-cc2b6c0b0d0d",
                objOut: "5b454a1a-6452-439b-a776-ed836b5c4bdc"
            }, {
                portIn: "Link",
                portOut: "childs",
                objIn: "cb69e5ac-0c2e-4417-be96-f0237292287a",
                objOut: "5b454a1a-6452-439b-a776-ed836b5c4bdc"
            }]
        }],
        objName: "Ops.Sidebar.SideBarStyle"
    }, {
        id: "ea6d30a2-4d5b-4c48-8683-cc2b6c0b0d0d",
        uiAttribs: {},
        portsIn: [{
            name: "link"
        }, {
            name: "Names"
        }, {
            name: "Style index",
            value: 1
        }, {
            name: "Style",
            value: "Switch"
        }, {
            name: "Text",
            value: "Person"
        }, {
            name: "Input",
            value: 22
        }, {
            name: "Set Default",
            value: null
        }, {
            name: "Grey Out",
            value: false
        }, {
            name: "Default",
            value: 3
        }],
        portsOut: [{
            name: "childs"
        }, {
            name: "Index",
            value: 0
        }, {
            name: "String",
            value: "Cat"
        }],
        objName: "Ops.Sidebar.SideBarSwitch"
    }, {
        id: "cb69e5ac-0c2e-4417-be96-f0237292287a",
        uiAttribs: {},
        portsIn: [{
            name: "Link"
        }, {
            name: "Text",
            value: "Age"
        }, {
            name: "Input",
            value: 11
        }, {
            name: "Set Default",
            value: 0
        }, {
            name: "Default",
            value: 0
        }],
        portsOut: [{
            name: "Children",
            links: [{
                portIn: "Link",
                portOut: "Children",
                objIn: "37cd0323-322f-4e24-8b22-ffbf4ec7f850",
                objOut: "cb69e5ac-0c2e-4417-be96-f0237292287a"
            }]
        }, {
            name: "Result",
            links: [{
                portIn: "Sides",
                portOut: "Result",
                objIn: "4a2e00bd-d526-4d8b-ab0e-7101b5b3587d",
                objOut: "cb69e5ac-0c2e-4417-be96-f0237292287a"
            }]
        }],
        objName: "Ops.Sidebar.NumberInput_v2"
    }, {
        id: "37cd0323-322f-4e24-8b22-ffbf4ec7f850",
        uiAttribs: {},
        portsIn: [{
            name: "Link"
        }, {
            name: "Text",
            value: "Favourite color"
        }, {
            name: "Input Red",
            value: .5215686274509804
        }, {
            name: "Input Green",
            value: .8980392156862745
        }, {
            name: "Input Blue",
            value: .7333333333333333
        }, {
            name: "Set Default",
            value: 0
        }, {
            name: "Default",
            value: "#07F78C"
        }],
        portsOut: [{
            name: "Children",
            links: [{
                portIn: "link",
                portOut: "Children",
                objIn: "b0f10b57-541c-4905-871c-f9c60f7995df",
                objOut: "37cd0323-322f-4e24-8b22-ffbf4ec7f850"
            }]
        }, {
            name: "Red",
            value: .5215686274509804
        }, {
            name: "Green",
            value: .8980392156862745
        }, {
            name: "Blue",
            value: .7333333333333333
        }, {
            name: "Hex",
            value: "#85e5bb"
        }],
        objName: "Ops.Sidebar.ColorPicker_v3"
    }, {
        id: "3b258ed3-87d8-4632-ac24-87d9b30ff3a1",
        uiAttribs: {},
        portsIn: [{
            name: "text"
        }, {
            name: "separator",
            value: ","
        }, {
            name: "Numbers",
            value: false
        }, {
            name: "Trim",
            value: true
        }, {
            name: "Split Lines",
            value: false
        }],
        portsOut: [{
            name: "Parsed",
            value: 0
        }, {
            name: "array",
            links: [{
                portIn: "Names",
                portOut: "array",
                objIn: "ea6d30a2-4d5b-4c48-8683-cc2b6c0b0d0d",
                objOut: "3b258ed3-87d8-4632-ac24-87d9b30ff3a1"
            }]
        }, {
            name: "length",
            value: 2
        }],
        objName: "Ops.Array.StringToArray_v2"
    }, {
        id: "1ce79283-01c5-4e43-9eef-6e46f822bf21",
        uiAttribs: {},
        portsIn: [{
            name: "value",
            value: "Cat, Dog"
        }],
        portsOut: [{
            name: "String",
            links: [{
                portIn: "text",
                portOut: "String",
                objIn: "3b258ed3-87d8-4632-ac24-87d9b30ff3a1",
                objOut: "1ce79283-01c5-4e43-9eef-6e46f822bf21"
            }]
        }],
        objName: "Ops.String.String_v2"
    }, {
        id: "f54bfdbb-12ae-4da8-8248-b74b4476dd15",
        uiAttribs: {},
        portsIn: [{
            name: "Render"
        }, {
            name: "Render Mesh",
            value: true
        }, {
            name: "Width",
            value: 1.61
        }, {
            name: "Length",
            value: 1.12
        }, {
            name: "Height",
            value: .22
        }, {
            name: "Center",
            value: true
        }, {
            name: "Mapping index",
            value: 0
        }, {
            name: "Mapping",
            value: "Side"
        }, {
            name: "Bias",
            value: 0
        }, {
            name: "Flip X",
            value: true
        }, {
            name: "Top",
            value: true
        }, {
            name: "Bottom",
            value: true
        }, {
            name: "Left",
            value: true
        }, {
            name: "Right",
            value: true
        }, {
            name: "Front",
            value: true
        }, {
            name: "Back",
            value: true
        }],
        portsOut: [{
            name: "Next",
            value: 0
        }, {
            name: "geometry"
        }],
        objName: "Ops.Gl.Meshes.Cube_v2"
    }, {
        id: "16199bf6-96e5-4502-af1d-e6156c122145",
        uiAttribs: {},
        portsIn: [{
            name: "Filename",
            value: "cables"
        }, {
            name: "Screenshot"
        }],
        portsOut: [{
            name: "Finished",
            value: 0
        }],
        objName: "Ops.Gl.SaveScreenShot_v3"
    }, {
        id: "d275cb61-bb03-404e-877f-cf48bccce099",
        uiAttribs: {},
        portsIn: [{
            name: "Exec"
        }, {
            name: "Reset"
        }],
        portsOut: [{
            name: "Next",
            links: [{
                portIn: "Screenshot",
                portOut: "Next",
                objIn: "16199bf6-96e5-4502-af1d-e6156c122145",
                objOut: "d275cb61-bb03-404e-877f-cf48bccce099"
            }]
        }, {
            name: "Was Triggered",
            value: 1
        }],
        objName: "Ops.Trigger.TriggerOnce"
    }, {
        id: "b0f10b57-541c-4905-871c-f9c60f7995df",
        uiAttribs: {},
        portsIn: [{
            name: "link"
        }, {
            name: "Text",
            value: "Download as image"
        }, {
            name: "Grey Out",
            value: false
        }, {
            name: "Visible",
            value: true
        }],
        portsOut: [{
            name: "childs"
        }, {
            name: "Pressed Trigger",
            links: [{
                portIn: "Reset",
                portOut: "Pressed Trigger",
                objIn: "d275cb61-bb03-404e-877f-cf48bccce099",
                objOut: "b0f10b57-541c-4905-871c-f9c60f7995df"
            }]
        }],
        objName: "Ops.Sidebar.Button_v2"
    }, {
        id: "23acb7cc-74f2-40b9-926d-f15d899744d7",
        uiAttribs: {},
        portsIn: [{
            name: "render"
        }, {
            name: "Text",
            value: "Upgrade to paid"
        }, {
            name: "Letter Spacing",
            value: 1.89
        }, {
            name: "align index",
            value: 0
        }, {
            name: "align",
            value: "center"
        }, {
            name: "Render",
            value: true
        }],
        portsOut: [{
            name: "Lines"
        }],
        objName: "Ops.Gl.LineFont_v2"
    }, {
        id: "07504819-e523-4aee-b261-15e6871047d0",
        uiAttribs: {},
        portsIn: [{
            name: "Render"
        }, {
            name: "Active",
            value: true
        }, {
            name: "Generate Texture",
            value: true
        }, {
            name: "Webcam Input index",
            value: 0
        }, {
            name: "Webcam Input",
            value: "Default"
        }, {
            name: "Requested Width",
            value: 1280
        }, {
            name: "Requested Height",
            value: 720
        }, {
            name: "Flip X",
            value: false
        }, {
            name: "Flip Y",
            value: false
        }, {
            name: "Show HTML Element",
            value: false
        }, {
            name: "CSS",
            value: "z-index:99999;\nposition:absolute;\n"
        }, {
            name: "Element Flip X",
            value: false
        }, {
            name: "Element Flip Y",
            value: false
        }],
        portsOut: [{
            name: "Next",
            value: 0
        }, {
            name: "Texture",
            links: [{
                portIn: "Base Texture",
                portOut: "Texture",
                objIn: "d1dcb3c6-5ee1-4a70-bac5-2b012acc16e8",
                objOut: "07504819-e523-4aee-b261-15e6871047d0"
            }]
        }, {
            name: "Ratio",
            value: 1.7777777777777777
        }, {
            name: "Available",
            value: 1
        }, {
            name: "Size Width",
            value: 1280
        }, {
            name: "Size Height",
            value: 720
        }, {
            name: "Error",
            value: ""
        }, {
            name: "HTML Element"
        }, {
            name: "Available devices"
        }, {
            name: "Active device",
            value: "UVC Camera (12d1:4321)"
        }, {
            name: "Texture updated",
            value: 0
        }],
        objName: "Ops.Gl.Textures.WebcamTexture_v3"
    }, {
        id: "d1dcb3c6-5ee1-4a70-bac5-2b012acc16e8",
        uiAttribs: {},
        portsIn: [{
            name: "Render"
        }, {
            name: "Base Texture"
        }, {
            name: "UV Texture"
        }, {
            name: "Size index",
            value: 0
        }, {
            name: "Size",
            value: "Canvas"
        }, {
            name: "Width",
            value: 640
        }, {
            name: "Height",
            value: 480
        }, {
            name: "Filter index",
            value: 1
        }, {
            name: "Filter",
            value: "linear"
        }, {
            name: "Wrap index",
            value: 1
        }, {
            name: "Wrap",
            value: "repeat"
        }, {
            name: "Pixel Format index",
            value: 0
        }, {
            name: "Pixel Format",
            value: "RGBA 8bit ubyte"
        }, {
            name: "R",
            value: 0
        }, {
            name: "G",
            value: 0
        }, {
            name: "B",
            value: 0
        }, {
            name: "A",
            value: 0
        }],
        portsOut: [{
            name: "Next",
            links: [{
                portIn: "Render",
                portOut: "Next",
                objIn: "4a2e00bd-d526-4d8b-ab0e-7101b5b3587d",
                objOut: "d1dcb3c6-5ee1-4a70-bac5-2b012acc16e8"
            }, {
                portIn: "render",
                portOut: "Next",
                objIn: "9b3f5eb4-bc94-41af-b570-a86ede96883d",
                objOut: "d1dcb3c6-5ee1-4a70-bac5-2b012acc16e8"
            }]
        }, {
            name: "texture_out",
            links: [{
                portIn: "texture",
                portOut: "texture_out",
                objIn: "9b3f5eb4-bc94-41af-b570-a86ede96883d",
                objOut: "d1dcb3c6-5ee1-4a70-bac5-2b012acc16e8"
            }]
        }, {
            name: "Aspect Ratio",
            value: 2.253125
        }, {
            name: "Texture Width",
            value: 721
        }, {
            name: "Texture Height",
            value: 320
        }],
        objName: "Ops.Gl.TextureEffects.ImageCompose_v4"
    }, {
        id: "4a2e00bd-d526-4d8b-ab0e-7101b5b3587d",
        uiAttribs: {},
        portsIn: [{
            name: "Render"
        }, {
            name: "Blend Mode index",
            value: 0
        }, {
            name: "Blend Mode",
            value: "normal"
        }, {
            name: "Amount",
            value: 1
        }, {
            name: "Sides"
        }, {
            name: "Angle",
            value: 0
        }, {
            name: "Slide X",
            value: 0
        }, {
            name: "Slide Y",
            value: 0
        }, {
            name: "Center X",
            value: .5
        }, {
            name: "Center Y",
            value: .5
        }, {
            name: "Aspect Ratio",
            value: true
        }],
        portsOut: [{
            name: "Next",
            value: 0
        }],
        objName: "Ops.Gl.TextureEffects.Kaleidoscope_v2"
    }, {
        id: "54f1922b-e7df-49ed-8bb3-3810530e1ae5",
        uiAttribs: {},
        portsIn: [{
            name: "render",
            title: "Trigger"
        }, {
            name: "Render Mesh",
            value: true,
            title: "Render"
        }, {
            name: "width",
            value: .59
        }, {
            name: "height",
            value: .84
        }, {
            name: "pivot x index",
            value: 1
        }, {
            name: "pivot x",
            value: "center"
        }, {
            name: "pivot y index",
            value: 1
        }, {
            name: "pivot y",
            value: "center"
        }, {
            name: "axis index",
            value: 0
        }, {
            name: "axis",
            value: "xy"
        }, {
            name: "Flip TexCoord X",
            value: false
        }, {
            name: "Flip TexCoord Y",
            value: true
        }, {
            name: "num columns",
            value: 1
        }, {
            name: "num rows",
            value: 1
        }],
        portsOut: [{
            name: "trigger",
            value: 0,
            title: "Next"
        }, {
            name: "geometry"
        }],
        objName: "Ops.Gl.Meshes.Rectangle_v4"
    }, {
        id: "9b3f5eb4-bc94-41af-b570-a86ede96883d",
        uiAttribs: {},
        portsIn: [{
            name: "render"
        }, {
            name: "r",
            value: .4537986047368192
        }, {
            name: "g",
            value: .4286540480078711
        }, {
            name: "b",
            value: .6234603552356175
        }, {
            name: "a",
            value: 1
        }, {
            name: "texture"
        }, {
            name: "colorizeTexture",
            value: false
        }, {
            name: "Vertex Colors",
            value: false
        }, {
            name: "textureOpacity"
        }, {
            name: "Alpha Mask Source index",
            value: 0
        }, {
            name: "Alpha Mask Source",
            value: "Luminance"
        }, {
            name: "Opacity TexCoords Transform",
            value: false
        }, {
            name: "Discard Transparent Pixels",
            value: 0
        }, {
            name: "diffuseRepeatX",
            value: 1
        }, {
            name: "diffuseRepeatY",
            value: 1
        }, {
            name: "Tex Offset X",
            value: 0
        }, {
            name: "Tex Offset Y",
            value: 0
        }, {
            name: "Crop TexCoords",
            value: false
        }, {
            name: "billboard",
            value: false
        }],
        portsOut: [{
            name: "trigger",
            links: [{
                portIn: "render",
                portOut: "trigger",
                objIn: "54f1922b-e7df-49ed-8bb3-3810530e1ae5",
                objOut: "9b3f5eb4-bc94-41af-b570-a86ede96883d"
            }]
        }, {
            name: "shader"
        }],
        objName: "Ops.Gl.Shader.BasicMaterial_v3"
    }],
    _id: "6522ec46ad298be4ac5b8084",
    export: {
        time: "2023-10-15 08:07:38",
        service: "download",
        exportNumber: 5
    }
};
if (!CABLES.exportedPatch) {
    CABLES.exportedPatch = CABLES.exportedPatches["kgLqgI"]
}
"use strict";
var CABLES = CABLES || {};
CABLES.OPS = CABLES.OPS || {};
var Ops = Ops || {};
Ops.Gl = Ops.Gl || {};
Ops.Date = Ops.Date || {};
Ops.Json = Ops.Json || {};
Ops.Math = Ops.Math || {};
Ops.Array = Ops.Array || {};
Ops.String = Ops.String || {};
Ops.Gl.GLTF = Ops.Gl.GLTF || {};
Ops.Sidebar = Ops.Sidebar || {};
Ops.Trigger = Ops.Trigger || {};
Ops.Gl.Matrix = Ops.Gl.Matrix || {};
Ops.Gl.Meshes = Ops.Gl.Meshes || {};
Ops.Gl.Shader = Ops.Gl.Shader || {};
Ops.Gl.Textures = Ops.Gl.Textures || {};
Ops.Gl.TextureEffects = Ops.Gl.TextureEffects || {};
Ops.Gl.MainLoop = function() {
    CABLES.Op.apply(this, arguments);
    const i = this;
    const e = {};
    const t = i.inValue("FPS Limit", 0),
        n = i.outTrigger("trigger"),
        s = i.outNumber("width"),
        r = i.outNumber("height"),
        a = i.inValueBool("Reduce FPS not focussed", true),
        o = i.inValueBool("Reduce FPS loading"),
        l = i.inValueBool("Clear", true),
        h = i.inValueBool("ClearAlpha", true),
        c = i.inValueBool("Fullscreen Button", false),
        u = i.inValueBool("Active", true),
        d = i.inValueBool("Hires Displays", false),
        g = i.inSwitch("Pixel Unit", ["Display", "CSS"], "Display");
    i.onAnimFrame = A;
    d.onChange = function() {
        if (d.get()) i.patch.cgl.pixelDensity = window.devicePixelRatio;
        else i.patch.cgl.pixelDensity = 1;
        i.patch.cgl.updateSize();
        if (CABLES.UI) gui.setLayout()
    };
    u.onChange = function() {
        i.patch.removeOnAnimFrame(i);
        if (u.get()) {
            i.setUiAttrib({
                extendTitle: ""
            });
            i.onAnimFrame = A;
            i.patch.addOnAnimFrame(i);
            i.log("adding again!")
        } else {
            i.setUiAttrib({
                extendTitle: "Inactive"
            })
        }
    };
    const m = i.patch.cgl;
    let f = 0;
    let p = 0;
    if (!i.patch.cgl) i.uiAttr({
        error: "No webgl cgl context"
    });
    const b = vec3.create();
    vec3.set(b, 0, 0, 0);
    const _ = vec3.create();
    vec3.set(_, 0, 0, -2);
    c.onChange = S;
    setTimeout(S, 100);
    let v = null;
    let x = true;
    let y = true;
    window.addEventListener("blur", () => {
        x = false
    });
    window.addEventListener("focus", () => {
        x = true
    });
    document.addEventListener("visibilitychange", () => {
        y = !document.hidden
    });
    w();
    g.onChange = () => {
        s.set(0);
        r.set(0)
    };

    function C() {
        if (o.get() && i.patch.loading.getProgress() < 1) return 5;
        if (a.get()) {
            if (!y) return 10;
            if (!x) return 30
        }
        return t.get()
    }

    function S() {
        function e() {
            if (v) v.style.display = "block"
        }

        function t() {
            if (v) v.style.display = "none"
        }
        i.patch.cgl.canvas.addEventListener("mouseleave", t);
        i.patch.cgl.canvas.addEventListener("mouseenter", e);
        if (c.get()) {
            if (!v) {
                v = document.createElement("div");
                const n = i.patch.cgl.canvas.parentElement;
                if (n) n.appendChild(v);
                v.addEventListener("mouseenter", e);
                v.addEventListener("click", function(e) {
                    if (CABLES.UI && !e.shiftKey) gui.cycleFullscreen();
                    else m.fullScreen()
                })
            }
            v.style.padding = "10px";
            v.style.position = "absolute";
            v.style.right = "5px";
            v.style.top = "5px";
            v.style.width = "20px";
            v.style.height = "20px";
            v.style.cursor = "pointer";
            v.style["border-radius"] = "40px";
            v.style.background = "#444";
            v.style["z-index"] = "9999";
            v.style.display = "none";
            v.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" version="1.1" id="Capa_1" x="0px" y="0px" viewBox="0 0 490 490" style="width:20px;height:20px;" xml:space="preserve" width="512px" height="512px"><g><path d="M173.792,301.792L21.333,454.251v-80.917c0-5.891-4.776-10.667-10.667-10.667C4.776,362.667,0,367.442,0,373.333V480     c0,5.891,4.776,10.667,10.667,10.667h106.667c5.891,0,10.667-4.776,10.667-10.667s-4.776-10.667-10.667-10.667H36.416     l152.459-152.459c4.093-4.237,3.975-10.99-0.262-15.083C184.479,297.799,177.926,297.799,173.792,301.792z" fill="#FFFFFF"/><path d="M480,0H373.333c-5.891,0-10.667,4.776-10.667,10.667c0,5.891,4.776,10.667,10.667,10.667h80.917L301.792,173.792     c-4.237,4.093-4.354,10.845-0.262,15.083c4.093,4.237,10.845,4.354,15.083,0.262c0.089-0.086,0.176-0.173,0.262-0.262     L469.333,36.416v80.917c0,5.891,4.776,10.667,10.667,10.667s10.667-4.776,10.667-10.667V10.667C490.667,4.776,485.891,0,480,0z" fill="#FFFFFF"/><path d="M36.416,21.333h80.917c5.891,0,10.667-4.776,10.667-10.667C128,4.776,123.224,0,117.333,0H10.667     C4.776,0,0,4.776,0,10.667v106.667C0,123.224,4.776,128,10.667,128c5.891,0,10.667-4.776,10.667-10.667V36.416l152.459,152.459     c4.237,4.093,10.99,3.975,15.083-0.262c3.992-4.134,3.992-10.687,0-14.82L36.416,21.333z" fill="#FFFFFF"/><path d="M480,362.667c-5.891,0-10.667,4.776-10.667,10.667v80.917L316.875,301.792c-4.237-4.093-10.99-3.976-15.083,0.261     c-3.993,4.134-3.993,10.688,0,14.821l152.459,152.459h-80.917c-5.891,0-10.667,4.776-10.667,10.667s4.776,10.667,10.667,10.667     H480c5.891,0,10.667-4.776,10.667-10.667V373.333C490.667,367.442,485.891,362.667,480,362.667z" fill="#FFFFFF"/></g></svg>'
        } else {
            if (v) {
                v.style.display = "none";
                v.remove();
                v = null
            }
        }
    }
    i.onDelete = function() {
        m.gl.clearColor(0, 0, 0, 0);
        m.gl.clear(m.gl.COLOR_BUFFER_BIT | m.gl.DEPTH_BUFFER_BIT)
    };

    function A(e) {
        if (!u.get()) return;
        if (m.aborted || m.canvas.clientWidth === 0 || m.canvas.clientHeight === 0) return;
        i.patch.cg = m;
        const t = performance.now();
        i.patch.config.fpsLimit = C();
        if (m.canvasWidth == -1) {
            m.setCanvas(i.patch.config.glCanvasId);
            return
        }
        if (m.canvasWidth != s.get() || m.canvasHeight != r.get()) {
            let e = 1;
            if (g.get() == "CSS") e = i.patch.cgl.pixelDensity;
            s.set(m.canvasWidth / e);
            r.set(m.canvasHeight / e)
        }
        if (CABLES.now() - p > 1e3) {
            CGL.fpsReport = CGL.fpsReport || [];
            if (i.patch.loading.getProgress() >= 1 && p !== 0) CGL.fpsReport.push(f);
            f = 0;
            p = CABLES.now()
        }
        CGL.MESH.lastShader = null;
        CGL.MESH.lastMesh = null;
        m.renderStart(m, b, _);
        if (l.get()) {
            m.gl.clearColor(0, 0, 0, 1);
            m.gl.clear(m.gl.COLOR_BUFFER_BIT | m.gl.DEPTH_BUFFER_BIT)
        }
        n.trigger();
        if (CGL.MESH.lastMesh) CGL.MESH.lastMesh.unBind();
        if (CGL.Texture.previewTexture) {
            if (!CGL.Texture.texturePreviewer) CGL.Texture.texturePreviewer = new CGL.Texture.texturePreview(m);
            CGL.Texture.texturePreviewer.render(CGL.Texture.previewTexture)
        }
        m.renderEnd(m);
        i.patch.cg = null;
        if (h.get()) {
            m.gl.clearColor(1, 1, 1, 1);
            m.gl.colorMask(false, false, false, true);
            m.gl.clear(m.gl.COLOR_BUFFER_BIT);
            m.gl.colorMask(true, true, true, true)
        }
        if (!m.frameStore.phong) m.frameStore.phong = {};
        f++;
        i.patch.cgl.profileData.profileMainloopMs = performance.now() - t
    }

    function w() {
        setTimeout(() => {
            if (i.patch.getOpsByObjName(i.name).length > 1) {
                i.setUiError("multimainloop", "there should only be one mainloop op!");
                i.patch.addEventListener("onOpDelete", w)
            } else i.setUiError("multimainloop", null, 1)
        }, 500)
    }
};
Ops.Gl.MainLoop.prototype = new CABLES.Op;
CABLES.OPS["b0472a1d-db16-4ba6-8787-f300fbdc77bb"] = {
    f: Ops.Gl.MainLoop,
    objName: "Ops.Gl.MainLoop"
};
Ops.String.StringEditor = function() {
    CABLES.Op.apply(this, arguments);
    const e = this;
    const t = {};
    const n = e.inStringEditor("value", ""),
        i = e.inValueSelect("Syntax", ["text", "glsl", "css", "html", "xml", "json", "javascript", "inline-css", "sql"], "text"),
        s = e.outString("Result");
    i.onChange = r;

    function r() {
        let e = i.get();
        if (e == "javascript") e = "js";
        n.setUiAttribs({
            editorSyntax: e
        })
    }
    n.onChange = function() {
        s.set(n.get())
    }
};
Ops.String.StringEditor.prototype = new CABLES.Op;
CABLES.OPS["6468b7c1-f63e-4db4-b809-4b203d27ead3"] = {
    f: Ops.String.StringEditor,
    objName: "Ops.String.StringEditor"
};
Ops.Gl.Matrix.OrbitControls = function() {
    CABLES.Op.apply(this, arguments);
    const s = this;
    const j = {};
    const V = s.inTrigger("render"),
        r = s.inValueFloat("min distance"),
        a = s.inValueFloat("max distance"),
        o = s.inValue("min rot y", 0),
        l = s.inValue("max rot y", 0),
        t = s.inValue("initial radius", 0),
        n = s.inValueSlider("initial axis y"),
        i = s.inValueSlider("initial axis x"),
        h = s.inValueFloat("mul"),
        e = s.inValueSlider("Smoothness", 1),
        P = s.inValue("Speed X", 1),
        D = s.inValue("Speed Y", 1),
        U = s.inValueBool("Active", true),
        G = s.inValueBool("Allow Panning", true),
        F = s.inValueBool("Allow Zooming", true),
        z = s.inValueBool("Allow Rotation", true),
        $ = s.inValueBool("restricted", true),
        H = s.outTrigger("trigger"),
        c = s.outNumber("radius"),
        W = s.outNumber("Rot X"),
        X = s.outNumber("Rot Y"),
        Y = s.inTriggerButton("Reset");
    s.setPortGroup("Initial Values", [n, i, t]);
    s.setPortGroup("Interaction", [h, e, P, D]);
    s.setPortGroup("Boundaries", [o, l, r, a]);
    h.set(1);
    r.set(.05);
    a.set(99999);
    Y.onTriggered = K;
    let u = vec3.create();
    const d = vec3.create();
    const g = vec3.create();
    const m = mat4.create();
    const Z = mat4.create();
    const f = vec3.create();
    const q = vec3.create();
    n.set(.5);
    let p = false;
    let b = 5;
    c.set(b);
    let _ = 0,
        v = 0;
    let x = 0,
        y = 0;
    vec3.set(g, 0, 0, 0);
    vec3.set(d, 0, 1, 0);
    const C = vec3.create();
    const S = vec3.create();
    const A = vec3.create();
    const w = vec3.create();
    let I = 0;
    let T = 0;
    let J = 1;
    let E = null;
    ee();
    s.onDelete = de;
    const Q = Math.PI;
    const O = Math.PI * 2;

    function K() {
        let e = 0;
        if (I % O < -Q) {
            e = -O;
            I %= -O
        } else if (I % O > Q) {
            e = O;
            I %= O
        } else I %= O;
        T %= Math.PI;
        vec3.set(f, 0, 0, 0);
        vec3.set(g, 0, 0, 0);
        vec3.set(d, 0, 1, 0);
        x = i.get() * Math.PI * 2 + e;
        y = n.get() - .5;
        b = t.get();
        u = N(y)
    }

    function ee() {
        J = e.get() * 10 + 1
    }
    e.onChange = ee;
    let te = true;

    function L(e, t) {
        if (te) return t;
        return e + (t - e) / J
    }
    let M = 0;
    const ne = 0;
    V.onTriggered = function() {
        const e = s.patch.cg;
        if (!E) {
            ce(e.canvas);
            ue()
        }
        e.pushViewMatrix();
        I = L(I, x);
        T = L(T, y);
        let t = (T + .5) * 180;
        if (o.get() !== 0 && t < o.get()) {
            t = o.get();
            T = M
        } else if (l.get() !== 0 && t > l.get()) {
            t = l.get();
            T = M
        } else {
            M = T
        }
        const n = I * CGL.RAD2DEG;
        X.set(t);
        W.set(n);
        ie(u, T);
        vec3.add(C, u, f);
        vec3.add(A, g, f);
        S[0] = L(S[0], C[0]);
        S[1] = L(S[1], C[1]);
        S[2] = L(S[2], C[2]);
        w[0] = L(w[0], A[0]);
        w[1] = L(w[1], A[1]);
        w[2] = L(w[2], A[2]);
        const i = vec3.create();
        mat4.lookAt(m, S, w, d);
        mat4.rotate(m, m, I, d);
        mat4.multiply(e.vMatrix, e.vMatrix, m);
        H.trigger();
        e.popViewMatrix();
        te = false
    };

    function ie(e, t) {
        const n = h.get();
        if (b < r.get() * n) b = r.get() * n;
        if (b > a.get() * n) b = a.get() * n;
        c.set(b * n);
        let i = 0,
            s = 0;
        s = 360 * t / 2 * CGL.DEG2RAD;
        vec3.set(e, Math.cos(s) * b * n, Math.sin(s) * b * n, 0);
        return e
    }

    function N(e) {
        const t = h.get();
        if (b < r.get() * t) b = r.get() * t;
        if (b > a.get() * t) b = a.get() * t;
        c.set(b * t);
        let n = 0,
            i = 0;
        const s = vec3.create();
        i = 360 * e / 2 * CGL.DEG2RAD;
        vec3.set(s, Math.cos(i) * b * t, Math.sin(i) * b * t, 0);
        return s
    }

    function k(e) {
        if (!p) return;
        const t = e.clientX;
        const n = e.clientY;
        let i = t - _;
        let s = n - v;
        i *= P.get();
        s *= D.get();
        if (e.buttons == 2 && G.get()) {
            f[2] += i * .01 * h.get();
            f[1] += s * .01 * h.get()
        } else if (e.buttons == 4 && F.get()) {
            b += s * .05;
            u = N(y)
        } else {
            if (z.get()) {
                x += i * .003;
                y += s * .002;
                if ($.get()) {
                    if (y > .5) y = .5;
                    if (y < -.5) y = -.5
                }
            }
        }
        _ = t;
        v = n
    }

    function B(e) {
        _ = e.clientX;
        v = e.clientY;
        p = true;
        try {
            E.setPointerCapture(e.pointerId)
        } catch (e) {}
    }

    function R(e) {
        p = false;
        try {
            E.releasePointerCapture(e.pointerId)
        } catch (e) {}
    }

    function se() {
        const e = s.patch.cg.canvas;
        if (document.pointerLockElement === e || document.mozPointerLockElement === e || document.webkitPointerLockElement === e) {
            document.addEventListener("mousemove", k, false)
        }
    }

    function re(e) {}
    t.onChange = function() {
        b = t.get();
        K()
    };
    i.onChange = function() {
        I = x = i.get() * Math.PI * 2
    };
    n.onChange = function() {
        T = y = n.get() - .5;
        u = N(y)
    };
    const ae = function(e) {
        if (F.get()) {
            const t = CGL.getWheelSpeed(e) * .06;
            b += parseFloat(t) * 1.2;
            u = N(y)
        }
    };
    const oe = function(e) {
        if (e.touches && e.touches.length > 0) B(e.touches[0])
    };
    const le = function(e) {
        R()
    };
    const he = function(e) {
        if (e.touches && e.touches.length > 0) k(e.touches[0])
    };
    U.onChange = function() {
        if (U.get()) ue();
        else de()
    };

    function ce(e) {
        de();
        E = e;
        ue()
    }

    function ue() {
        if (!E) return;
        E.addEventListener("pointermove", k);
        E.addEventListener("pointerdown", B);
        E.addEventListener("pointerup", R);
        E.addEventListener("pointerleave", R);
        E.addEventListener("pointerenter", re);
        E.addEventListener("contextmenu", function(e) {
            e.preventDefault()
        });
        E.addEventListener("wheel", ae, {
            passive: true
        })
    }

    function de() {
        if (!E) return;
        E.removeEventListener("pointermove", k);
        E.removeEventListener("pointerdown", B);
        E.removeEventListener("pointerup", R);
        E.removeEventListener("pointerleave", R);
        E.removeEventListener("pointerenter", R);
        E.removeEventListener("wheel", ae)
    }
    u = N(0);
    i.set(.25);
    t.set(.05)
};
Ops.Gl.Matrix.OrbitControls.prototype = new CABLES.Op;
CABLES.OPS["eaf4f7ce-08a3-4d1b-b9f4-ebc0b7b1cde1"] = {
    f: Ops.Gl.Matrix.OrbitControls,
    objName: "Ops.Gl.Matrix.OrbitControls"
};
Ops.Gl.Meshes.Cube_v2 = function() {
    CABLES.Op.apply(this, arguments);
    const a = this;
    const e = {};
    const t = a.inTrigger("Render"),
        n = a.inValueBool("Render Mesh", true),
        o = a.inValue("Width", 1),
        l = a.inValue("Length", 1),
        h = a.inValue("Height", 1),
        c = a.inValueBool("Center", true),
        u = a.inSwitch("Mapping", ["Side", "Cube +-", "SideWrap"], "Side"),
        d = a.inValue("Bias", 0),
        g = a.inValueBool("Flip X", true),
        m = a.inValueBool("Top", true),
        f = a.inValueBool("Bottom", true),
        p = a.inValueBool("Left", true),
        b = a.inValueBool("Right", true),
        _ = a.inValueBool("Front", true),
        v = a.inValueBool("Back", true),
        i = a.outTrigger("Next"),
        x = a.outObject("geometry", null, "geometry");
    const s = a.patch.cgl;
    a.toWorkPortsNeedToBeLinked(t);
    a.toWorkShouldNotBeChild("Ops.Gl.TextureEffects.ImageCompose", CABLES.OP_PORT_TYPE_FUNCTION);
    a.setPortGroup("Mapping", [u, d, g]);
    a.setPortGroup("Geometry", [o, h, l, c]);
    a.setPortGroup("Sides", [m, f, p, b, _, v]);
    let y = null,
        C = null,
        S = true,
        A = true;
    d.onChange = g.onChange = m.onChange = f.onChange = p.onChange = b.onChange = _.onChange = v.onChange = u.onChange = o.onChange = h.onChange = l.onChange = c.onChange = r;

    function r() {
        A = true
    }
    t.onLinkChanged = function() {
        if (!t.isLinked()) x.set(null);
        else x.setRef(y)
    };
    t.onTriggered = function() {
        if (A) w();
        if (n.get() && C && S) C.render(s.getShader());
        i.trigger()
    };
    a.preRender = function() {
        w();
        C.render(s.getShader())
    };

    function w() {
        if (!y) y = new CGL.Geometry("cubemesh");
        y.clear();
        let e = o.get();
        let t = -1 * o.get();
        let n = h.get();
        let i = -1 * h.get();
        let s = l.get();
        let r = -1 * l.get();
        if (!c.get()) {
            t = 0;
            i = 0;
            r = 0
        } else {
            e *= .5;
            t *= .5;
            n *= .5;
            i *= .5;
            s *= .5;
            r *= .5
        }
        E(y, e, n, s, t, i, r);
        if (u.get() == "Side") I(y, 1, 1, 1);
        else if (u.get() == "SideWrap") I(y, e, n, s);
        else T(y);
        y.verticesIndices = [];
        if (m.get()) y.verticesIndices.push(8, 9, 10, 8, 10, 11);
        if (f.get()) y.verticesIndices.push(12, 13, 14, 12, 14, 15);
        if (p.get()) y.verticesIndices.push(20, 21, 22, 20, 22, 23);
        if (b.get()) y.verticesIndices.push(16, 17, 18, 16, 18, 19);
        if (v.get()) y.verticesIndices.push(4, 5, 6, 4, 6, 7);
        if (_.get()) y.verticesIndices.push(0, 1, 2, 0, 2, 3);
        if (y.verticesIndices.length === 0) S = false;
        else S = true;
        if (C) C.dispose();
        C = a.patch.cg.createMesh(y);
        x.setRef(y);
        A = false
    }
    a.onDelete = function() {
        if (C) C.dispose()
    };

    function I(e, t, n, i) {
        const s = d.get();
        let r = 1 - s;
        let a = 0 + s;
        if (g.get()) {
            [r, a] = [a, r]
        }
        let o = 1 - s;
        let l = 0 + s;
        e.setTexCoords([t * a, n * o, t * r, n * o, t * r, n * l, t * a, n * l, t * r, n * o, t * r, n * l, t * a, n * l, t * a, n * o, t * a, i * l, t * a, i * o, t * r, i * o, t * r, i * l, t * r, n * l, t * a, n * l, t * a, n * o, t * r, n * o, i * r, n * o, i * r, n * l, i * a, n * l, i * a, n * o, i * a, n * o, i * r, n * o, i * r, n * l, i * a, n * l])
    }

    function T(e, t, n, i, s, r, a) {
        const o = .25;
        const l = 1 / 3;
        const h = d.get();
        let c = 0;
        if (g.get()) c = 1;
        const u = [];
        u.push(c + o + h, l * 2 - h, c + o * 2 - h, l * 2 - h, c + o * 2 - h, l + h, c + o + h, l + h, c + o * 4 - h, l * 2 - h, c + o * 4 - h, l + h, c + o * 3 + h, l + h, c + o * 3 + h, l * 2 - h);
        if (g.get()) u.push(o + h, 0 - h, o * 2 - h, 0 - h, o * 2 - h, l * 1 + h, o + h, l * 1 + h, o + h, l * 3 + h, o + h, l * 2 - h, o * 2 - h, l * 2 - h, o * 2 - h, l * 3 + h);
        else u.push(o + h, 0 + h, o + h, l * 1 - h, o * 2 - h, l * 1 - h, o * 2 - h, 0 + h, o + h, l * 3 - h, o * 2 - h, l * 3 - h, o * 2 - h, l * 2 + h, o + h, l * 2 + h);
        u.push(c + o * 3 - h, 1 - l - h, c + o * 3 - h, 1 - l * 2 + h, c + o * 2 + h, 1 - l * 2 + h, c + o * 2 + h, 1 - l - h, c + o * 0 + h, 1 - l - h, c + o * 1 - h, 1 - l - h, c + o * 1 - h, 1 - l * 2 + h, c + o * 0 + h, 1 - l * 2 + h);
        e.setTexCoords(u)
    }

    function E(e, t, n, i, s, r, a) {
        e.vertices = [s, r, i, t, r, i, t, n, i, s, n, i, s, r, a, s, n, a, t, n, a, t, r, a, s, n, a, s, n, i, t, n, i, t, n, a, s, r, a, t, r, a, t, r, i, s, r, i, t, r, a, t, n, a, t, n, i, t, r, i, s, r, a, s, r, i, s, n, i, s, n, a];
        e.vertexNormals = new Float32Array([0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0]);
        e.tangents = new Float32Array([0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1]);
        e.biTangents = new Float32Array([-1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1])
    }
};
Ops.Gl.Meshes.Cube_v2.prototype = new CABLES.Op;
CABLES.OPS["37b92ba4-cea5-42ae-bf28-a513ca28549c"] = {
    f: Ops.Gl.Meshes.Cube_v2,
    objName: "Ops.Gl.Meshes.Cube_v2"
};
Ops.Json.AjaxRequest_v2 = function() {
    CABLES.Op.apply(this, arguments);
    const a = this;
    const e = {};
    const i = a.inUrl("file"),
        o = a.inValueBool("JsonP", false),
        l = a.inObject("headers", {}),
        h = a.inStringEditor("body", ""),
        c = a.inDropDown("HTTP Method", ["GET", "POST", "PUT", "DELETE", "PATCH", "HEAD", "CONNECT", "OPTIONS", "TRACE"], "GET"),
        u = a.inString("Content-Type", "application/json"),
        d = a.inBool("parse json", true),
        g = a.inBool("Auto request", true),
        t = a.inTriggerButton("reload"),
        m = a.outObject("data"),
        f = a.outString("response"),
        p = a.outNumber("Duration MS", 0),
        b = a.outNumber("Status Code", 0),
        _ = a.outBoolNum("Is Loading", false),
        v = a.outTrigger("Loaded");
    i.setUiAttribs({
        title: "URL"
    });
    t.setUiAttribs({
        buttonTitle: "trigger request"
    });
    m.ignoreValueSerialize = true;
    f.ignoreValueSerialize = true;
    g.onChange = i.onChange = o.onChange = l.onChange = c.onChange = d.onChange = function() {
        s(false)
    };
    t.onTriggered = function() {
        s(true)
    };
    let n = 0;

    function s(e = false) {
        clearTimeout(n);
        n = setTimeout(function() {
            r(null, e)
        }, 100)
    }
    a.onFileChanged = function(e) {
        if (i.get() && i.get().indexOf(e) > -1) r(true)
    };

    function r(e, t = false) {
        if (!g.get() && !t) return;
        if (!i.get()) return;
        const s = a.patch.loading.start("jsonFile", "" + i.get(), a);
        _.set(true);
        a.setUiAttrib({
            extendTitle: CABLES.basename(i.get())
        });
        a.setUiError("jsonerr", null);
        let n = CABLES.ajax;
        if (o.get()) n = CABLES.jsonp;
        let r = a.patch.getFilePath(i.get());
        if (e) r += "?rnd=" + CABLES.generateUUID();
        a.patch.loading.addAssetLoadingTask(() => {
            const e = h.get();
            const i = performance.now();
            n(r, (e, t, n) => {
                p.set(Math.round(performance.now() - i));
                m.set(null);
                f.set(null);
                b.set(n.status);
                try {
                    let e = t;
                    if (typeof e === "string" && d.get()) {
                        e = JSON.parse(t);
                        m.set(e)
                    }
                    f.set(t);
                    a.uiAttr({
                        error: null
                    });
                    a.patch.loading.finished(s);
                    v.trigger();
                    _.set(false)
                } catch (e) {
                    a.logError(e);
                    a.setUiError("jsonerr", "Problem while loading json:<br/>" + e);
                    a.patch.loading.finished(s);
                    _.set(false)
                }
            }, c.get(), e && e.length > 0 ? e : null, u.get(), null, l.get() || {})
        })
    }
};
Ops.Json.AjaxRequest_v2.prototype = new CABLES.Op;
CABLES.OPS["e0879058-5505-4dc4-b9ff-47a3d3c8a71a"] = {
    f: Ops.Json.AjaxRequest_v2,
    objName: "Ops.Json.AjaxRequest_v2"
};
Ops.String.ParseFloat = function() {
    CABLES.Op.apply(this, arguments);
    const e = this;
    const t = {};
    const n = e.inString("String", 5711),
        i = e.outNumber("Number");
    n.onChange = function() {
        let e = parseFloat(n.get());
        if (e != e) e = 0;
        i.set(e)
    }
};
Ops.String.ParseFloat.prototype = new CABLES.Op;
CABLES.OPS["fa36a56b-a64d-4269-9a9e-addc16493006"] = {
    f: Ops.String.ParseFloat,
    objName: "Ops.String.ParseFloat"
};
Ops.Math.Math = function() {
    CABLES.Op.apply(this, arguments);
    const t = this;
    const e = {};
    const n = t.inFloat("number 0", 0),
        i = t.inFloat("number 1", 0),
        s = t.inSwitch("math mode", ["+", "-", "*", "/", "%", "min", "max"], "+"),
        r = t.outNumber("result");
    let a;
    n.onChange = i.onChange = b;
    s.onChange = p;
    let o = 0;
    let l = 0;
    const h = function(e, t) {
        return e + t
    };
    const c = function(e, t) {
        return e - t
    };
    const u = function(e, t) {
        return e * t
    };
    const d = function(e, t) {
        return e / t
    };
    const g = function(e, t) {
        return e % t
    };
    const m = function(e, t) {
        return Math.min(e, t)
    };
    const f = function(e, t) {
        return Math.max(e, t)
    };

    function p() {
        let e = s.get();
        if (e == "+") a = h;
        else if (e == "-") a = c;
        else if (e == "*") a = u;
        else if (e == "/") a = d;
        else if (e == "%") a = g;
        else if (e == "min") a = m;
        else if (e == "max") a = f;
        b();
        t.setUiAttrib({
            extendTitle: e
        })
    }

    function b() {
        o = n.get();
        l = i.get();
        r.set(a(o, l))
    }
    p()
};
Ops.Math.Math.prototype = new CABLES.Op;
CABLES.OPS["e9fdcaca-a007-4563-8a4d-e94e08506e0f"] = {
    f: Ops.Math.Math,
    objName: "Ops.Math.Math"
};
Ops.Gl.Meshes.TextMesh_v2 = function() {
    CABLES.Op.apply(this, arguments);
    const t = this;
    const e = {
        textmesh_frag: "UNI sampler2D tex;\n#ifdef DO_MULTEX\n    UNI sampler2D texMul;\n#endif\n#ifdef DO_MULTEX_MASK\n    UNI sampler2D texMulMask;\n#endif\nIN vec2 texCoord;\nIN vec2 texPos;\nUNI float r;\nUNI float g;\nUNI float b;\nUNI float a;\n\nvoid main()\n{\n    vec4 col=texture(tex,texCoord);\n    col.a=col.r;\n    col.r*=r;\n    col.g*=g;\n    col.b*=b;\n    col*=a;\n\n    if(col.a==0.0)discard;\n\n    #ifdef DO_MULTEX\n        col*=texture(texMul,texPos);\n    #endif\n\n    #ifdef DO_MULTEX_MASK\n        col*=texture(texMulMask,texPos).r;\n    #endif\n\n    outColor=col;\n}",
        textmesh_vert: "UNI sampler2D tex;\nUNI mat4 projMatrix;\nUNI mat4 modelMatrix;\nUNI mat4 viewMatrix;\nUNI float scale;\nIN vec3 vPosition;\nIN vec2 attrTexCoord;\nIN mat4 instMat;\nIN vec2 attrTexOffsets;\nIN vec2 attrTexSize;\nIN vec2 attrTexPos;\nOUT vec2 texPos;\n\nOUT vec2 texCoord;\n\nvoid main()\n{\n    texCoord=(attrTexCoord*(attrTexSize)) + attrTexOffsets;\n    mat4 instMVMat=instMat;\n    instMVMat[3][0]*=scale;\n\n    texPos=attrTexPos;\n\n    vec4 vert=vec4( vPosition.x*(attrTexSize.x/attrTexSize.y)*scale,vPosition.y*scale,vPosition.z*scale, 1. );\n\n    mat4 mvMatrix=viewMatrix * modelMatrix * instMVMat;\n\n    gl_Position = projMatrix * mvMatrix * vert;\n}\n"
    };
    const n = t.inTrigger("Render"),
        _ = t.inString("Text", "cables"),
        i = t.inValueFloat("Scale", 1),
        c = t.inString("Font", "Arial"),
        v = t.inValueSelect("align", ["left", "center", "right"], "center"),
        s = t.inValueSelect("vertical align", ["Top", "Middle", "Bottom"], "Middle"),
        x = t.inValueFloat("Line Height", 1),
        y = t.inValueFloat("Letter Spacing"),
        o = t.inSwitch("filter", ["nearest", "linear", "mipmap"], "mipmap"),
        l = t.inSwitch("Anisotropic", [0, 1, 2, 4, 8, 16], 0),
        r = t.inTexture("Texture Color"),
        a = t.inTexture("Texture Mask"),
        j = t.outTrigger("Next"),
        C = t.outTexture("texture"),
        V = t.outNumber("Total Lines", 0),
        P = t.outNumber("Width", 0),
        D = t.outBoolNum("Font Available", 0);
    const S = t.patch.cgl;
    t.toWorkPortsNeedToBeLinked(n);
    t.setPortGroup("Masking", [r, a]);
    const u = 1024;
    let h = false;
    let d = true;
    v.onChange = _.onChange = x.onChange = U;

    function U() {
        d = true
    }
    let g = null;
    CABLES.OpTextureMeshCanvas = {};
    let m = 0;
    const G = null;
    let A = null;
    let w = true;
    let I = true;
    l.onChange = o.onChange = () => {
        T().texture = null;
        I = true
    };
    a.onChange = r.onChange = function() {
        p.toggleDefine("DO_MULTEX", r.get());
        p.toggleDefine("DO_MULTEX_MASK", a.get())
    };
    C.set(null);
    c.onChange = function() {
        I = true;
        w = true;
        f()
    };
    t.patch.on("fontLoaded", e => {
        if (e == c.get()) {
            I = true;
            w = true
        }
    });

    function f() {
        const e = h;
        try {
            h = document.fonts.check('20px "' + c.get() + '"')
        } catch (e) {
            t.logError(e)
        }
        if (!e && h) {
            D.set(true);
            I = true;
            w = true
        }
        if (!h) setTimeout(f, 250)
    }
    s.onChange = function() {
        if (s.get() == "Middle") m = 0;
        else if (s.get() == "Top") m = 1;
        else if (s.get() == "Bottom") m = 2
    };

    function T() {
        g = "" + c.get();
        if (CABLES.OpTextureMeshCanvas.hasOwnProperty(g)) return CABLES.OpTextureMeshCanvas[g];
        const e = document.createElement("canvas");
        e.dataset.font = c.get();
        e.id = "texturetext_" + CABLES.generateUUID();
        e.style.display = "none";
        const t = document.getElementsByTagName("body")[0];
        t.appendChild(e);
        const n = e.getContext("2d");
        CABLES.OpTextureMeshCanvas[g] = {
            ctx: n,
            canvas: e,
            chars: {},
            characters: "",
            fontSize: 320
        };
        return CABLES.OpTextureMeshCanvas[g]
    }
    t.onDelete = function() {
        if (g && CABLES.OpTextureMeshCanvas[g]) CABLES.OpTextureMeshCanvas[g].canvas.remove()
    };
    const p = new CGL.Shader(S, "TextMesh");
    p.setSource(e.textmesh_vert, e.textmesh_frag);
    const F = new CGL.Uniform(p, "t", "tex", 0);
    const z = new CGL.Uniform(p, "t", "texMul", 1);
    const $ = new CGL.Uniform(p, "t", "texMulMask", 2);
    const H = new CGL.Uniform(p, "f", "scale", i);
    const b = t.inValueSlider("r", 1),
        E = t.inValueSlider("g", 1),
        O = t.inValueSlider("b", 1),
        L = t.inValueSlider("a", 1),
        W = new CGL.Uniform(p, "f", "r", b),
        X = new CGL.Uniform(p, "f", "g", E),
        Y = new CGL.Uniform(p, "f", "b", O),
        Z = new CGL.Uniform(p, "f", "a", L);
    b.setUiAttribs({
        colorPick: true
    });
    t.setPortGroup("Display", [i, c]);
    t.setPortGroup("Alignment", [v, s]);
    t.setPortGroup("Color", [b, E, O, L]);
    let M = 0;
    const N = vec3.create();
    let k = -1;
    let B = false;
    n.onTriggered = function() {
        if (d) {
            q();
            d = false
        }
        const e = T();
        if (e.lastChange != k) {
            w = true;
            k = e.lastChange
        }
        if (I) J();
        if (w) q();
        if (A && A.numInstances > 0) {
            S.pushBlendMode(CGL.BLEND_NORMAL, true);
            S.pushShader(p);
            S.setTexture(0, C.get().tex);
            const t = r.get();
            if (t) S.setTexture(1, t.tex);
            const n = a.get();
            if (n) S.setTexture(2, n.tex);
            if (m === 2) vec3.set(N, 0, M, 0);
            else if (m === 1) vec3.set(N, 0, 0, 0);
            else if (m === 0) vec3.set(N, 0, M / 2, 0);
            N[1] -= x.get();
            S.pushModelMatrix();
            mat4.translate(S.mMatrix, S.mMatrix, N);
            if (!B) A.render(S.getShader());
            S.popModelMatrix();
            S.setTexture(0, null);
            S.popShader();
            S.popBlendMode()
        }
        j.trigger()
    };
    y.onChange = function() {
        w = true
    };

    function q() {
        const e = String(_.get() + "");
        if (!C.get()) return;
        const r = T();
        if (!r.geom) {
            r.geom = new CGL.Geometry("textmesh");
            r.geom.vertices = [1, 1, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0];
            r.geom.texCoords = new Float32Array([1, 1, 0, 1, 1, 0, 0, 0]);
            r.geom.verticesIndices = [0, 1, 2, 2, 1, 3]
        }
        if (!A) A = new CGL.Mesh(S, r.geom);
        const a = e.split("\n");
        V.set(a.length);
        const o = [];
        const l = [];
        const h = [];
        const c = [];
        let u = 0;
        I = false;
        const d = mat4.create();
        let g = 0;
        for (let s = 0; s < a.length; s++) {
            const m = a[s];
            const f = m.length;
            let t = 0;
            let n = 0;
            let i = 0;
            for (let e = 0; e < f; e++) {
                const p = m.substring(e, e + 1);
                const b = r.chars[String(p)];
                if (b) {
                    i += b.texCoordWidth / b.texCoordHeight;
                    i += y.get()
                }
            }
            i -= y.get();
            M = 0;
            if (v.get() == "left") n = 0;
            else if (v.get() == "right") n = i;
            else if (v.get() == "center") n = i / 2;
            M = (s + 1) * x.get();
            for (let e = 0; e < f; e++) {
                const p = m.substring(e, e + 1);
                const b = r.chars[String(p)];
                if (!b) {
                    I = true;
                    return
                } else {
                    c.push(t / i * .99 + .005, (1 - s / (a.length - 1)) * .99 + .005);
                    l.push(b.texCoordX, 1 - b.texCoordY - b.texCoordHeight);
                    h.push(b.texCoordWidth, b.texCoordHeight);
                    mat4.identity(d);
                    mat4.translate(d, d, [t - n, 0 - s * x.get(), 0]);
                    t += b.texCoordWidth / b.texCoordHeight + y.get();
                    g = Math.max(g, t - n);
                    o.push(Array.prototype.slice.call(d));
                    u++
                }
            }
        }
        const t = [].concat.apply([], o);
        B = false;
        if (t.length == 0) B = true;
        A.numInstances = t.length / 16;
        if (A.numInstances == 0) {
            B = true;
            return
        }
        P.set(g * i.get());
        A.setAttribute("instMat", new Float32Array(t), 16, {
            instanced: true
        });
        A.setAttribute("attrTexOffsets", new Float32Array(l), 2, {
            instanced: true
        });
        A.setAttribute("attrTexSize", new Float32Array(h), 2, {
            instanced: true
        });
        A.setAttribute("attrTexPos", new Float32Array(c), 2, {
            instanced: true
        });
        w = false;
        if (I) J()
    }

    function R(t, n) {
        const i = T();
        if (!n) i.chars = {};
        const s = i.ctx;
        s.font = t + "px " + c.get();
        s.textAlign = "left";
        let r = 0;
        let a = 0;
        const o = t * 1.4;
        const e = {
            fits: true
        };
        for (let e = 0; e < i.characters.length; e++) {
            const l = String(i.characters.substring(e, e + 1));
            const h = s.measureText(l).width;
            if (a + h >= u) {
                r += o + 2;
                a = 0
            }
            if (!n) {
                i.chars[l] = {
                    str: l,
                    texCoordX: a / u,
                    texCoordY: r / u,
                    texCoordWidth: h / u,
                    texCoordHeight: o / u
                };
                s.fillText(l, a, r + t)
            }
            a += h + 12
        }
        if (r > u - o) {
            e.fits = false
        }
        e.spaceLeft = u - r;
        return e
    }

    function J() {
        let e = CGL.Texture.FILTER_LINEAR;
        if (o.get() == "nearest") e = CGL.Texture.FILTER_NEAREST;
        if (o.get() == "mipmap") e = CGL.Texture.FILTER_MIPMAP;
        const t = T();
        let n = String(_.get());
        if (n == null || n == undefined) n = "";
        for (let e = 0; e < n.length; e++) {
            const a = n.substring(e, e + 1);
            if (t.characters.indexOf(a) == -1) {
                t.characters += a;
                I = true
            }
        }
        const i = t.ctx;
        t.canvas.width = t.canvas.height = u;
        if (!t.texture) t.texture = CGL.Texture.createFromImage(S, t.canvas, {
            filter: e,
            anisotropic: parseFloat(l.get())
        });
        t.texture.setSize(u, u);
        i.fillStyle = "transparent";
        i.clearRect(0, 0, u, u);
        i.fillStyle = "rgba(255,255,255,255)";
        let s = t.fontSize + 40;
        let r = R(s, true);
        while (!r.fits) {
            s -= 5;
            r = R(s, true)
        }
        R(s, false);
        i.restore();
        t.texture.initTexture(t.canvas, e);
        t.texture.unpackAlpha = true;
        C.set(t.texture);
        t.lastChange = CABLES.now();
        w = true;
        I = false
    }
};
Ops.Gl.Meshes.TextMesh_v2.prototype = new CABLES.Op;
CABLES.OPS["2390f6b3-2122-412e-8c8d-5c2f574e8bd1"] = {
    f: Ops.Gl.Meshes.TextMesh_v2,
    objName: "Ops.Gl.Meshes.TextMesh_v2"
};
Ops.Json.ObjectGetStringByPath = function() {
    CABLES.Op.apply(this, arguments);
    const r = this;
    const e = {};
    const t = r.inObject("Object");
    const a = r.inString("Path");
    const o = r.inBool("Output path if missing", false);
    const l = r.outString("Output");
    const h = r.outBool("Found");
    t.ignoreValueSerialize = true;
    t.onChange = n;
    a.onChange = n;
    o.onChange = n;

    function n() {
        const e = t.get();
        const n = a.get();
        r.setUiError("missing", null);
        if (e && n) {
            if (!Array.isArray(e) && !(typeof e === "object")) {
                h.set(false);
                r.setUiError("notiterable", "input object of type " + typeof e + " is not travesable by path")
            } else {
                r.setUiError("notiterable", null);
                let t = e[n];
                const i = n.split(".");
                r.setUiAttrib({
                    extendTitle: i[i.length - 1] + ""
                });
                if (!t) t = c(n, e);
                if (t === undefined) {
                    const s = "could not find element at path " + n;
                    let e = 2;
                    t = null;
                    h.set(false);
                    if (o.get()) {
                        t = n;
                        e = 1
                    } else {
                        t = null
                    }
                    r.setUiError("missing", s, e)
                } else {
                    h.set(true);
                    t = String(t)
                }
                l.set(t)
            }
        } else {
            h.set(false)
        }
    }

    function c(e, t = self, n = ".") {
        const i = Array.isArray(e) ? e : e.split(n);
        return i.reduce((e, t) => {
            return e && e[t]
        }, t)
    }
};
Ops.Json.ObjectGetStringByPath.prototype = new CABLES.Op;
CABLES.OPS["497a6b7c-e33c-45e4-8fb2-a9149d972b5b"] = {
    f: Ops.Json.ObjectGetStringByPath,
    objName: "Ops.Json.ObjectGetStringByPath"
};
Ops.Trigger.NthTrigger_v2 = function() {
    CABLES.Op.apply(this, arguments);
    const e = this;
    const t = {};
    let n = 5;
    let i = e.inTriggerButton("Execute");
    let s = e.inValue("Nth", n);
    let r = e.outTrigger("Next");
    let a = 0;
    let o = n;
    i.onTriggered = l;
    s.onChange = h;

    function l() {
        a++;
        if (a % o === 0) {
            a = 0;
            r.trigger()
        }
    }

    function h() {
        o = s.get();
        a = 0
    }
};
Ops.Trigger.NthTrigger_v2.prototype = new CABLES.Op;
CABLES.OPS["ea43c184-5842-4aa1-b298-5db4515cbed0"] = {
    f: Ops.Trigger.NthTrigger_v2,
    objName: "Ops.Trigger.NthTrigger_v2"
};
Ops.Gl.GLTF.GltfScene_v4 = function() {
    CABLES.Op.apply(this, arguments);
    const y = this;
    const l = {
        inc_camera_js: "const gltfCamera = class\n{\n    constructor(gltf, node)\n    {\n        this.node = node;\n        this.name = node.name;\n        // console.log(gltf);\n        this.config = gltf.json.cameras[node.camera];\n\n        this.pos = vec3.create();\n        this.quat = quat.create();\n        this.vCenter = vec3.create();\n        this.vUp = vec3.create();\n        this.vMat = mat4.create();\n    }\n\n    updateAnim(time)\n    {\n        if (this.node && this.node._animTrans)\n        {\n            vec3.set(this.pos,\n                this.node._animTrans[0].getValue(time),\n                this.node._animTrans[1].getValue(time),\n                this.node._animTrans[2].getValue(time));\n\n            quat.set(this.quat,\n                this.node._animRot[0].getValue(time),\n                this.node._animRot[1].getValue(time),\n                this.node._animRot[2].getValue(time),\n                this.node._animRot[3].getValue(time));\n        }\n    }\n\n    start(time)\n    {\n        if (cgl.frameStore.shadowPass) return;\n\n        this.updateAnim(time);\n        const asp = cgl.getViewPort()[2] / cgl.getViewPort()[3];\n\n        cgl.pushPMatrix();\n        // mat4.perspective(\n        //     cgl.pMatrix,\n        //     this.config.perspective.yfov*0.5,\n        //     asp,\n        //     this.config.perspective.znear,\n        //     this.config.perspective.zfar);\n\n        cgl.pushViewMatrix();\n        // mat4.identity(cgl.vMatrix);\n\n        // if(this.node && this.node.parent)\n        // {\n        //     console.log(this.node.parent)\n        // vec3.add(this.pos,this.pos,this.node.parent._node.translation);\n        // vec3.sub(this.vCenter,this.vCenter,this.node.parent._node.translation);\n        // mat4.translate(cgl.vMatrix,cgl.vMatrix,\n        // [\n        //     -this.node.parent._node.translation[0],\n        //     -this.node.parent._node.translation[1],\n        //     -this.node.parent._node.translation[2]\n        // ])\n        // }\n\n        // vec3.set(this.vUp, 0, 1, 0);\n        // vec3.set(this.vCenter, 0, -1, 0);\n        // // vec3.set(this.vCenter, 0, 1, 0);\n        // vec3.transformQuat(this.vCenter, this.vCenter, this.quat);\n        // vec3.normalize(this.vCenter, this.vCenter);\n        // vec3.add(this.vCenter, this.vCenter, this.pos);\n\n        // mat4.lookAt(cgl.vMatrix, this.pos, this.vCenter, this.vUp);\n\n        let mv = mat4.create();\n        mat4.invert(mv, this.node.modelMatAbs());\n\n        // console.log(this.node.modelMatAbs());\n\n        this.vMat = mv;\n\n        mat4.identity(cgl.vMatrix);\n        // console.log(mv);\n        mat4.mul(cgl.vMatrix, cgl.vMatrix, mv);\n    }\n\n    end()\n    {\n        if (cgl.frameStore.shadowPass) return;\n        cgl.popPMatrix();\n        cgl.popViewMatrix();\n    }\n};\n",
        inc_gltf_js: 'const le = true; // little endian\n\nconst Gltf = class\n{\n    constructor()\n    {\n        this.json = {};\n        this.accBuffers = [];\n        this.meshes = [];\n        this.nodes = [];\n        this.shaders = [];\n        this.timing = [];\n        this.cams = [];\n        this.startTime = performance.now();\n        this.bounds = new CABLES.CG.BoundingBox();\n        this.loaded = Date.now();\n        this.accBuffersDelete = [];\n    }\n\n    getNode(n)\n    {\n        for (let i = 0; i < this.nodes.length; i++)\n        {\n            if (this.nodes[i].name == n) return this.nodes[i];\n        }\n    }\n\n    unHideAll()\n    {\n        for (let i = 0; i < this.nodes.length; i++)\n        {\n            this.nodes[i].unHide();\n        }\n    }\n};\n\nfunction Utf8ArrayToStr(array)\n{\n    if (window.TextDecoder) return new TextDecoder("utf-8").decode(array);\n\n    let out, i, len, c;\n    let char2, char3;\n\n    out = "";\n    len = array.length;\n    i = 0;\n    while (i < len)\n    {\n        c = array[i++];\n        switch (c >> 4)\n        {\n        case 0: case 1: case 2: case 3: case 4: case 5: case 6: case 7:\n            // 0xxxxxxx\n            out += String.fromCharCode(c);\n            break;\n        case 12: case 13:\n            // 110x xxxx   10xx xxxx\n            char2 = array[i++];\n            out += String.fromCharCode(((c & 0x1F) << 6) | (char2 & 0x3F));\n            break;\n        case 14:\n            // 1110 xxxx  10xx xxxx  10xx xxxx\n            char2 = array[i++];\n            char3 = array[i++];\n            out += String.fromCharCode(((c & 0x0F) << 12) |\n                    ((char2 & 0x3F) << 6) |\n                    ((char3 & 0x3F) << 0));\n            break;\n        }\n    }\n\n    return out;\n}\n\nfunction readChunk(dv, bArr, arrayBuffer, offset)\n{\n    const chunk = {};\n\n    if (offset >= dv.byteLength)\n    {\n        op.log("could not read chunk...");\n        return;\n    }\n    chunk.size = dv.getUint32(offset + 0, le);\n\n    // chunk.type = new TextDecoder("utf-8").decode(bArr.subarray(offset+4, offset+4+4));\n    chunk.type = Utf8ArrayToStr(bArr.subarray(offset + 4, offset + 4 + 4));\n\n    if (chunk.type == "BIN\\0")\n    {\n        // console.log(chunk.size,arrayBuffer.length,offset);\n        // try\n        // {\n        chunk.dataView = new DataView(arrayBuffer, offset + 8, chunk.size);\n        // }\n        // catch(e)\n        // {\n        //     chunk.dataView = null;\n        //     console.log(e);\n        // }\n    }\n    else\n    if (chunk.type == "JSON")\n    {\n        const json = Utf8ArrayToStr(bArr.subarray(offset + 8, offset + 8 + chunk.size));\n\n        try\n        {\n            const obj = JSON.parse(json);\n            chunk.data = obj;\n            outGenerator.set(obj.asset.generator);\n        }\n        catch (e)\n        {\n        }\n    }\n    else\n    {\n        op.warn("unknown type", chunk.type);\n    }\n\n    return chunk;\n}\n\nfunction loadAnims(gltf)\n{\n    const uniqueAnimNames = {};\n\n    for (let i = 0; i < gltf.json.animations.length; i++)\n    {\n        const an = gltf.json.animations[i];\n\n        an.name = an.name || "unknown";\n\n        for (let ia = 0; ia < an.channels.length; ia++)\n        {\n            const chan = an.channels[ia];\n\n            const node = gltf.nodes[chan.target.node];\n            const sampler = an.samplers[chan.sampler];\n\n            const acc = gltf.json.accessors[sampler.input];\n            const bufferIn = gltf.accBuffers[sampler.input];\n\n            const accOut = gltf.json.accessors[sampler.output];\n            const bufferOut = gltf.accBuffers[sampler.output];\n\n            gltf.accBuffersDelete.push(sampler.output, sampler.input);\n\n            if (bufferIn && bufferOut)\n            {\n                let numComps = 1;\n                if (accOut.type === "VEC2")numComps = 2;\n                else if (accOut.type === "VEC3")numComps = 3;\n                else if (accOut.type === "VEC4")numComps = 4;\n                else if (accOut.type === "SCALAR")\n                {\n                    numComps = bufferOut.length / bufferIn.length; // is this really the way to find out ? cant find any other way,except number of morph targets, but not really connected...\n                }\n                else op.log("[] UNKNOWN accOut.type", accOut.type);\n\n                const anims = [];\n\n                uniqueAnimNames[an.name] = true;\n\n                for (let k = 0; k < numComps; k++)\n                {\n                    const newAnim = new CABLES.Anim();\n                    // newAnim.name=an.name;\n                    anims.push(newAnim);\n                }\n\n                if (sampler.interpolation === "LINEAR") {}\n                else if (sampler.interpolation === "STEP") for (let k = 0; k < numComps; k++) anims[k].defaultEasing = CABLES.EASING_ABSOLUTE;\n                else if (sampler.interpolation === "CUBICSPLINE") for (let k = 0; k < numComps; k++) anims[k].defaultEasing = CABLES.EASING_CUBICSPLINE;\n                else op.warn("unknown interpolation", sampler.interpolation);\n\n                // console.log(bufferOut)\n\n                // if there is no keyframe for time 0 copy value of first keyframe at time 0\n                if (bufferIn[0] !== 0.0)\n                    for (let k = 0; k < numComps; k++)\n                        anims[k].setValue(0, bufferOut[0 * numComps + k]);\n\n                for (let j = 0; j < bufferIn.length; j++)\n                {\n                    maxTime = Math.max(bufferIn[j], maxTime);\n\n                    for (let k = 0; k < numComps; k++)\n                    {\n                        if (anims[k].defaultEasing === CABLES.EASING_CUBICSPLINE)\n                        {\n                            const idx = ((j * numComps) * 3 + k);\n\n                            const key = anims[k].setValue(bufferIn[j], bufferOut[idx + numComps]);\n                            key.bezTangIn = bufferOut[idx];\n                            key.bezTangOut = bufferOut[idx + (numComps * 2)];\n\n                            // console.log(an.name,k,bufferOut[idx+1]);\n                        }\n                        else\n                        {\n                            // console.log(an.name,k,bufferOut[j * numComps + k]);\n                            anims[k].setValue(bufferIn[j], bufferOut[j * numComps + k]);\n                        }\n                    }\n                }\n\n                node.setAnim(chan.target.path, an.name, anims);\n            }\n            else\n            {\n                op.warn("loadAmins bufferIn undefined ", bufferIn === undefined);\n                op.warn("loadAmins bufferOut undefined ", bufferOut === undefined);\n                op.warn("loadAmins ", sampler, accOut);\n                op.warn("loadAmins num accBuffers", gltf.accBuffers.length);\n                op.warn("loadAmins num accessors", gltf.json.accessors.length);\n            }\n        }\n    }\n\n    gltf.uniqueAnimNames = uniqueAnimNames;\n\n    outAnims.setRef(Object.keys(uniqueAnimNames));\n}\n\nfunction loadCams(gltf)\n{\n    if (!gltf || !gltf.json.cameras) return;\n\n    gltf.cameras = gltf.cameras || [];\n\n    for (let i = 0; i < gltf.nodes.length; i++)\n    {\n        if (gltf.nodes[i].hasOwnProperty("camera"))\n        {\n            const cam = new gltfCamera(gltf, gltf.nodes[i]);\n            gltf.cameras.push(cam);\n        }\n    }\n}\n\nfunction loadAfterDraco()\n{\n    if (!window.DracoDecoder)\n    {\n        setTimeout(() =>\n        {\n            loadAfterDraco();\n        }, 100);\n    }\n\n    reloadSoon();\n}\n\nfunction parseGltf(arrayBuffer)\n{\n    const CHUNK_HEADER_SIZE = 8;\n\n    let j = 0, i = 0;\n\n    const gltf = new Gltf();\n    gltf.timing.push(["Start parsing", Math.round((performance.now() - gltf.startTime))]);\n\n    if (!arrayBuffer) return;\n    const byteArray = new Uint8Array(arrayBuffer);\n    let pos = 0;\n\n    // var string = new TextDecoder("utf-8").decode(byteArray.subarray(pos, 4));\n    const string = Utf8ArrayToStr(byteArray.subarray(pos, 4));\n    pos += 4;\n    if (string != "glTF") return;\n\n    gltf.timing.push(["dataview", Math.round((performance.now() - gltf.startTime))]);\n\n    const dv = new DataView(arrayBuffer);\n    const version = dv.getUint32(pos, le);\n    pos += 4;\n    const size = dv.getUint32(pos, le);\n    pos += 4;\n\n    outVersion.set(version);\n\n    const chunks = [];\n    gltf.chunks = chunks;\n\n    chunks.push(readChunk(dv, byteArray, arrayBuffer, pos));\n    pos += chunks[0].size + CHUNK_HEADER_SIZE;\n    gltf.json = chunks[0].data;\n\n    gltf.cables = {\n        "fileUrl": inFile.get(),\n        "shortFileName": CABLES.basename(inFile.get())\n    };\n\n    outJson.setRef(gltf.json);\n    outExtensions.setRef(gltf.json.extensionsUsed || []);\n\n    let ch = readChunk(dv, byteArray, arrayBuffer, pos);\n    while (ch)\n    {\n        chunks.push(ch);\n        pos += ch.size + CHUNK_HEADER_SIZE;\n        ch = readChunk(dv, byteArray, arrayBuffer, pos);\n    }\n\n    gltf.chunks = chunks;\n\n    const views = chunks[0].data.bufferViews;\n    const accessors = chunks[0].data.accessors;\n\n    gltf.timing.push(["Parse buffers", Math.round((performance.now() - gltf.startTime))]);\n\n    if (gltf.json.extensionsUsed && gltf.json.extensionsUsed.indexOf("KHR_draco_mesh_compression") > -1)\n    {\n        if (!window.DracoDecoder)\n        {\n            op.setUiError("gltfdraco", "GLTF draco compression lib not found / add draco op to your patch!");\n\n            loadAfterDraco();\n            return gltf;\n        }\n        else\n        {\n            gltf.useDraco = true;\n        }\n    }\n\n    op.setUiError("gltfdraco", null);\n    // let accPos = (view.byteOffset || 0) + (acc.byteOffset || 0);\n\n    if (views)\n    {\n        for (i = 0; i < accessors.length; i++)\n        {\n            const acc = accessors[i];\n            const view = views[acc.bufferView];\n\n            let numComps = 0;\n            if (acc.type == "SCALAR")numComps = 1;\n            else if (acc.type == "VEC2")numComps = 2;\n            else if (acc.type == "VEC3")numComps = 3;\n            else if (acc.type == "VEC4")numComps = 4;\n            else if (acc.type == "MAT4")numComps = 16;\n            else console.error("unknown accessor type", acc.type);\n\n            //   const decoder = new decoderModule.Decoder();\n            //   const decodedGeometry = decodeDracoData(data, decoder);\n            //   // Encode mesh\n            //   encodeMeshToFile(decodedGeometry, decoder);\n\n            //   decoderModule.destroy(decoder);\n            //   decoderModule.destroy(decodedGeometry);\n\n            // 5120 (BYTE)\t1\n            // 5121 (UNSIGNED_BYTE)\t1\n            // 5122 (SHORT)\t2\n\n            if (chunks[1].dataView)\n            {\n                if (view)\n                {\n                    const num = acc.count * numComps;\n                    let accPos = (view.byteOffset || 0) + (acc.byteOffset || 0);\n                    let stride = view.byteStride || 0;\n                    let dataBuff = null;\n\n                    if (acc.componentType == 5126 || acc.componentType == 5125) // 4byte FLOAT or INT\n                    {\n                        stride = stride || 4;\n\n                        const isInt = acc.componentType == 5125;\n                        if (isInt)dataBuff = new Uint32Array(num);\n                        else dataBuff = new Float32Array(num);\n\n                        for (j = 0; j < num; j++)\n                        {\n                            if (isInt) dataBuff[j] = chunks[1].dataView.getUint32(accPos, le);\n                            else dataBuff[j] = chunks[1].dataView.getFloat32(accPos, le);\n\n                            if (stride != 4 && (j + 1) % numComps === 0)accPos += stride - (numComps * 4);\n                            accPos += 4;\n                        }\n                    }\n                    else if (acc.componentType == 5123) // UNSIGNED_SHORT\n                    {\n                        stride = stride || 2;\n\n                        dataBuff = new Uint16Array(num);\n\n                        for (j = 0; j < num; j++)\n                        {\n                            dataBuff[j] = chunks[1].dataView.getUint16(accPos, le);\n\n                            if (stride != 2 && (j + 1) % numComps === 0) accPos += stride - (numComps * 2);\n\n                            accPos += 2;\n                        }\n                    }\n                    else if (acc.componentType == 5121) // UNSIGNED_BYTE\n                    {\n                        stride = stride || 1;\n\n                        dataBuff = new Uint8Array(num);\n\n                        for (j = 0; j < num; j++)\n                        {\n                            dataBuff[j] = chunks[1].dataView.getUint8(accPos, le);\n\n                            if (stride != 1 && (j + 1) % numComps === 0) accPos += stride - (numComps * 1);\n\n                            accPos += 1;\n                        }\n                    }\n\n                    else\n                    {\n                        console.error("unknown component type", acc.componentType);\n                    }\n\n                    gltf.accBuffers.push(dataBuff);\n                }\n                else\n                {\n                    // console.log("has no dataview");\n                }\n            }\n        }\n    }\n\n    gltf.timing.push(["Parse mesh groups", Math.round((performance.now() - gltf.startTime))]);\n\n    gltf.json.meshes = gltf.json.meshes || [];\n\n    if (gltf.json.meshes)\n    {\n        for (i = 0; i < gltf.json.meshes.length; i++)\n        {\n            const mesh = new gltfMeshGroup(gltf, gltf.json.meshes[i]);\n            gltf.meshes.push(mesh);\n        }\n    }\n\n    gltf.timing.push(["Parse nodes", Math.round((performance.now() - gltf.startTime))]);\n\n    for (i = 0; i < gltf.json.nodes.length; i++)\n    {\n        if (gltf.json.nodes[i].children)\n            for (j = 0; j < gltf.json.nodes[i].children.length; j++)\n            {\n                gltf.json.nodes[gltf.json.nodes[i].children[j]].isChild = true;\n            }\n    }\n\n    for (i = 0; i < gltf.json.nodes.length; i++)\n    {\n        const node = new gltfNode(gltf.json.nodes[i], gltf);\n        gltf.nodes.push(node);\n    }\n\n    for (i = 0; i < gltf.nodes.length; i++)\n    {\n        const node = gltf.nodes[i];\n\n        if (!node.children) continue;\n        for (let j = 0; j < node.children.length; j++)\n        {\n            gltf.nodes[node.children[j]].parent = node;\n        }\n    }\n\n    for (i = 0; i < gltf.nodes.length; i++)\n    {\n        gltf.nodes[i].initSkin();\n    }\n\n    needsMatUpdate = true;\n\n    gltf.timing.push(["load anims", Math.round((performance.now() - gltf.startTime))]);\n\n    if (gltf.json.animations) loadAnims(gltf);\n\n    gltf.timing.push(["load cameras", Math.round((performance.now() - gltf.startTime))]);\n\n    if (gltf.json.cameras) loadCams(gltf);\n\n    gltf.timing.push(["finished", Math.round((performance.now() - gltf.startTime))]);\n    return gltf;\n}\n',
        inc_mesh_js: 'let gltfMesh = class\n{\n    constructor(name, prim, gltf, finished)\n    {\n        this.POINTS = 0;\n        this.LINES = 1;\n        this.LINE_LOOP = 2;\n        this.LINE_STRIP = 3;\n        this.TRIANGLES = 4;\n        this.TRIANGLE_STRIP = 5;\n        this.TRIANGLE_FAN = 6;\n\n        this.test = 0;\n        this.name = name;\n        this.submeshIndex = 0;\n        this.material = prim.material;\n        // console.log(prim);\n        this.mesh = null;\n        this.geom = new CGL.Geometry("gltf_" + this.name);\n        this.geom.verticesIndices = [];\n        this.bounds = null;\n        this.primitive = 4;\n        this.morphTargetsRenderMod = null;\n        this.weights = prim.weights;\n\n        if (prim.hasOwnProperty("mode")) this.primitive = prim.mode;\n\n        if (prim.hasOwnProperty("indices")) this.geom.verticesIndices = gltf.accBuffers[prim.indices];\n\n        gltf.loadingMeshes = gltf.loadingMeshes || 0;\n        gltf.loadingMeshes++;\n\n        this.materialJson =\n            this._matPbrMetalness =\n            this._matPbrRoughness =\n            this._matDiffuseColor = null;\n\n        if (gltf.json.materials)\n        {\n            if (this.material != -1) this.materialJson = gltf.json.materials[this.material];\n\n            if (this.materialJson && this.materialJson.pbrMetallicRoughness)\n            {\n                if (!this.materialJson.pbrMetallicRoughness.hasOwnProperty("baseColorFactor"))\n                {\n                    this._matDiffuseColor = [1, 1, 1, 1];\n                }\n                else\n                {\n                    this._matDiffuseColor = this.materialJson.pbrMetallicRoughness.baseColorFactor;\n                }\n\n                this._matDiffuseColor = this.materialJson.pbrMetallicRoughness.baseColorFactor;\n\n                if (!this.materialJson.pbrMetallicRoughness.hasOwnProperty("metallicFactor"))\n                {\n                    this._matPbrMetalness = 1.0;\n                }\n                else\n                {\n                    this._matPbrMetalness = this.materialJson.pbrMetallicRoughness.metallicFactor || null;\n                }\n\n                if (!this.materialJson.pbrMetallicRoughness.hasOwnProperty("roughnessFactor"))\n                {\n                    this._matPbrRoughness = 1.0;\n                }\n                else\n                {\n                    this._matPbrRoughness = this.materialJson.pbrMetallicRoughness.roughnessFactor || null;\n                }\n            }\n        }\n\n        if (gltf.useDraco && prim.extensions.KHR_draco_mesh_compression)\n        {\n            const view = gltf.chunks[0].data.bufferViews[prim.extensions.KHR_draco_mesh_compression.bufferView];\n            const num = view.byteLength;\n            const dataBuff = new Int8Array(num);\n            let accPos = (view.byteOffset || 0);// + (acc.byteOffset || 0);\n            for (let j = 0; j < num; j++)\n            {\n                dataBuff[j] = gltf.chunks[1].dataView.getInt8(accPos, le);\n                accPos++;\n            }\n\n            const dracoDecoder = window.DracoDecoder;\n            dracoDecoder.decodeGeometry(dataBuff.buffer, (geometry) =>\n            {\n                const geom = new CGL.Geometry("draco mesh " + name);\n\n                for (let i = 0; i < geometry.attributes.length; i++)\n                {\n                    const attr = geometry.attributes[i];\n\n                    if (attr.name === "position") geom.vertices = attr.array;\n                    else if (attr.name === "normal") geom.vertexNormals = attr.array;\n                    else if (attr.name === "uv") geom.texCoords = attr.array;\n                    else if (attr.name === "color") geom.vertexColors = this.calcVertexColors(attr.array);\n                    else if (attr.name === "joints") geom.setAttribute("attrJoints", Array.from(attr.array), 4);\n                    else if (attr.name === "weights")\n                    {\n                        const arr4 = new Float32Array(attr.array.length / attr.itemSize * 4);\n\n                        for (let k = 0; k < attr.array.length / attr.itemSize; k++)\n                        {\n                            arr4[k * 4] = arr4[k * 4 + 1] = arr4[k * 4 + 2] = arr4[k * 4 + 3] = 0;\n                            for (let j = 0; j < attr.itemSize; j++)\n                                arr4[k * 4 + j] = attr.array[k * attr.itemSize + j];\n                        }\n                        geom.setAttribute("attrWeights", arr4, 4);\n                    }\n                    else op.logWarn("unknown draco attrib", attr);\n                }\n\n                geometry.attributes = null;\n                geom.verticesIndices = geometry.index.array;\n\n                this.setGeom(geom);\n\n                this.mesh = null;\n                gltf.loadingMeshes--;\n                gltf.timing.push(["draco decode", Math.round((performance.now() - gltf.startTime))]);\n\n                if (finished)finished(this);\n            }, (error) => { op.logError(error); });\n        }\n        else\n        {\n            gltf.loadingMeshes--;\n            this.fillGeomAttribs(gltf, this.geom, prim.attributes);\n\n            if (prim.targets)\n            {\n                console.log("prim.targets", prim.targets.length);\n                for (let j = 0; j < prim.targets.length; j++)\n                {\n                    const tgeom = new CGL.Geometry("gltf_target_" + j);\n\n                    // if (prim.hasOwnProperty("indices")) tgeom.verticesIndices = gltf.accBuffers[prim.indices];\n\n                    this.fillGeomAttribs(gltf, tgeom, prim.targets[j], false);\n\n                    // { // calculate normals for final position of morphtarget for later...\n                    //     for (let i = 0; i < tgeom.vertices.length; i++) tgeom.vertices[i] += this.geom.vertices[i];\n                    //     tgeom.calculateNormals();\n                    //     for (let i = 0; i < tgeom.vertices.length; i++) tgeom.vertices[i] -= this.geom.vertices[i];\n                    // }\n\n                    this.geom.morphTargets.push(tgeom);\n                }\n            }\n            if (finished)finished(this);\n        }\n    }\n\n    _linearToSrgb(x)\n    {\n        if (x <= 0)\n            return 0;\n        else if (x >= 1)\n            return 1;\n        else if (x < 0.0031308)\n            return x * 12.92;\n        else\n            return x ** (1 / 2.2) * 1.055 - 0.055;\n    }\n\n    calcVertexColors(arr)\n    {\n        let vertexColors = null;\n        if (arr instanceof Float32Array)\n        {\n            let div = false;\n            for (let i = 0; i < arr.length; i++)\n            {\n                if (arr[i] > 1)\n                {\n                    div = true;\n                    continue;\n                }\n            }\n\n            if (div)\n                for (let i = 0; i < arr.length; i++) arr[i] /= 65535;\n\n            vertexColors = arr;\n        }\n\n        else if (arr instanceof Uint16Array)\n        {\n            const fb = new Float32Array(arr.length);\n            for (let i = 0; i < arr.length; i++) fb[i] = arr[i] / 65535;\n\n            vertexColors = fb;\n        }\n        else vertexColors = arr;\n\n        for (let i = 0; i < vertexColors.length; i++)\n        {\n            vertexColors[i] = this._linearToSrgb(vertexColors[i]);\n        }\n\n        return vertexColors;\n    }\n\n    fillGeomAttribs(gltf, tgeom, attribs, setGeom)\n    {\n        if (attribs.hasOwnProperty("POSITION")) tgeom.vertices = gltf.accBuffers[attribs.POSITION];\n        if (attribs.hasOwnProperty("NORMAL")) tgeom.vertexNormals = gltf.accBuffers[attribs.NORMAL];\n        if (attribs.hasOwnProperty("TANGENT")) tgeom.tangents = gltf.accBuffers[attribs.TANGENT];\n\n        if (attribs.hasOwnProperty("COLOR_0")) tgeom.vertexColors = this.calcVertexColors(gltf.accBuffers[attribs.COLOR_0]);\n        if (attribs.hasOwnProperty("COLOR_1")) tgeom.setAttribute("attrVertColor1", this.calcVertexColors(gltf.accBuffers[attribs.COLOR_1]), 4);\n        if (attribs.hasOwnProperty("COLOR_2")) tgeom.setAttribute("attrVertColor2", this.calcVertexColors(gltf.accBuffers[attribs.COLOR_2]), 4);\n        if (attribs.hasOwnProperty("COLOR_3")) tgeom.setAttribute("attrVertColor3", this.calcVertexColors(gltf.accBuffers[attribs.COLOR_3]), 4);\n        if (attribs.hasOwnProperty("COLOR_4")) tgeom.setAttribute("attrVertColor4", this.calcVertexColors(gltf.accBuffers[attribs.COLOR_4]), 4);\n\n        if (attribs.hasOwnProperty("TEXCOORD_0")) tgeom.texCoords = gltf.accBuffers[attribs.TEXCOORD_0];\n        if (attribs.hasOwnProperty("TEXCOORD_1")) tgeom.setAttribute("attrTexCoord1", gltf.accBuffers[attribs.TEXCOORD_1], 2);\n        if (attribs.hasOwnProperty("TEXCOORD_2")) tgeom.setAttribute("attrTexCoord2", gltf.accBuffers[attribs.TEXCOORD_2], 2);\n        if (attribs.hasOwnProperty("TEXCOORD_3")) tgeom.setAttribute("attrTexCoord3", gltf.accBuffers[attribs.TEXCOORD_3], 2);\n        if (attribs.hasOwnProperty("TEXCOORD_4")) tgeom.setAttribute("attrTexCoord4", gltf.accBuffers[attribs.TEXCOORD_4], 2);\n\n        if (attribs.hasOwnProperty("WEIGHTS_0"))\n        {\n            tgeom.setAttribute("attrWeights", gltf.accBuffers[attribs.WEIGHTS_0], 4);\n        }\n        if (attribs.hasOwnProperty("JOINTS_0"))\n        {\n            if (!gltf.accBuffers[attribs.JOINTS_0])console.log("no !gltf.accBuffers[attribs.JOINTS_0]");\n            tgeom.setAttribute("attrJoints", gltf.accBuffers[attribs.JOINTS_0], 4);\n        }\n\n        if (attribs.hasOwnProperty("POSITION")) gltf.accBuffersDelete.push(attribs.POSITION);\n        if (attribs.hasOwnProperty("NORMAL")) gltf.accBuffersDelete.push(attribs.NORMAL);\n        if (attribs.hasOwnProperty("TEXCOORD_0")) gltf.accBuffersDelete.push(attribs.TEXCOORD_0);\n        if (attribs.hasOwnProperty("TANGENT")) gltf.accBuffersDelete.push(attribs.TANGENT);\n        if (attribs.hasOwnProperty("COLOR_0"))gltf.accBuffersDelete.push(attribs.COLOR_0);\n        if (attribs.hasOwnProperty("COLOR_0"))gltf.accBuffersDelete.push(attribs.COLOR_0);\n        if (attribs.hasOwnProperty("COLOR_1"))gltf.accBuffersDelete.push(attribs.COLOR_1);\n        if (attribs.hasOwnProperty("COLOR_2"))gltf.accBuffersDelete.push(attribs.COLOR_2);\n        if (attribs.hasOwnProperty("COLOR_3"))gltf.accBuffersDelete.push(attribs.COLOR_3);\n\n        if (attribs.hasOwnProperty("TEXCOORD_1")) gltf.accBuffersDelete.push(attribs.TEXCOORD_1);\n        if (attribs.hasOwnProperty("TEXCOORD_2")) gltf.accBuffersDelete.push(attribs.TEXCOORD_2);\n        if (attribs.hasOwnProperty("TEXCOORD_3")) gltf.accBuffersDelete.push(attribs.TEXCOORD_3);\n        if (attribs.hasOwnProperty("TEXCOORD_4")) gltf.accBuffersDelete.push(attribs.TEXCOORD_4);\n\n        if (setGeom !== false) if (tgeom && tgeom.verticesIndices) this.setGeom(tgeom);\n    }\n\n    setGeom(geom)\n    {\n        if (inNormFormat.get() == "X-ZY")\n        {\n            for (let i = 0; i < geom.vertexNormals.length; i += 3)\n            {\n                let t = geom.vertexNormals[i + 2];\n                geom.vertexNormals[i + 2] = geom.vertexNormals[i + 1];\n                geom.vertexNormals[i + 1] = -t;\n            }\n        }\n\n        if (inVertFormat.get() == "XZ-Y")\n        {\n            for (let i = 0; i < geom.vertices.length; i += 3)\n            {\n                let t = geom.vertices[i + 2];\n                geom.vertices[i + 2] = -geom.vertices[i + 1];\n                geom.vertices[i + 1] = t;\n            }\n        }\n\n        if (this.primitive == this.TRIANGLES)\n        {\n            if (inCalcNormals.get() == "Force Smooth") geom.calculateNormals();\n            else if (!geom.vertexNormals.length && inCalcNormals.get() == "Auto") geom.calculateNormals({ "smooth": false });\n\n            if ((!geom.biTangents || geom.biTangents.length == 0) && geom.tangents)\n            {\n                const bitan = vec3.create();\n                const tan = vec3.create();\n\n                const tangents = geom.tangents;\n                geom.tangents = new Float32Array(tangents.length / 4 * 3);\n                geom.biTangents = new Float32Array(tangents.length / 4 * 3);\n\n                for (let i = 0; i < tangents.length; i += 4)\n                {\n                    const idx = i / 4 * 3;\n\n                    vec3.cross(\n                        bitan,\n                        [geom.vertexNormals[idx], geom.vertexNormals[idx + 1], geom.vertexNormals[idx + 2]],\n                        [tangents[i], tangents[i + 1], tangents[i + 2]]\n                    );\n\n                    vec3.div(bitan, bitan, [tangents[i + 3], tangents[i + 3], tangents[i + 3]]);\n                    vec3.normalize(bitan, bitan);\n\n                    geom.biTangents[idx + 0] = bitan[0];\n                    geom.biTangents[idx + 1] = bitan[1];\n                    geom.biTangents[idx + 2] = bitan[2];\n\n                    geom.tangents[idx + 0] = tangents[i + 0];\n                    geom.tangents[idx + 1] = tangents[i + 1];\n                    geom.tangents[idx + 2] = tangents[i + 2];\n                }\n            }\n\n            if (geom.tangents.length === 0 || inCalcNormals.get() != "Never")\n            {\n                console.log("[gltf ]no tangents... calculating tangents...");\n                geom.calcTangentsBitangents();\n            }\n        }\n\n        this.geom = geom;\n\n        this.bounds = geom.getBounds();\n    }\n\n    render(cgl, ignoreMaterial, skinRenderer)\n    {\n        if (!this.mesh && this.geom && this.geom.verticesIndices)\n        {\n            let g = this.geom;\n            if (this.geom.vertices.length / 3 > 64000)\n            {\n                g = this.geom.copy();\n                g.unIndex(false, true);\n            }\n\n            let glprim;\n            if (this.primitive == this.TRIANGLES)glprim = cgl.gl.TRIANGLES;\n            else if (this.primitive == this.LINES)glprim = cgl.gl.LINES;\n            else if (this.primitive == this.LINE_STRIP)glprim = cgl.gl.LINE_STRIP;\n            else if (this.primitive == this.POINTS)glprim = cgl.gl.POINTS;\n            else\n            {\n                op.logWarn("unknown primitive type", this);\n            }\n\n            this.mesh = new CGL.Mesh(cgl, g, glprim);\n        }\n        else\n        {\n            // update morphTargets\n            if (this.geom && this.geom.morphTargets.length && !this.morphTargetsRenderMod)\n            {\n                this.mesh.addVertexNumbers = true;\n                this.morphTargetsRenderMod = new GltfTargetsRenderer(this);\n            }\n\n\n            let useMat = !ignoreMaterial && this.material != -1 && gltf.shaders[this.material];\n            if (skinRenderer)useMat = false;\n\n            if (useMat) cgl.pushShader(gltf.shaders[this.material]);\n\n            const currentShader = cgl.getShader() || {};\n            const uniDiff = currentShader.uniformColorDiffuse;\n\n            const uniPbrMetalness = currentShader.uniformPbrMetalness;\n            const uniPbrRoughness = currentShader.uniformPbrRoughness;\n\n            if (!gltf.shaders[this.material] && inUseMatProps.get())\n            {\n                if (uniDiff && this._matDiffuseColor)\n                {\n                    this._matDiffuseColorOrig = [uniDiff.getValue()[0], uniDiff.getValue()[1], uniDiff.getValue()[2], uniDiff.getValue()[3]];\n                    uniDiff.setValue(this._matDiffuseColor);\n                }\n\n                if (uniPbrMetalness)\n                    if (this._matPbrMetalness != null)\n                    {\n                        this._matPbrMetalnessOrig = uniPbrMetalness.getValue();\n                        uniPbrMetalness.setValue(this._matPbrMetalness);\n                    }\n                    else\n                        uniPbrMetalness.setValue(0);\n\n                if (uniPbrRoughness)\n                    if (this._matPbrRoughness != null)\n                    {\n                        this._matPbrRoughnessOrig = uniPbrRoughness.getValue();\n                        uniPbrRoughness.setValue(this._matPbrRoughness);\n                    }\n                    else\n                    {\n                        uniPbrRoughness.setValue(0);\n                    }\n            }\n\n            if (this.morphTargetsRenderMod) this.morphTargetsRenderMod.renderStart(cgl, 0);\n            if (this.mesh)\n            {\n                // console.log(this.mesh)\n                // this.mesh.lastMaterial=0;\n                this.mesh.render(cgl.getShader(), ignoreMaterial);\n            }\n            if (this.morphTargetsRenderMod) this.morphTargetsRenderMod.renderFinish(cgl);\n\n            if (inUseMatProps.get())\n            {\n                if (uniDiff && this._matDiffuseColor) uniDiff.setValue(this._matDiffuseColorOrig);\n                if (uniPbrMetalness && this._matPbrMetalnessOrig != undefined) uniPbrMetalness.setValue(this._matPbrMetalnessOrig);\n                if (uniPbrRoughness && this._matPbrRoughnessOrig != undefined) uniPbrRoughness.setValue(this._matPbrRoughnessOrig);\n            }\n\n            if (useMat) cgl.popShader();\n        }\n    }\n};\n',
        inc_meshGroup_js: "const gltfMeshGroup = class\n{\n    constructor(gltf, m)\n    {\n        this.bounds = new CABLES.CG.BoundingBox();\n        this.meshes = [];\n        this.name = m.name;\n        const prims = m.primitives;\n\n        for (let i = 0; i < prims.length; i++)\n        {\n            const mesh = new gltfMesh(this.name, prims[i], gltf,\n                (mesh) =>\n                {\n                    mesh.extras = m.extras;\n                    this.bounds.apply(mesh.bounds);\n                });\n\n            mesh.submeshIndex = i;\n            this.meshes.push(mesh);\n        }\n    }\n\n    render(cgl, ignoreMat, skinRenderer, _time, weights)\n    {\n        for (let i = 0; i < this.meshes.length; i++)\n        {\n            const useMat = gltf.shaders[this.meshes[i].material];\n\n            if (!ignoreMat && useMat) cgl.pushShader(gltf.shaders[this.meshes[i].material]);\n            // console.log(gltf.shaders[this.meshes[i].material],this.meshes[i].material)\n            if (skinRenderer)skinRenderer.renderStart(cgl, _time);\n            if (weights) this.meshes[i].weights = weights;\n            this.meshes[i].render(cgl, ignoreMat, skinRenderer, _time);\n            if (skinRenderer)skinRenderer.renderFinish(cgl);\n            if (!ignoreMat && useMat) cgl.popShader();\n        }\n    }\n};\n",
        inc_node_js: 'const gltfNode = class\n{\n    constructor(node, gltf)\n    {\n        this.isChild = node.isChild || false;\n        this.name = node.name;\n        if (node.hasOwnProperty("camera")) this.camera = node.camera;\n        this.hidden = false;\n        this.mat = mat4.create();\n        this._animActions = {};\n        this.animWeights = [];\n        this._animMat = mat4.create();\n        this._tempMat = mat4.create();\n        this._tempQuat = quat.create();\n        this._tempRotmat = mat4.create();\n        this.mesh = null;\n        this.children = [];\n        this._node = node;\n        this._gltf = gltf;\n        this.absMat = mat4.create();\n        this.addTranslate = null;\n        this._tempAnimScale = null;\n        this.addMulMat = null;\n        this.updateMatrix();\n        this.skinRenderer = null;\n        this.copies = [];\n    }\n\n    get skin()\n    {\n        if (this._node.hasOwnProperty("skin")) return this._node.skin;\n        else return -1;\n    }\n\n    copy()\n    {\n        this.isCopy = true;\n        const n = new gltfNode(this._node, this._gltf);\n        n.copyOf = this;\n\n        n._animActions = this._animActions;\n        n.children = this.children;\n        if (this.skin) n.skinRenderer = new GltfSkin(this);\n\n        this.updateMatrix();\n        return n;\n    }\n\n    hasSkin()\n    {\n        if (this._node.hasOwnProperty("skin")) return this._gltf.json.skins[this._node.skin].name || "unknown";\n        return false;\n    }\n\n    initSkin()\n    {\n        if (this.skin > -1)\n        {\n            this.skinRenderer = new GltfSkin(this);\n        }\n    }\n\n    updateMatrix()\n    {\n        mat4.identity(this.mat);\n        if (this._node.translation) mat4.translate(this.mat, this.mat, this._node.translation);\n\n        if (this._node.rotation)\n        {\n            const rotmat = mat4.create();\n            this._rot = this._node.rotation;\n\n            mat4.fromQuat(rotmat, this._node.rotation);\n            mat4.mul(this.mat, this.mat, rotmat);\n        }\n\n        if (this._node.scale)\n        {\n            this._scale = this._node.scale;\n            mat4.scale(this.mat, this.mat, this._scale);\n        }\n\n        if (this._node.hasOwnProperty("mesh"))\n        {\n            this.mesh = this._gltf.meshes[this._node.mesh];\n            if (this.isCopy)\n            {\n                // console.log(this.mesh);\n            }\n        }\n\n        if (this._node.children)\n        {\n            for (let i = 0; i < this._node.children.length; i++)\n            {\n                this._gltf.json.nodes[i].isChild = true;\n                if (this._gltf.nodes[this._node.children[i]]) this._gltf.nodes[this._node.children[i]].isChild = true;\n                this.children.push(this._node.children[i]);\n            }\n        }\n    }\n\n    unHide()\n    {\n        this.hidden = false;\n        for (let i = 0; i < this.children.length; i++)\n            if (this.children[i].unHide) this.children[i].unHide();\n    }\n\n    calcBounds(gltf, mat, bounds)\n    {\n        const localMat = mat4.create();\n\n        if (mat) mat4.copy(localMat, mat);\n        if (this.mat) mat4.mul(localMat, localMat, this.mat);\n\n        if (this.mesh)\n        {\n            const bb = this.mesh.bounds.copy();\n            bb.mulMat4(localMat);\n            bounds.apply(bb);\n\n            if (bounds.changed)\n            {\n                boundingPoints.push(\n                    bb._min[0] || 0, bb._min[1] || 0, bb._min[2] || 0,\n                    bb._max[0] || 0, bb._max[1] || 0, bb._max[2] || 0);\n            }\n        }\n\n        for (let i = 0; i < this.children.length; i++)\n        {\n            if (gltf.nodes[this.children[i]] && gltf.nodes[this.children[i]].calcBounds)\n            {\n                const b = gltf.nodes[this.children[i]].calcBounds(gltf, localMat, bounds);\n\n                bounds.apply(b);\n            }\n        }\n\n        if (bounds.changed) return bounds;\n        else return null;\n    }\n\n    setAnimAction(name)\n    {\n        // console.log("setAnimAction:", name);\n        if (!name) return;\n\n        this._currentAnimaction = name;\n\n        if (name && !this._animActions[name])\n        {\n            // console.log("no action found:", name,this._animActions);\n            return null;\n        }\n\n        // else console.log("YES action found:", name);\n        // console.log(this._animActions);\n\n        for (let path in this._animActions[name])\n        {\n            if (path == "translation") this._animTrans = this._animActions[name][path];\n            else if (path == "rotation") this._animRot = this._animActions[name][path];\n            else if (path == "scale") this._animScale = this._animActions[name][path];\n            else if (path == "weights") this.animWeights = this._animActions[name][path];\n            else console.log("[gltfNode] unknown anim path", path, this._animActions[name][path]);\n        }\n    }\n\n    setAnim(path, name, anims)\n    {\n        if (!path || !name || !anims) return;\n\n        // console.log("setanim", this._node.name, path, name, anims);\n\n        this._animActions[name] = this._animActions[name] || {};\n\n        // console.log(this._animActions);\n        // debugger;\n\n        // for (let i = 0; i < this.copies.length; i++) this.copies[i]._animActions = this._animActions;\n\n        if (this._animActions[name][path]) op.log("[gltfNode] animation action path already exists", name, path, this._animActions[name][path]);\n\n        this._animActions[name][path] = anims;\n\n        if (path == "translation") this._animTrans = anims;\n        else if (path == "rotation") this._animRot = anims;\n        else if (path == "scale") this._animScale = anims;\n        else if (path == "weights")\n        {\n            // console.log("weights",name,path,anims)\n            this.animWeights = this._animActions[name][path];\n            // console.log(this.animWeights);\n        }\n        else console.warn("unknown anim path", path, anims);\n    }\n\n    modelMatLocal()\n    {\n        return this._animMat || this.mat;\n    }\n\n    modelMatAbs()\n    {\n        return this.absMat;\n    }\n\n    transform(cgl, _time)\n    {\n        if (!_time && _time != 0)_time = time;\n\n        this._lastTimeTrans = _time;\n\n        // console.log(this._rot)\n\n        gltfTransforms++;\n\n        if (!this._animTrans && !this._animRot && !this._animScale)\n        {\n            mat4.mul(cgl.mMatrix, cgl.mMatrix, this.mat);\n            this._animMat = null;\n        }\n        else\n        {\n            this._animMat = this._animMat || mat4.create();\n            mat4.identity(this._animMat);\n\n            const playAnims = true;\n\n            if (playAnims && this._animTrans)\n            {\n                mat4.translate(this._animMat, this._animMat, [\n                    this._animTrans[0].getValue(_time),\n                    this._animTrans[1].getValue(_time),\n                    this._animTrans[2].getValue(_time)]);\n            }\n            else\n            if (this._node.translation) mat4.translate(this._animMat, this._animMat, this._node.translation);\n\n            if (playAnims && this._animRot)\n            {\n                if (this._animRot[0].defaultEasing == CABLES.EASING_LINEAR) CABLES.Anim.slerpQuaternion(_time, this._tempQuat, this._animRot[0], this._animRot[1], this._animRot[2], this._animRot[3]);\n                else if (this._animRot[0].defaultEasing == CABLES.EASING_ABSOLUTE)\n                {\n                    this._tempQuat[0] = this._animRot[0].getValue(_time);\n                    this._tempQuat[1] = this._animRot[1].getValue(_time);\n                    this._tempQuat[2] = this._animRot[2].getValue(_time);\n                    this._tempQuat[3] = this._animRot[3].getValue(_time);\n                }\n                else if (this._animRot[0].defaultEasing == CABLES.EASING_CUBICSPLINE)\n                {\n                    CABLES.Anim.slerpQuaternion(_time, this._tempQuat, this._animRot[0], this._animRot[1], this._animRot[2], this._animRot[3]);\n                }\n\n                mat4.fromQuat(this._tempMat, this._tempQuat);\n                mat4.mul(this._animMat, this._animMat, this._tempMat);\n            }\n            else if (this._rot)\n            {\n                mat4.fromQuat(this._tempRotmat, this._rot);\n                mat4.mul(this._animMat, this._animMat, this._tempRotmat);\n            }\n\n            if (playAnims && this._animScale)\n            {\n                if (!this._tempAnimScale) this._tempAnimScale = [1, 1, 1];\n                this._tempAnimScale[0] = this._animScale[0].getValue(_time);\n                this._tempAnimScale[1] = this._animScale[1].getValue(_time);\n                this._tempAnimScale[2] = this._animScale[2].getValue(_time);\n                mat4.scale(this._animMat, this._animMat, this._tempAnimScale);\n            }\n            else if (this._scale) mat4.scale(this._animMat, this._animMat, this._scale);\n\n            mat4.mul(cgl.mMatrix, cgl.mMatrix, this._animMat);\n        }\n\n        if (this.animWeights)\n        {\n            this.weights = this.weights || [];\n\n            let str = "";\n            for (let i = 0; i < this.animWeights.length; i++)\n            {\n                this.weights[i] = this.animWeights[i].getValue(_time);\n                str += this.weights[i] + "/";\n            }\n\n            // console.log(str);\n            // this.mesh.weights=this.animWeights.get(_time);\n            // console.log(this.animWeights);\n        }\n\n        if (this.addTranslate) mat4.translate(cgl.mMatrix, cgl.mMatrix, this.addTranslate);\n\n        if (this.addMulMat) mat4.mul(cgl.mMatrix, cgl.mMatrix, this.addMulMat);\n\n        mat4.copy(this.absMat, cgl.mMatrix);\n    }\n\n    render(cgl, dontTransform, dontDrawMesh, ignoreMaterial, ignoreChilds, drawHidden, _time)\n    {\n        if (!dontTransform) cgl.pushModelMatrix();\n\n        if (_time === undefined) _time = gltf.time;\n\n        if (!dontTransform || this.skinRenderer) this.transform(cgl, _time);\n\n        if (this.hidden && !drawHidden)\n        {\n        }\n        else\n        {\n            if (this.skinRenderer)\n            {\n                this.skinRenderer.time = _time;\n                if (!dontDrawMesh)\n                    this.mesh.render(cgl, ignoreMaterial, this.skinRenderer, _time, this.weights);\n            }\n            else\n            {\n                if (this.mesh && !dontDrawMesh)\n                    this.mesh.render(cgl, ignoreMaterial, null, _time, this.weights);\n            }\n        }\n\n        if (!ignoreChilds && !this.hidden)\n            for (let i = 0; i < this.children.length; i++)\n                if (gltf.nodes[this.children[i]])\n                    gltf.nodes[this.children[i]].render(cgl, dontTransform, dontDrawMesh, ignoreMaterial, ignoreChilds, drawHidden, _time);\n\n        if (!dontTransform)cgl.popModelMatrix();\n    }\n};\n',
        inc_print_js: 'let tab = null;\n\nfunction closeTab()\n{\n    if (tab)gui.mainTabs.closeTab(tab.id);\n    tab = null;\n}\n\nfunction formatVec(arr)\n{\n    const nums = [];\n    for (let i = 0; i < arr.length; i++)\n    {\n        nums.push(Math.round(arr[i] * 1000) / 1000);\n    }\n\n    return nums.join(",");\n}\n\nfunction printNode(html, node, level)\n{\n    if (!gltf) return;\n\n    html += "<tr class=\\"row\\">";\n\n    let ident = "";\n    let identSpace = "";\n\n    for (let i = 1; i < level; i++)\n    {\n        identSpace += "&nbsp;&nbsp;&nbsp;";\n        let identClass = "identBg";\n        if (i == 1)identClass = "identBgLevel0";\n        ident += "<td class=\\"ident " + identClass + "\\" ><div style=\\"\\"></div></td>";\n    }\n    let id = CABLES.uuid();\n    html += ident;\n    html += "<td colspan=\\"" + (21 - level) + "\\">";\n\n    if (node.mesh && node.mesh.meshes.length)html += "<span class=\\"icon icon-cube\\"></span>&nbsp;";\n    else html += "<span class=\\"icon icon-box-select\\"></span> &nbsp;";\n\n    html += node.name + "</td><td></td>";\n\n    if (node.mesh)\n    {\n        html += "<td>";\n        for (let i = 0; i < node.mesh.meshes.length; i++)\n        {\n            if (i > 0)html += ", ";\n            html += node.mesh.meshes[i].name;\n        }\n\n        html += "</td>";\n\n        html += "<td>";\n        html += node.hasSkin() || "-";\n        html += "</td>";\n\n        html += "<td>";\n        let countMats = 0;\n        for (let i = 0; i < node.mesh.meshes.length; i++)\n        {\n            if (countMats > 0)html += ", ";\n            if (gltf.json.materials && node.mesh.meshes[i].hasOwnProperty("material"))\n            {\n                if (gltf.json.materials[node.mesh.meshes[i].material])\n                {\n                    html += gltf.json.materials[node.mesh.meshes[i].material].name;\n                    countMats++;\n                }\n            }\n        }\n        if (countMats == 0)html += "none";\n        html += "</td>";\n    }\n    else\n    {\n        html += "<td>-</td><td>-</td><td>-</td>";\n    }\n\n    html += "<td>";\n\n    if (node._node.translation || node._node.rotation || node._node.scale)\n    {\n        let info = "";\n\n        if (node._node.translation)info += "Translate: `" + formatVec(node._node.translation) + "` || ";\n        if (node._node.rotation)info += "Rotation: `" + formatVec(node._node.rotation) + "` || ";\n        if (node._node.scale)info += "Scale: `" + formatVec(node._node.scale) + "` || ";\n\n        html += "<span class=\\"icon icon-gizmo info\\" data-info=\\"" + info + "\\"></span> &nbsp;";\n    }\n\n    if (node._animRot || node._animScale || node._animTrans)\n    {\n        let info = "Animated: ";\n        if (node._animRot) info += "Rot ";\n        if (node._animScale) info += "Scale ";\n        if (node._animTrans) info += "Trans ";\n\n        html += "<span class=\\"icon icon-clock info\\" data-info=\\"" + info + "\\"></span>&nbsp;";\n    }\n\n    if (!node._node.translation && !node._node.rotation && !node._node.scale && !node._animRot && !node._animScale && !node._animTrans) html += "-";\n\n    html += "</td>";\n\n    html += "<td>";\n    let hideclass = "";\n    if (node.hidden)hideclass = "node-hidden";\n\n    // html+=\'\';\n    html += "<a onclick=\\"gui.corePatch().getOpById(\'" + op.id + "\').exposeNode(\'" + node.name + "\',\'transform\')\\" class=\\"treebutton\\">Transform</a>";\n    html += " <a onclick=\\"gui.corePatch().getOpById(\'" + op.id + "\').exposeNode(\'" + node.name + "\',\'hierarchy\')\\" class=\\"treebutton\\">Hierarchy</a>";\n    html += " <a onclick=\\"gui.corePatch().getOpById(\'" + op.id + "\').exposeNode(\'" + node.name + "\')\\" class=\\"treebutton\\">Node</a>";\n\n    if (node.hasSkin())\n        html += " <a onclick=\\"gui.corePatch().getOpById(\'" + op.id + "\').exposeNode(\'" + node.name + "\',false,{skin:true});\\" class=\\"treebutton\\">Skin</a>";\n\n    html += "</td><td>";\n    html += "&nbsp;<span class=\\"icon iconhover icon-eye " + hideclass + "\\" onclick=\\"gui.corePatch().getOpById(\'" + op.id + "\').toggleNodeVisibility(\'" + node.name + "\');this.classList.toggle(\'node-hidden\');\\"></span>";\n    html += "</td>";\n\n    html += "</tr>";\n\n    if (node.children)\n    {\n        for (let i = 0; i < node.children.length; i++)\n            html = printNode(html, gltf.nodes[node.children[i]], level + 1);\n    }\n\n    return html;\n}\n\nfunction printMaterial(mat, idx)\n{\n    let html = "<tr>";\n    html += " <td>" + idx + "</td>";\n    html += " <td>" + mat.name + "</td>";\n    // html+=\' <td><a onclick="" class="treebutton">Assign</a><td>\';\n\n    html += " <td>";\n\n    const info = JSON.stringify(mat, null, 4).replaceAll("\\"", "").replaceAll("\\n", "<br/>");\n\n    html += "<span class=\\"icon icon-info\\" onclick=\\"new CABLES.UI.ModalDialog({ \'html\': \'<pre>" + info + "</pre>\', \'title\': \'" + mat.name + "\' });\\"></span>&nbsp;";\n\n    if (mat.pbrMetallicRoughness && mat.pbrMetallicRoughness.baseColorFactor)\n    {\n        let rgb = "";\n        rgb += "" + Math.round(mat.pbrMetallicRoughness.baseColorFactor[0] * 255);\n        rgb += "," + Math.round(mat.pbrMetallicRoughness.baseColorFactor[1] * 255);\n        rgb += "," + Math.round(mat.pbrMetallicRoughness.baseColorFactor[2] * 255);\n\n        html += "<div style=\\"width:15px;height:15px;background-color:rgb(" + rgb + ");display:inline-block\\">&nbsp;</a>";\n    }\n    html += " <td style=\\"\\">" + (gltf.shaders[idx] ? "-" : "<a onclick=\\"gui.corePatch().getOpById(\'" + op.id + "\').assignMaterial(\'" + mat.name + "\')\\" class=\\"treebutton\\">Assign</a>") + "<td>";\n    html += "<td>";\n\n    html += "</tr>";\n    return html;\n}\n\nfunction printInfo()\n{\n    if (!gltf) return;\n\n    const startTime = performance.now();\n    const sizes = {};\n    let html = "<div style=\\"overflow:scroll;width:100%;height:100%\\">";\n\n    html += "File: <a href=\\"" + CABLES.sandbox.getCablesUrl() + "/asset/patches/?filename=" + inFile.get() + "\\" target=\\"_blank\\">" + CABLES.basename(inFile.get()) + "</a><br/>";\n\n    html += "Generator:" + gltf.json.asset.generator;\n\n    let numNodes = 0;\n    if (gltf.json.nodes)numNodes = gltf.json.nodes.length;\n    html += "<div id=\\"groupNodes\\">Nodes (" + numNodes + ")</div>";\n\n    html += "<table id=\\"sectionNodes\\" class=\\"table treetable\\">";\n\n    html += "<tr>";\n    html += " <th colspan=\\"21\\">Name</th>";\n    html += " <th>Mesh</th>";\n    html += " <th>Skin</th>";\n    html += " <th>Material</th>";\n    html += " <th>Transform</th>";\n    html += " <th>Expose</th>";\n    html += " <th></th>";\n    html += "</tr>";\n\n    for (let i = 0; i < gltf.nodes.length; i++)\n    {\n        if (!gltf.nodes[i].isChild)\n            html = printNode(html, gltf.nodes[i], 1);\n    }\n    html += "</table>";\n\n    // / //////////////////\n\n    let numMaterials = 0;\n    if (gltf.json.materials)numMaterials = gltf.json.materials.length;\n    html += "<div id=\\"groupMaterials\\">Materials (" + numMaterials + ")</div>";\n\n    if (!gltf.json.materials || gltf.json.materials.length == 0)\n    {\n    }\n    else\n    {\n        html += "<table id=\\"materialtable\\"  class=\\"table treetable\\">";\n        html += "<tr>";\n        html += " <th>Index</th>";\n        html += " <th>Name</th>";\n        html += " <th>Color</th>";\n        html += " <th>Function</th>";\n        html += " <th></th>";\n        html += "</tr>";\n        for (let i = 0; i < gltf.json.materials.length; i++)\n        {\n            html += printMaterial(gltf.json.materials[i], i);\n        }\n        html += "</table>";\n    }\n\n    // / ///////////////////////\n\n    html += "<div id=\\"groupMeshes\\">Meshes (" + gltf.json.meshes.length + ")</div>";\n\n    html += "<table id=\\"meshestable\\"  class=\\"table treetable\\">";\n    html += "<tr>";\n    html += " <th>Name</th>";\n    html += " <th>Node</th>";\n    html += " <th>Material</th>";\n    html += " <th>Vertices</th>";\n    html += " <th>Attributes</th>";\n    html += "</tr>";\n\n    let sizeBufferViews = [];\n    sizes.meshes = 0;\n    sizes.meshTargets = 0;\n\n    for (let i = 0; i < gltf.json.meshes.length; i++)\n    {\n        html += "<tr>";\n        html += "<td>" + gltf.json.meshes[i].name + "</td>";\n\n        html += "<td>";\n        let count = 0;\n        let nodename = "";\n        for (let j = 0; j < gltf.json.nodes.length; j++)\n        {\n            if (gltf.json.nodes[j].mesh == i)\n            {\n                count++;\n                if (count == 1)\n                {\n                    nodename = gltf.json.nodes[j].name;\n                }\n            }\n        }\n        if (count > 1) html += (count) + " nodes (" + nodename + " ...)";\n        else html += nodename;\n        html += "</td>";\n\n        // -------\n\n        html += "<td>";\n        for (let j = 0; j < gltf.json.meshes[i].primitives.length; j++)\n        {\n            if (gltf.json.meshes[i].primitives[j].hasOwnProperty("material"))\n            {\n                if (gltf.json.materials[gltf.json.meshes[i]])\n                {\n                    html += gltf.json.materials[gltf.json.meshes[i].primitives[j].material].name + " ";\n                }\n            }\n            else html += "None";\n        }\n        html += "</td>";\n\n        html += "<td>";\n        let numVerts = 0;\n        for (let j = 0; j < gltf.json.meshes[i].primitives.length; j++)\n        {\n            if (gltf.json.meshes[i].primitives[j].attributes.POSITION != undefined)\n            {\n                let v = parseInt(gltf.json.accessors[gltf.json.meshes[i].primitives[j].attributes.POSITION].count);\n                numVerts += v;\n                html += "" + v + "<br/>";\n            }\n            else html += "-<br/>";\n        }\n\n        if (gltf.json.meshes[i].primitives.length > 1)\n            html += "=" + numVerts;\n        html += "</td>";\n\n        html += "<td>";\n        for (let j = 0; j < gltf.json.meshes[i].primitives.length; j++)\n        {\n            html += Object.keys(gltf.json.meshes[i].primitives[j].attributes);\n            html += " <a onclick=\\"gui.corePatch().getOpById(\'" + op.id + "\').exposeGeom(\'" + gltf.json.meshes[i].name + "\'," + j + ")\\" class=\\"treebutton\\">Geometry</a>";\n            html += "<br/>";\n\n            if (gltf.json.meshes[i].primitives[j].targets)\n            {\n                html += gltf.json.meshes[i].primitives[j].targets.length + " targets<br/>";\n\n                if (gltf.json.meshes[i].extras && gltf.json.meshes[i].extras.targetNames)\n                    html += "Targetnames:<br/>" + gltf.json.meshes[i].extras.targetNames.join("<br/>");\n\n                html += "<br/>";\n            }\n        }\n\n        html += "</td>";\n        html += "</tr>";\n\n        for (let j = 0; j < gltf.json.meshes[i].primitives.length; j++)\n        {\n            const accessor = gltf.json.accessors[gltf.json.meshes[i].primitives[j].indices];\n            if (accessor)\n            {\n                let bufView = accessor.bufferView;\n\n                if (sizeBufferViews.indexOf(bufView) == -1)\n                {\n                    sizeBufferViews.push(bufView);\n                    if (gltf.json.bufferViews[bufView])sizes.meshes += gltf.json.bufferViews[bufView].byteLength;\n                }\n            }\n\n            for (let k in gltf.json.meshes[i].primitives[j].attributes)\n            {\n                const attr = gltf.json.meshes[i].primitives[j].attributes[k];\n                const bufView2 = gltf.json.accessors[attr].bufferView;\n\n                if (sizeBufferViews.indexOf(bufView2) == -1)\n                {\n                    sizeBufferViews.push(bufView2);\n                    if (gltf.json.bufferViews[bufView2])sizes.meshes += gltf.json.bufferViews[bufView2].byteLength;\n                }\n            }\n\n            if (gltf.json.meshes[i].primitives[j].targets)\n                for (let k = 0; k < gltf.json.meshes[i].primitives[j].targets.length; k++)\n                {\n                    for (let l in gltf.json.meshes[i].primitives[j].targets[k])\n                    {\n                        const accessorIdx = gltf.json.meshes[i].primitives[j].targets[k][l];\n                        const accessor = gltf.json.accessors[accessorIdx];\n                        const bufView2 = accessor.bufferView;\n                        console.log("accessor", accessor);\n                        if (sizeBufferViews.indexOf(bufView2) == -1)\n                            if (gltf.json.bufferViews[bufView2])\n                            {\n                                sizeBufferViews.push(bufView2);\n                                sizes.meshTargets += gltf.json.bufferViews[bufView2].byteLength;\n                            }\n                    }\n                }\n        }\n    }\n    html += "</table>";\n\n    // / //////////////////////////////////\n\n    let numSamplers = 0;\n    let numAnims = 0;\n\n    if (gltf.json.animations)\n    {\n        numAnims = gltf.json.animations.length;\n        for (let i = 0; i < gltf.json.animations.length; i++)\n            numSamplers += gltf.json.animations[i].samplers.length;\n    }\n\n    html += "<div id=\\"groupAnims\\">Animations (" + numAnims + "/" + numSamplers + ")</div>";\n\n    if (gltf.json.animations)\n    {\n        html += "<table id=\\"sectionAnim\\" class=\\"table treetable\\">";\n        html += "<tr>";\n        html += "  <th>Name</th>";\n        html += "  <th>Target node</th>";\n        html += "  <th>Path</th>";\n        html += "  <th>Interpolation</th>";\n        html += "  <th>Keys</th>";\n        html += "</tr>";\n\n        sizes.animations = 0;\n\n        for (let i = 0; i < gltf.json.animations.length; i++)\n        {\n            for (let j = 0; j < gltf.json.animations[i].samplers.length; j++)\n            {\n                let bufView = gltf.json.accessors[gltf.json.animations[i].samplers[j].input].bufferView;\n                if (sizeBufferViews.indexOf(bufView) == -1)\n                {\n                    sizeBufferViews.push(bufView);\n                    sizes.animations += gltf.json.bufferViews[bufView].byteLength;\n                }\n\n                bufView = gltf.json.accessors[gltf.json.animations[i].samplers[j].output].bufferView;\n                if (sizeBufferViews.indexOf(bufView) == -1)\n                {\n                    sizeBufferViews.push(bufView);\n                    sizes.animations += gltf.json.bufferViews[bufView].byteLength;\n                }\n            }\n\n            for (let j = 0; j < gltf.json.animations[i].channels.length; j++)\n            {\n                html += "<tr>";\n                html += "  <td> Anim " + i + ": " + gltf.json.animations[i].name + "</td>";\n\n                html += "  <td>" + gltf.nodes[gltf.json.animations[i].channels[j].target.node].name + "</td>";\n                html += "  <td>";\n                html += gltf.json.animations[i].channels[j].target.path + " ";\n                html += "  </td>";\n\n                const smplidx = gltf.json.animations[i].channels[j].sampler;\n                const smplr = gltf.json.animations[i].samplers[smplidx];\n\n                html += "  <td>" + smplr.interpolation + "</td>";\n\n                html += "  <td>" + gltf.json.accessors[smplr.output].count;\n\n                // html += "&nbsp;&nbsp;<a onclick=\\"gui.corePatch().getOpById(\'" + op.id + "\').showAnim(\'" + i + "\',\'" + j + "\')\\" class=\\"icon icon-search\\"></a>";\n\n                html += "</td>";\n\n                html += "</tr>";\n            }\n        }\n        html += "</table>";\n    }\n    else\n    {\n\n    }\n\n    // / ///////////////////\n\n    let numImages = 0;\n    if (gltf.json.images)numImages = gltf.json.images.length;\n    html += "<div id=\\"groupImages\\">Images (" + numImages + ")</div>";\n\n    if (gltf.json.images)\n    {\n        html += "<table id=\\"sectionImages\\" class=\\"table treetable\\">";\n\n        html += "<tr>";\n        html += "  <th>name</th>";\n        html += "  <th>type</th>";\n        html += "  <th>func</th>";\n        html += "</tr>";\n\n        sizes.images = 0;\n\n        for (let i = 0; i < gltf.json.images.length; i++)\n        {\n            if (gltf.json.images[i].hasOwnProperty("bufferView"))\n            {\n                // if (sizeBufferViews.indexOf(gltf.json.images[i].hasOwnProperty("bufferView")) == -1)console.log("image bufferview already there?!");\n                // else\n                sizes.images += gltf.json.bufferViews[gltf.json.images[i].bufferView].byteLength;\n            }\n            else console.log("image has no bufferview?!");\n\n            html += "<tr>";\n            html += "<td>" + gltf.json.images[i].name + "</td>";\n            html += "<td>" + gltf.json.images[i].mimeType + "</td>";\n            html += "<td>";\n\n            let name = gltf.json.images[i].name;\n            if (name === undefined)name = gltf.json.images[i].bufferView;\n\n            html += "<a onclick=\\"gui.corePatch().getOpById(\'" + op.id + "\').exposeTexture(\'" + name + "\')\\" class=\\"treebutton\\">Expose</a>";\n            html += "</td>";\n\n            html += "<tr>";\n        }\n        html += "</table>";\n    }\n\n    // / ///////////////////////\n\n    let numCameras = 0;\n    if (gltf.json.cameras)numCameras = gltf.json.cameras.length;\n    html += "<div id=\\"groupCameras\\">Cameras (" + numCameras + ")</div>";\n\n    if (gltf.json.cameras)\n    {\n        html += "<table id=\\"sectionCameras\\" class=\\"table treetable\\">";\n\n        html += "<tr>";\n        html += "  <th>name</th>";\n        html += "  <th>type</th>";\n        html += "  <th>info</th>";\n        html += "</tr>";\n\n        for (let i = 0; i < gltf.json.cameras.length; i++)\n        {\n            html += "<tr>";\n            html += "<td>" + gltf.json.cameras[i].name + "</td>";\n            html += "<td>" + gltf.json.cameras[i].type + "</td>";\n            html += "<td>";\n\n            if (gltf.json.cameras[i].perspective)\n            {\n                html += "yfov: " + Math.round(gltf.json.cameras[i].perspective.yfov * 100) / 100;\n                html += ", ";\n                html += "zfar: " + Math.round(gltf.json.cameras[i].perspective.zfar * 100) / 100;\n                html += ", ";\n                html += "znear: " + Math.round(gltf.json.cameras[i].perspective.znear * 100) / 100;\n            }\n            html += "</td>";\n\n            html += "<tr>";\n        }\n        html += "</table>";\n    }\n\n    // / ////////////////////////////////////\n\n    let numSkins = 0;\n    if (gltf.json.skins)numSkins = gltf.json.skins.length;\n    html += "<div id=\\"groupSkins\\">Skins (" + numSkins + ")</div>";\n\n    if (gltf.json.skins)\n    {\n        // html += "<h3>Skins (" + gltf.json.skins.length + ")</h3>";\n        html += "<table id=\\"sectionSkins\\" class=\\"table treetable\\">";\n\n        html += "<tr>";\n        html += "  <th>name</th>";\n        html += "  <th></th>";\n        html += "  <th>total joints</th>";\n        html += "</tr>";\n\n        for (let i = 0; i < gltf.json.skins.length; i++)\n        {\n            html += "<tr>";\n            html += "<td>" + gltf.json.skins[i].name + "</td>";\n            html += "<td>" + "</td>";\n            html += "<td>" + gltf.json.skins[i].joints.length + "</td>";\n            html += "<td>";\n            html += "</td>";\n            html += "<tr>";\n        }\n        html += "</table>";\n    }\n\n    // / ////////////////////////////////////\n\n    if (gltf.timing)\n    {\n        html += "<div id=\\"groupTiming\\">Debug Loading Timing </div>";\n\n        html += "<table id=\\"sectionTiming\\" class=\\"table treetable\\">";\n\n        html += "<tr>";\n        html += "  <th>task</th>";\n        html += "  <th>time used</th>";\n        html += "</tr>";\n\n        let lt = 0;\n        for (let i = 0; i < gltf.timing.length - 1; i++)\n        {\n            html += "<tr>";\n            html += "  <td>" + gltf.timing[i][0] + "</td>";\n            html += "  <td>" + (gltf.timing[i + 1][1] - gltf.timing[i][1]) + " ms</td>";\n            html += "</tr>";\n            // lt = gltf.timing[i][1];\n        }\n        html += "</table>";\n    }\n\n    // / //////////////////////////\n\n    let sizeBin = 0;\n    if (gltf.json.buffers)\n        sizeBin = gltf.json.buffers[0].byteLength;\n\n    html += "<div id=\\"groupBinary\\">File Size Allocation (" + Math.round(sizeBin / 1024) + "k )</div>";\n\n    html += "<table id=\\"sectionBinary\\" class=\\"table treetable\\">";\n    html += "<tr>";\n    html += "  <th>name</th>";\n    html += "  <th>size</th>";\n    html += "  <th>%</th>";\n    html += "</tr>";\n    let sizeUnknown = sizeBin;\n    for (let i in sizes)\n    {\n        // html+=i+\':\'+Math.round(sizes[i]/1024);\n        html += "<tr>";\n        html += "<td>" + i + "</td>";\n        html += "<td>" + readableSize(sizes[i]) + " </td>";\n        html += "<td>" + Math.round(sizes[i] / sizeBin * 100) + "% </td>";\n        html += "<tr>";\n        sizeUnknown -= sizes[i];\n    }\n\n    if (sizeUnknown != 0)\n    {\n        html += "<tr>";\n        html += "<td>unknown</td>";\n        html += "<td>" + readableSize(sizeUnknown) + " </td>";\n        html += "<td>" + Math.round(sizeUnknown / sizeBin * 100) + "% </td>";\n        html += "<tr>";\n    }\n\n    html += "</table>";\n    html += "</div>";\n\n    tab = new CABLES.UI.Tab("GLTF " + CABLES.basename(inFile.get()), { "icon": "cube", "infotext": "tab_gltf", "padding": true, "singleton": true });\n    gui.mainTabs.addTab(tab, true);\n\n    tab.addEventListener("onClose", closeTab);\n    tab.html(html);\n\n    CABLES.UI.Collapsable.setup(ele.byId("groupNodes"), ele.byId("sectionNodes"), false);\n    CABLES.UI.Collapsable.setup(ele.byId("groupMaterials"), ele.byId("materialtable"), true);\n    CABLES.UI.Collapsable.setup(ele.byId("groupAnims"), ele.byId("sectionAnim"), true);\n    CABLES.UI.Collapsable.setup(ele.byId("groupMeshes"), ele.byId("meshestable"), true);\n    CABLES.UI.Collapsable.setup(ele.byId("groupCameras"), ele.byId("sectionCameras"), true);\n    CABLES.UI.Collapsable.setup(ele.byId("groupImages"), ele.byId("sectionImages"), true);\n    CABLES.UI.Collapsable.setup(ele.byId("groupSkins"), ele.byId("sectionSkins"), true);\n    CABLES.UI.Collapsable.setup(ele.byId("groupBinary"), ele.byId("sectionBinary"), true);\n    CABLES.UI.Collapsable.setup(ele.byId("groupTiming"), ele.byId("sectionTiming"), true);\n\n    gui.maintabPanel.show(true);\n}\n\nfunction readableSize(n)\n{\n    if (n > 1024) return Math.round(n / 1024) + " kb";\n    if (n > 1024 * 500) return Math.round(n / 1024) + " mb";\n    else return n + " bytes";\n}\n',
        inc_skin_js: 'const GltfSkin = class\n{\n    constructor(node)\n    {\n        this._mod = null;\n        this._node = node;\n        this._lastTime = 0;\n        this._matArr = [];\n        this._m = mat4.create();\n        this._invBindMatrix = mat4.create();\n        this.identity = true;\n    }\n\n    renderFinish(cgl)\n    {\n        cgl.popModelMatrix();\n        this._mod.unbind();\n    }\n\n    renderStart(cgl, time)\n    {\n        if (!this._mod)\n        {\n            this._mod = new CGL.ShaderModifier(cgl, op.name + this._node.name);\n\n            this._mod.addModule({\n                "priority": -2,\n                "name": "MODULE_VERTEX_POSITION",\n                "srcHeadVert": attachments.skin_head_vert || "",\n                "srcBodyVert": attachments.skin_vert || ""\n            });\n\n            this._mod.addUniformVert("m4[]", "MOD_boneMats", []);// bohnenmatze\n            const tr = vec3.create();\n        }\n\n        const skinIdx = this._node.skin;\n        const arrLength = gltf.json.skins[skinIdx].joints.length * 16;\n\n        // if (this._lastTime != time || !time)\n        {\n            // this._lastTime=inTime.get();\n            if (this._matArr.length != arrLength) this._matArr.length = arrLength;\n\n            for (let i = 0; i < gltf.json.skins[skinIdx].joints.length; i++)\n            {\n                const i16 = i * 16;\n                const jointIdx = gltf.json.skins[skinIdx].joints[i];\n                const nodeJoint = gltf.nodes[jointIdx];\n\n                for (let j = 0; j < 16; j++)\n                    this._invBindMatrix[j] = gltf.accBuffers[gltf.json.skins[skinIdx].inverseBindMatrices][i16 + j];\n\n                mat4.mul(this._m, nodeJoint.modelMatAbs(), this._invBindMatrix);\n\n                for (let j = 0; j < this._m.length; j++) this._matArr[i16 + j] = this._m[j];\n            }\n\n            this._mod.setUniformValue("MOD_boneMats", this._matArr);\n            this._lastTime = time;\n        }\n\n        this._mod.define("SKIN_NUM_BONES", gltf.json.skins[skinIdx].joints.length);\n        this._mod.bind();\n\n        // draw mesh...\n        cgl.pushModelMatrix();\n        if (this.identity)mat4.identity(cgl.mMatrix);\n    }\n};\n',
        inc_targets_js: 'const GltfTargetsRenderer = class\n{\n    constructor(mesh)\n    {\n        this.mesh = mesh;\n        this.tex = null;\n        this.numRowsPerTarget = 0;\n\n        this.makeTex(mesh.geom);\n    }\n\n    renderFinish(cgl)\n    {\n        cgl.popModelMatrix();\n        this._mod.unbind();\n    }\n\n    renderStart(cgl, time)\n    {\n        if (!this._mod)\n        {\n            this._mod = new CGL.ShaderModifier(cgl, "gltftarget");\n\n            this._mod.addModule({\n                "priority": -2,\n                "name": "MODULE_VERTEX_POSITION",\n                "srcHeadVert": attachments.targets_head_vert || "",\n                "srcBodyVert": attachments.targets_vert || ""\n            });\n\n            this._mod.addUniformVert("4f", "MOD_targetTexInfo", [0, 0, 0, 0]);\n            this._mod.addUniformVert("t", "MOD_targetTex", 1);\n            this._mod.addUniformVert("f[]", "MOD_weights", []);\n\n            const tr = vec3.create();\n        }\n\n        // if (this.tex && this.mesh.weights)\n        // {\n        // }\n        this._mod.pushTexture("MOD_targetTex", this.tex);\n        this._mod.setUniformValue("MOD_weights", this.mesh.weights);\n        this._mod.setUniformValue("MOD_targetTexInfo", [this.tex.width, this.tex.height, this.numRowsPerTarget, this.mesh.weights.length]);\n\n        // console.log("MOD_NUM_WEIGHTS",this.mesh.weights)\n        this._mod.define("MOD_NUM_WEIGHTS", Math.max(1, this.mesh.weights.length));\n        this._mod.bind();\n\n        // draw mesh...\n        cgl.pushModelMatrix();\n        if (this.identity)mat4.identity(cgl.mMatrix);\n    }\n\n    makeTex(geom)\n    {\n        if (!geom.morphTargets || !geom.morphTargets.length) return;\n\n        let w = geom.morphTargets[0].vertices.length / 3;\n        let h = 0;\n        this.numRowsPerTarget = 0;\n\n        if (geom.morphTargets[0].vertices && geom.morphTargets[0].vertices.length) this.numRowsPerTarget++;\n        if (geom.morphTargets[0].vertexNormals && geom.morphTargets[0].vertexNormals.length) this.numRowsPerTarget++;\n        if (geom.morphTargets[0].tangents && geom.morphTargets[0].tangents.length) this.numRowsPerTarget++;\n        if (geom.morphTargets[0].bitangents && geom.morphTargets[0].bitangents.length) this.numRowsPerTarget++;\n\n        h = geom.morphTargets.length * this.numRowsPerTarget;\n\n        // console.log("this.numRowsPerTarget", this.numRowsPerTarget);\n\n        const pixels = new Float32Array(w * h * 4);\n        let row = 0;\n\n        for (let i = 0; i < geom.morphTargets.length; i++)\n        {\n            if (geom.morphTargets[i].vertices && geom.morphTargets[i].vertices.length)\n            {\n                for (let j = 0; j < geom.morphTargets[i].vertices.length; j += 3)\n                {\n                    pixels[((row * w) + (j / 3)) * 4 + 0] = geom.morphTargets[i].vertices[j + 0];\n                    pixels[((row * w) + (j / 3)) * 4 + 1] = geom.morphTargets[i].vertices[j + 1];\n                    pixels[((row * w) + (j / 3)) * 4 + 2] = geom.morphTargets[i].vertices[j + 2];\n                    pixels[((row * w) + (j / 3)) * 4 + 3] = 1;\n                }\n                row++;\n            }\n\n            if (geom.morphTargets[i].vertexNormals && geom.morphTargets[i].vertexNormals.length)\n            {\n                for (let j = 0; j < geom.morphTargets[i].vertexNormals.length; j += 3)\n                {\n                    pixels[(row * w + j / 3) * 4 + 0] = geom.morphTargets[i].vertexNormals[j + 0];\n                    pixels[(row * w + j / 3) * 4 + 1] = geom.morphTargets[i].vertexNormals[j + 1];\n                    pixels[(row * w + j / 3) * 4 + 2] = geom.morphTargets[i].vertexNormals[j + 2];\n                    pixels[(row * w + j / 3) * 4 + 3] = 1;\n                }\n\n                row++;\n            }\n\n            if (geom.morphTargets[i].tangents && geom.morphTargets[i].tangents.length)\n            {\n                for (let j = 0; j < geom.morphTargets[i].tangents.length; j += 3)\n                {\n                    pixels[(row * w + j / 3) * 4 + 0] = geom.morphTargets[i].tangents[j + 0];\n                    pixels[(row * w + j / 3) * 4 + 1] = geom.morphTargets[i].tangents[j + 1];\n                    pixels[(row * w + j / 3) * 4 + 2] = geom.morphTargets[i].tangents[j + 2];\n                    pixels[(row * w + j / 3) * 4 + 3] = 1;\n                }\n                row++;\n            }\n\n            if (geom.morphTargets[i].bitangents && geom.morphTargets[i].bitangents.length)\n            {\n                for (let j = 0; j < geom.morphTargets[i].bitangents.length; j += 3)\n                {\n                    pixels[(row * w + j / 3) * 4 + 0] = geom.morphTargets[i].bitangents[j + 0];\n                    pixels[(row * w + j / 3) * 4 + 1] = geom.morphTargets[i].bitangents[j + 1];\n                    pixels[(row * w + j / 3) * 4 + 2] = geom.morphTargets[i].bitangents[j + 2];\n                    pixels[(row * w + j / 3) * 4 + 3] = 1;\n                }\n                row++;\n            }\n        }\n\n        this.tex = new CGL.Texture(cgl, { "isFloatingPointTexture": true, "name": "targetsTexture" });\n\n        this.tex.initFromData(pixels, w, h, CGL.Texture.FILTER_LINEAR, CGL.Texture.WRAP_REPEAT);\n\n        console.log("morphTargets generated texture", w, h);\n    }\n};\n',
        skin_vert: "int index=int(attrJoints.x);\nvec4 newPos = (MOD_boneMats[index] * pos) * attrWeights.x;\nvec3 newNorm = (vec4((MOD_boneMats[index] * vec4(norm.xyz, 0.0)) * attrWeights.x).xyz);\n\nindex=int(attrJoints.y);\nnewPos += (MOD_boneMats[index] * pos) * attrWeights.y;\nnewNorm = (vec4((MOD_boneMats[index] * vec4(norm.xyz, 0.0)) * attrWeights.y).xyz)+newNorm;\n\nindex=int(attrJoints.z);\nnewPos += (MOD_boneMats[index] * pos) * attrWeights.z;\nnewNorm = (vec4((MOD_boneMats[index] * vec4(norm.xyz, 0.0)) * attrWeights.z).xyz)+newNorm;\n\nindex=int(attrJoints.w);\nnewPos += (MOD_boneMats[index] * pos) * attrWeights.w ;\nnewNorm = (vec4((MOD_boneMats[index] * vec4(norm.xyz, 0.0)) * attrWeights.w).xyz)+newNorm;\n\npos=newPos;\n\nnorm=normalize(newNorm.xyz);\n\n\n",
        skin_head_vert: "\nIN vec4 attrWeights;\nIN vec4 attrJoints;\nUNI mat4 MOD_boneMats[SKIN_NUM_BONES];\n",
        targets_vert: "\n\nfloat MOD_width=MOD_targetTexInfo.x;\nfloat MOD_height=MOD_targetTexInfo.y;\nfloat MOD_numTargets=MOD_targetTexInfo.w;\nfloat MOD_numLinesPerTarget=MOD_height/MOD_numTargets;\n\nfloat halfpix=(1.0/MOD_width)*0.5;\nfloat halfpixy=(1.0/MOD_height)*0.5;\n\nfloat x=(attrVertIndex)/MOD_width+halfpix;\n\nvec3 off=vec3(0.0);\n\nfor(float i=0.0;i<MOD_numTargets;i+=1.0)\n{\n    float y=1.0-((MOD_numLinesPerTarget*i)/MOD_height+halfpixy);\n    vec2 coord=vec2(x,y);\n    vec3 targetXYZ = texture(MOD_targetTex,coord).xyz;\n\n    off+=(targetXYZ*MOD_weights[int(i)]);\n\n\n\n    coord.y+=1.0/MOD_height; // normals are in next row\n    vec3 targetNormal = texture(MOD_targetTex,coord).xyz;\n    norm+=targetNormal*MOD_weights[int(i)];\n\n\n}\n\n// norm=normalize(norm);\npos.xyz+=off;\n",
        targets_head_vert: "\nUNI float MOD_weights[MOD_NUM_WEIGHTS];\n"
    };
    const j = class {
        constructor(e, t) {
            this.node = t;
            this.name = t.name;
            this.config = e.json.cameras[t.camera];
            this.pos = vec3.create();
            this.quat = quat.create();
            this.vCenter = vec3.create();
            this.vUp = vec3.create();
            this.vMat = mat4.create()
        }
        updateAnim(e) {
            if (this.node && this.node._animTrans) {
                vec3.set(this.pos, this.node._animTrans[0].getValue(e), this.node._animTrans[1].getValue(e), this.node._animTrans[2].getValue(e));
                quat.set(this.quat, this.node._animRot[0].getValue(e), this.node._animRot[1].getValue(e), this.node._animRot[2].getValue(e), this.node._animRot[3].getValue(e))
            }
        }
        start(e) {
            if (m.frameStore.shadowPass) return;
            this.updateAnim(e);
            const t = m.getViewPort()[2] / m.getViewPort()[3];
            m.pushPMatrix();
            m.pushViewMatrix();
            let n = mat4.create();
            mat4.invert(n, this.node.modelMatAbs());
            this.vMat = n;
            mat4.identity(m.vMatrix);
            mat4.mul(m.vMatrix, m.vMatrix, n)
        }
        end() {
            if (m.frameStore.shadowPass) return;
            m.popPMatrix();
            m.popViewMatrix()
        }
    };
    const C = true;
    const V = class {
        constructor() {
            this.json = {};
            this.accBuffers = [];
            this.meshes = [];
            this.nodes = [];
            this.shaders = [];
            this.timing = [];
            this.cams = [];
            this.startTime = performance.now();
            this.bounds = new CABLES.CG.BoundingBox;
            this.loaded = Date.now();
            this.accBuffersDelete = []
        }
        getNode(t) {
            for (let e = 0; e < this.nodes.length; e++) {
                if (this.nodes[e].name == t) return this.nodes[e]
            }
        }
        unHideAll() {
            for (let e = 0; e < this.nodes.length; e++) {
                this.nodes[e].unHide()
            }
        }
    };

    function S(e) {
        if (window.TextDecoder) return new TextDecoder("utf-8").decode(e);
        let t, n, i, s;
        let r, a;
        t = "";
        i = e.length;
        n = 0;
        while (n < i) {
            s = e[n++];
            switch (s >> 4) {
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                case 7:
                    t += String.fromCharCode(s);
                    break;
                case 12:
                case 13:
                    r = e[n++];
                    t += String.fromCharCode((s & 31) << 6 | r & 63);
                    break;
                case 14:
                    r = e[n++];
                    a = e[n++];
                    t += String.fromCharCode((s & 15) << 12 | (r & 63) << 6 | (a & 63) << 0);
                    break
            }
        }
        return t
    }

    function A(e, t, n, i) {
        const s = {};
        if (i >= e.byteLength) {
            y.log("could not read chunk...");
            return
        }
        s.size = e.getUint32(i + 0, C);
        s.type = S(t.subarray(i + 4, i + 4 + 4));
        if (s.type == "BIN\0") {
            s.dataView = new DataView(n, i + 8, s.size)
        } else if (s.type == "JSON") {
            const r = S(t.subarray(i + 8, i + 8 + s.size));
            try {
                const a = JSON.parse(r);
                s.data = a;
                ae.set(a.asset.generator)
            } catch (e) {}
        } else {
            y.warn("unknown type", s.type)
        }
        return s
    }

    function P(t) {
        const i = {};
        for (let e = 0; e < t.json.animations.length; e++) {
            const s = t.json.animations[e];
            s.name = s.name || "unknown";
            for (let e = 0; e < s.channels.length; e++) {
                const r = s.channels[e];
                const a = t.nodes[r.target.node];
                const o = s.samplers[r.sampler];
                const n = t.json.accessors[o.input];
                const l = t.accBuffers[o.input];
                const h = t.json.accessors[o.output];
                const c = t.accBuffers[o.output];
                t.accBuffersDelete.push(o.output, o.input);
                if (l && c) {
                    let n = 1;
                    if (h.type === "VEC2") n = 2;
                    else if (h.type === "VEC3") n = 3;
                    else if (h.type === "VEC4") n = 4;
                    else if (h.type === "SCALAR") {
                        n = c.length / l.length
                    } else y.log("[] UNKNOWN accOut.type", h.type);
                    const u = [];
                    i[s.name] = true;
                    for (let e = 0; e < n; e++) {
                        const d = new CABLES.Anim;
                        u.push(d)
                    }
                    if (o.interpolation === "LINEAR") {} else if (o.interpolation === "STEP")
                        for (let e = 0; e < n; e++) u[e].defaultEasing = CABLES.EASING_ABSOLUTE;
                    else if (o.interpolation === "CUBICSPLINE")
                        for (let e = 0; e < n; e++) u[e].defaultEasing = CABLES.EASING_CUBICSPLINE;
                    else y.warn("unknown interpolation", o.interpolation);
                    if (l[0] !== 0)
                        for (let e = 0; e < n; e++) u[e].setValue(0, c[0 * n + e]);
                    for (let t = 0; t < l.length; t++) {
                        T = Math.max(l[t], T);
                        for (let e = 0; e < n; e++) {
                            if (u[e].defaultEasing === CABLES.EASING_CUBICSPLINE) {
                                const g = t * n * 3 + e;
                                const m = u[e].setValue(l[t], c[g + n]);
                                m.bezTangIn = c[g];
                                m.bezTangOut = c[g + n * 2]
                            } else {
                                u[e].setValue(l[t], c[t * n + e])
                            }
                        }
                    }
                    a.setAnim(r.target.path, s.name, u)
                } else {
                    y.warn("loadAmins bufferIn undefined ", l === undefined);
                    y.warn("loadAmins bufferOut undefined ", c === undefined);
                    y.warn("loadAmins ", o, h);
                    y.warn("loadAmins num accBuffers", t.accBuffers.length);
                    y.warn("loadAmins num accessors", t.json.accessors.length)
                }
            }
        }
        t.uniqueAnimNames = i;
        de.setRef(Object.keys(i))
    }

    function D(n) {
        if (!n || !n.json.cameras) return;
        n.cameras = n.cameras || [];
        for (let t = 0; t < n.nodes.length; t++) {
            if (n.nodes[t].hasOwnProperty("camera")) {
                const e = new j(n, n.nodes[t]);
                n.cameras.push(e)
            }
        }
    }

    function U() {
        if (!window.DracoDecoder) {
            setTimeout(() => {
                U()
            }, 100)
        }
        k()
    }

    function G(e) {
        const t = 8;
        let s = 0,
            n = 0;
        const r = new V;
        r.timing.push(["Start parsing", Math.round(performance.now() - r.startTime)]);
        if (!e) return;
        const i = new Uint8Array(e);
        let a = 0;
        const o = S(i.subarray(a, 4));
        a += 4;
        if (o != "glTF") return;
        r.timing.push(["dataview", Math.round(performance.now() - r.startTime)]);
        const l = new DataView(e);
        const h = l.getUint32(a, C);
        a += 4;
        const c = l.getUint32(a, C);
        a += 4;
        oe.set(h);
        const u = [];
        r.chunks = u;
        u.push(A(l, i, e, a));
        a += u[0].size + t;
        r.json = u[0].data;
        r.cables = {
            fileUrl: w.get(),
            shortFileName: CABLES.basename(w.get())
        };
        ue.setRef(r.json);
        le.setRef(r.json.extensionsUsed || []);
        let d = A(l, i, e, a);
        while (d) {
            u.push(d);
            a += d.size + t;
            d = A(l, i, e, a)
        }
        r.chunks = u;
        const g = u[0].data.bufferViews;
        const m = u[0].data.accessors;
        r.timing.push(["Parse buffers", Math.round(performance.now() - r.startTime)]);
        if (r.json.extensionsUsed && r.json.extensionsUsed.indexOf("KHR_draco_mesh_compression") > -1) {
            if (!window.DracoDecoder) {
                y.setUiError("gltfdraco", "GLTF draco compression lib not found / add draco op to your patch!");
                U();
                return r
            } else {
                r.useDraco = true
            }
        }
        y.setUiError("gltfdraco", null);
        if (g) {
            for (n = 0; n < m.length; n++) {
                const f = m[n];
                const p = g[f.bufferView];
                let i = 0;
                if (f.type == "SCALAR") i = 1;
                else if (f.type == "VEC2") i = 2;
                else if (f.type == "VEC3") i = 3;
                else if (f.type == "VEC4") i = 4;
                else if (f.type == "MAT4") i = 16;
                else console.error("unknown accessor type", f.type);
                if (u[1].dataView) {
                    if (p) {
                        const b = f.count * i;
                        let e = (p.byteOffset || 0) + (f.byteOffset || 0);
                        let t = p.byteStride || 0;
                        let n = null;
                        if (f.componentType == 5126 || f.componentType == 5125) {
                            t = t || 4;
                            const _ = f.componentType == 5125;
                            if (_) n = new Uint32Array(b);
                            else n = new Float32Array(b);
                            for (s = 0; s < b; s++) {
                                if (_) n[s] = u[1].dataView.getUint32(e, C);
                                else n[s] = u[1].dataView.getFloat32(e, C);
                                if (t != 4 && (s + 1) % i === 0) e += t - i * 4;
                                e += 4
                            }
                        } else if (f.componentType == 5123) {
                            t = t || 2;
                            n = new Uint16Array(b);
                            for (s = 0; s < b; s++) {
                                n[s] = u[1].dataView.getUint16(e, C);
                                if (t != 2 && (s + 1) % i === 0) e += t - i * 2;
                                e += 2
                            }
                        } else if (f.componentType == 5121) {
                            t = t || 1;
                            n = new Uint8Array(b);
                            for (s = 0; s < b; s++) {
                                n[s] = u[1].dataView.getUint8(e, C);
                                if (t != 1 && (s + 1) % i === 0) e += t - i * 1;
                                e += 1
                            }
                        } else {
                            console.error("unknown component type", f.componentType)
                        }
                        r.accBuffers.push(n)
                    } else {}
                }
            }
        }
        r.timing.push(["Parse mesh groups", Math.round(performance.now() - r.startTime)]);
        r.json.meshes = r.json.meshes || [];
        if (r.json.meshes) {
            for (n = 0; n < r.json.meshes.length; n++) {
                const v = new z(r, r.json.meshes[n]);
                r.meshes.push(v)
            }
        }
        r.timing.push(["Parse nodes", Math.round(performance.now() - r.startTime)]);
        for (n = 0; n < r.json.nodes.length; n++) {
            if (r.json.nodes[n].children)
                for (s = 0; s < r.json.nodes[n].children.length; s++) {
                    r.json.nodes[r.json.nodes[n].children[s]].isChild = true
                }
        }
        for (n = 0; n < r.json.nodes.length; n++) {
            const x = new $(r.json.nodes[n], r);
            r.nodes.push(x)
        }
        for (n = 0; n < r.nodes.length; n++) {
            const x = r.nodes[n];
            if (!x.children) continue;
            for (let e = 0; e < x.children.length; e++) {
                r.nodes[x.children[e]].parent = x
            }
        }
        for (n = 0; n < r.nodes.length; n++) {
            r.nodes[n].initSkin()
        }
        O = true;
        r.timing.push(["load anims", Math.round(performance.now() - r.startTime)]);
        if (r.json.animations) P(r);
        r.timing.push(["load cameras", Math.round(performance.now() - r.startTime)]);
        if (r.json.cameras) D(r);
        r.timing.push(["finished", Math.round(performance.now() - r.startTime)]);
        return r
    }
    let F = class {
        constructor(e, n, r, a) {
            this.POINTS = 0;
            this.LINES = 1;
            this.LINE_LOOP = 2;
            this.LINE_STRIP = 3;
            this.TRIANGLES = 4;
            this.TRIANGLE_STRIP = 5;
            this.TRIANGLE_FAN = 6;
            this.test = 0;
            this.name = e;
            this.submeshIndex = 0;
            this.material = n.material;
            this.mesh = null;
            this.geom = new CGL.Geometry("gltf_" + this.name);
            this.geom.verticesIndices = [];
            this.bounds = null;
            this.primitive = 4;
            this.morphTargetsRenderMod = null;
            this.weights = n.weights;
            if (n.hasOwnProperty("mode")) this.primitive = n.mode;
            if (n.hasOwnProperty("indices")) this.geom.verticesIndices = r.accBuffers[n.indices];
            r.loadingMeshes = r.loadingMeshes || 0;
            r.loadingMeshes++;
            this.materialJson = this._matPbrMetalness = this._matPbrRoughness = this._matDiffuseColor = null;
            if (r.json.materials) {
                if (this.material != -1) this.materialJson = r.json.materials[this.material];
                if (this.materialJson && this.materialJson.pbrMetallicRoughness) {
                    if (!this.materialJson.pbrMetallicRoughness.hasOwnProperty("baseColorFactor")) {
                        this._matDiffuseColor = [1, 1, 1, 1]
                    } else {
                        this._matDiffuseColor = this.materialJson.pbrMetallicRoughness.baseColorFactor
                    }
                    this._matDiffuseColor = this.materialJson.pbrMetallicRoughness.baseColorFactor;
                    if (!this.materialJson.pbrMetallicRoughness.hasOwnProperty("metallicFactor")) {
                        this._matPbrMetalness = 1
                    } else {
                        this._matPbrMetalness = this.materialJson.pbrMetallicRoughness.metallicFactor || null
                    }
                    if (!this.materialJson.pbrMetallicRoughness.hasOwnProperty("roughnessFactor")) {
                        this._matPbrRoughness = 1
                    } else {
                        this._matPbrRoughness = this.materialJson.pbrMetallicRoughness.roughnessFactor || null
                    }
                }
            }
            if (r.useDraco && n.extensions.KHR_draco_mesh_compression) {
                const i = r.chunks[0].data.bufferViews[n.extensions.KHR_draco_mesh_compression.bufferView];
                const s = i.byteLength;
                const o = new Int8Array(s);
                let t = i.byteOffset || 0;
                for (let e = 0; e < s; e++) {
                    o[e] = r.chunks[1].dataView.getInt8(t, C);
                    t++
                }
                const l = window.DracoDecoder;
                l.decodeGeometry(o.buffer, t => {
                    const n = new CGL.Geometry("draco mesh " + e);
                    for (let e = 0; e < t.attributes.length; e++) {
                        const i = t.attributes[e];
                        if (i.name === "position") n.vertices = i.array;
                        else if (i.name === "normal") n.vertexNormals = i.array;
                        else if (i.name === "uv") n.texCoords = i.array;
                        else if (i.name === "color") n.vertexColors = this.calcVertexColors(i.array);
                        else if (i.name === "joints") n.setAttribute("attrJoints", Array.from(i.array), 4);
                        else if (i.name === "weights") {
                            const s = new Float32Array(i.array.length / i.itemSize * 4);
                            for (let t = 0; t < i.array.length / i.itemSize; t++) {
                                s[t * 4] = s[t * 4 + 1] = s[t * 4 + 2] = s[t * 4 + 3] = 0;
                                for (let e = 0; e < i.itemSize; e++) s[t * 4 + e] = i.array[t * i.itemSize + e]
                            }
                            n.setAttribute("attrWeights", s, 4)
                        } else y.logWarn("unknown draco attrib", i)
                    }
                    t.attributes = null;
                    n.verticesIndices = t.index.array;
                    this.setGeom(n);
                    this.mesh = null;
                    r.loadingMeshes--;
                    r.timing.push(["draco decode", Math.round(performance.now() - r.startTime)]);
                    if (a) a(this)
                }, e => {
                    y.logError(e)
                })
            } else {
                r.loadingMeshes--;
                this.fillGeomAttribs(r, this.geom, n.attributes);
                if (n.targets) {
                    console.log("prim.targets", n.targets.length);
                    for (let e = 0; e < n.targets.length; e++) {
                        const t = new CGL.Geometry("gltf_target_" + e);
                        this.fillGeomAttribs(r, t, n.targets[e], false);
                        this.geom.morphTargets.push(t)
                    }
                }
                if (a) a(this)
            }
        }
        _linearToSrgb(e) {
            if (e <= 0) return 0;
            else if (e >= 1) return 1;
            else if (e < .0031308) return e * 12.92;
            else return e ** (1 / 2.2) * 1.055 - .055
        }
        calcVertexColors(n) {
            let i = null;
            if (n instanceof Float32Array) {
                let t = false;
                for (let e = 0; e < n.length; e++) {
                    if (n[e] > 1) {
                        t = true;
                        continue
                    }
                }
                if (t)
                    for (let e = 0; e < n.length; e++) n[e] /= 65535;
                i = n
            } else if (n instanceof Uint16Array) {
                const t = new Float32Array(n.length);
                for (let e = 0; e < n.length; e++) t[e] = n[e] / 65535;
                i = t
            } else i = n;
            for (let e = 0; e < i.length; e++) {
                i[e] = this._linearToSrgb(i[e])
            }
            return i
        }
        fillGeomAttribs(e, t, n, i) {
            if (n.hasOwnProperty("POSITION")) t.vertices = e.accBuffers[n.POSITION];
            if (n.hasOwnProperty("NORMAL")) t.vertexNormals = e.accBuffers[n.NORMAL];
            if (n.hasOwnProperty("TANGENT")) t.tangents = e.accBuffers[n.TANGENT];
            if (n.hasOwnProperty("COLOR_0")) t.vertexColors = this.calcVertexColors(e.accBuffers[n.COLOR_0]);
            if (n.hasOwnProperty("COLOR_1")) t.setAttribute("attrVertColor1", this.calcVertexColors(e.accBuffers[n.COLOR_1]), 4);
            if (n.hasOwnProperty("COLOR_2")) t.setAttribute("attrVertColor2", this.calcVertexColors(e.accBuffers[n.COLOR_2]), 4);
            if (n.hasOwnProperty("COLOR_3")) t.setAttribute("attrVertColor3", this.calcVertexColors(e.accBuffers[n.COLOR_3]), 4);
            if (n.hasOwnProperty("COLOR_4")) t.setAttribute("attrVertColor4", this.calcVertexColors(e.accBuffers[n.COLOR_4]), 4);
            if (n.hasOwnProperty("TEXCOORD_0")) t.texCoords = e.accBuffers[n.TEXCOORD_0];
            if (n.hasOwnProperty("TEXCOORD_1")) t.setAttribute("attrTexCoord1", e.accBuffers[n.TEXCOORD_1], 2);
            if (n.hasOwnProperty("TEXCOORD_2")) t.setAttribute("attrTexCoord2", e.accBuffers[n.TEXCOORD_2], 2);
            if (n.hasOwnProperty("TEXCOORD_3")) t.setAttribute("attrTexCoord3", e.accBuffers[n.TEXCOORD_3], 2);
            if (n.hasOwnProperty("TEXCOORD_4")) t.setAttribute("attrTexCoord4", e.accBuffers[n.TEXCOORD_4], 2);
            if (n.hasOwnProperty("WEIGHTS_0")) {
                t.setAttribute("attrWeights", e.accBuffers[n.WEIGHTS_0], 4)
            }
            if (n.hasOwnProperty("JOINTS_0")) {
                if (!e.accBuffers[n.JOINTS_0]) console.log("no !gltf.accBuffers[attribs.JOINTS_0]");
                t.setAttribute("attrJoints", e.accBuffers[n.JOINTS_0], 4)
            }
            if (n.hasOwnProperty("POSITION")) e.accBuffersDelete.push(n.POSITION);
            if (n.hasOwnProperty("NORMAL")) e.accBuffersDelete.push(n.NORMAL);
            if (n.hasOwnProperty("TEXCOORD_0")) e.accBuffersDelete.push(n.TEXCOORD_0);
            if (n.hasOwnProperty("TANGENT")) e.accBuffersDelete.push(n.TANGENT);
            if (n.hasOwnProperty("COLOR_0")) e.accBuffersDelete.push(n.COLOR_0);
            if (n.hasOwnProperty("COLOR_0")) e.accBuffersDelete.push(n.COLOR_0);
            if (n.hasOwnProperty("COLOR_1")) e.accBuffersDelete.push(n.COLOR_1);
            if (n.hasOwnProperty("COLOR_2")) e.accBuffersDelete.push(n.COLOR_2);
            if (n.hasOwnProperty("COLOR_3")) e.accBuffersDelete.push(n.COLOR_3);
            if (n.hasOwnProperty("TEXCOORD_1")) e.accBuffersDelete.push(n.TEXCOORD_1);
            if (n.hasOwnProperty("TEXCOORD_2")) e.accBuffersDelete.push(n.TEXCOORD_2);
            if (n.hasOwnProperty("TEXCOORD_3")) e.accBuffersDelete.push(n.TEXCOORD_3);
            if (n.hasOwnProperty("TEXCOORD_4")) e.accBuffersDelete.push(n.TEXCOORD_4);
            if (i !== false)
                if (t && t.verticesIndices) this.setGeom(t)
        }
        setGeom(n) {
            if (te.get() == "X-ZY") {
                for (let t = 0; t < n.vertexNormals.length; t += 3) {
                    let e = n.vertexNormals[t + 2];
                    n.vertexNormals[t + 2] = n.vertexNormals[t + 1];
                    n.vertexNormals[t + 1] = -e
                }
            }
            if (ne.get() == "XZ-Y") {
                for (let t = 0; t < n.vertices.length; t += 3) {
                    let e = n.vertices[t + 2];
                    n.vertices[t + 2] = -n.vertices[t + 1];
                    n.vertices[t + 1] = e
                }
            }
            if (this.primitive == this.TRIANGLES) {
                if (c.get() == "Force Smooth") n.calculateNormals();
                else if (!n.vertexNormals.length && c.get() == "Auto") n.calculateNormals({
                    smooth: false
                });
                if ((!n.biTangents || n.biTangents.length == 0) && n.tangents) {
                    const t = vec3.create();
                    const e = vec3.create();
                    const i = n.tangents;
                    n.tangents = new Float32Array(i.length / 4 * 3);
                    n.biTangents = new Float32Array(i.length / 4 * 3);
                    for (let e = 0; e < i.length; e += 4) {
                        const s = e / 4 * 3;
                        vec3.cross(t, [n.vertexNormals[s], n.vertexNormals[s + 1], n.vertexNormals[s + 2]], [i[e], i[e + 1], i[e + 2]]);
                        vec3.div(t, t, [i[e + 3], i[e + 3], i[e + 3]]);
                        vec3.normalize(t, t);
                        n.biTangents[s + 0] = t[0];
                        n.biTangents[s + 1] = t[1];
                        n.biTangents[s + 2] = t[2];
                        n.tangents[s + 0] = i[e + 0];
                        n.tangents[s + 1] = i[e + 1];
                        n.tangents[s + 2] = i[e + 2]
                    }
                }
                if (n.tangents.length === 0 || c.get() != "Never") {
                    console.log("[gltf ]no tangents... calculating tangents...");
                    n.calcTangentsBitangents()
                }
            }
            this.geom = n;
            this.bounds = n.getBounds()
        }
        render(n, t, i) {
            if (!this.mesh && this.geom && this.geom.verticesIndices) {
                let e = this.geom;
                if (this.geom.vertices.length / 3 > 64e3) {
                    e = this.geom.copy();
                    e.unIndex(false, true)
                }
                let t;
                if (this.primitive == this.TRIANGLES) t = n.gl.TRIANGLES;
                else if (this.primitive == this.LINES) t = n.gl.LINES;
                else if (this.primitive == this.LINE_STRIP) t = n.gl.LINE_STRIP;
                else if (this.primitive == this.POINTS) t = n.gl.POINTS;
                else {
                    y.logWarn("unknown primitive type", this)
                }
                this.mesh = new CGL.Mesh(n, e, t)
            } else {
                if (this.geom && this.geom.morphTargets.length && !this.morphTargetsRenderMod) {
                    this.mesh.addVertexNumbers = true;
                    this.morphTargetsRenderMod = new Z(this)
                }
                let e = !t && this.material != -1 && I.shaders[this.material];
                if (i) e = false;
                if (e) n.pushShader(I.shaders[this.material]);
                const s = n.getShader() || {};
                const r = s.uniformColorDiffuse;
                const a = s.uniformPbrMetalness;
                const o = s.uniformPbrRoughness;
                if (!I.shaders[this.material] && se.get()) {
                    if (r && this._matDiffuseColor) {
                        this._matDiffuseColorOrig = [r.getValue()[0], r.getValue()[1], r.getValue()[2], r.getValue()[3]];
                        r.setValue(this._matDiffuseColor)
                    }
                    if (a)
                        if (this._matPbrMetalness != null) {
                            this._matPbrMetalnessOrig = a.getValue();
                            a.setValue(this._matPbrMetalness)
                        } else a.setValue(0);
                    if (o)
                        if (this._matPbrRoughness != null) {
                            this._matPbrRoughnessOrig = o.getValue();
                            o.setValue(this._matPbrRoughness)
                        } else {
                            o.setValue(0)
                        }
                }
                if (this.morphTargetsRenderMod) this.morphTargetsRenderMod.renderStart(n, 0);
                if (this.mesh) {
                    this.mesh.render(n.getShader(), t)
                }
                if (this.morphTargetsRenderMod) this.morphTargetsRenderMod.renderFinish(n);
                if (se.get()) {
                    if (r && this._matDiffuseColor) r.setValue(this._matDiffuseColorOrig);
                    if (a && this._matPbrMetalnessOrig != undefined) a.setValue(this._matPbrMetalnessOrig);
                    if (o && this._matPbrRoughnessOrig != undefined) o.setValue(this._matPbrRoughnessOrig)
                }
                if (e) n.popShader()
            }
        }
    };
    const z = class {
        constructor(t, n) {
            this.bounds = new CABLES.CG.BoundingBox;
            this.meshes = [];
            this.name = n.name;
            const i = n.primitives;
            for (let e = 0; e < i.length; e++) {
                const s = new F(this.name, i[e], t, e => {
                    e.extras = n.extras;
                    this.bounds.apply(e.bounds)
                });
                s.submeshIndex = e;
                this.meshes.push(s)
            }
        }
        render(t, n, i, s, r) {
            for (let e = 0; e < this.meshes.length; e++) {
                const a = I.shaders[this.meshes[e].material];
                if (!n && a) t.pushShader(I.shaders[this.meshes[e].material]);
                if (i) i.renderStart(t, s);
                if (r) this.meshes[e].weights = r;
                this.meshes[e].render(t, n, i, s);
                if (i) i.renderFinish(t);
                if (!n && a) t.popShader()
            }
        }
    };
    const $ = class {
        constructor(e, t) {
            this.isChild = e.isChild || false;
            this.name = e.name;
            if (e.hasOwnProperty("camera")) this.camera = e.camera;
            this.hidden = false;
            this.mat = mat4.create();
            this._animActions = {};
            this.animWeights = [];
            this._animMat = mat4.create();
            this._tempMat = mat4.create();
            this._tempQuat = quat.create();
            this._tempRotmat = mat4.create();
            this.mesh = null;
            this.children = [];
            this._node = e;
            this._gltf = t;
            this.absMat = mat4.create();
            this.addTranslate = null;
            this._tempAnimScale = null;
            this.addMulMat = null;
            this.updateMatrix();
            this.skinRenderer = null;
            this.copies = []
        }
        get skin() {
            if (this._node.hasOwnProperty("skin")) return this._node.skin;
            else return -1
        }
        copy() {
            this.isCopy = true;
            const e = new $(this._node, this._gltf);
            e.copyOf = this;
            e._animActions = this._animActions;
            e.children = this.children;
            if (this.skin) e.skinRenderer = new Y(this);
            this.updateMatrix();
            return e
        }
        hasSkin() {
            if (this._node.hasOwnProperty("skin")) return this._gltf.json.skins[this._node.skin].name || "unknown";
            return false
        }
        initSkin() {
            if (this.skin > -1) {
                this.skinRenderer = new Y(this)
            }
        }
        updateMatrix() {
            mat4.identity(this.mat);
            if (this._node.translation) mat4.translate(this.mat, this.mat, this._node.translation);
            if (this._node.rotation) {
                const e = mat4.create();
                this._rot = this._node.rotation;
                mat4.fromQuat(e, this._node.rotation);
                mat4.mul(this.mat, this.mat, e)
            }
            if (this._node.scale) {
                this._scale = this._node.scale;
                mat4.scale(this.mat, this.mat, this._scale)
            }
            if (this._node.hasOwnProperty("mesh")) {
                this.mesh = this._gltf.meshes[this._node.mesh];
                if (this.isCopy) {}
            }
            if (this._node.children) {
                for (let e = 0; e < this._node.children.length; e++) {
                    this._gltf.json.nodes[e].isChild = true;
                    if (this._gltf.nodes[this._node.children[e]]) this._gltf.nodes[this._node.children[e]].isChild = true;
                    this.children.push(this._node.children[e])
                }
            }
        }
        unHide() {
            this.hidden = false;
            for (let e = 0; e < this.children.length; e++)
                if (this.children[e].unHide) this.children[e].unHide()
        }
        calcBounds(t, e, n) {
            const i = mat4.create();
            if (e) mat4.copy(i, e);
            if (this.mat) mat4.mul(i, i, this.mat);
            if (this.mesh) {
                const s = this.mesh.bounds.copy();
                s.mulMat4(i);
                n.apply(s);
                if (n.changed) {
                    _.push(s._min[0] || 0, s._min[1] || 0, s._min[2] || 0, s._max[0] || 0, s._max[1] || 0, s._max[2] || 0)
                }
            }
            for (let e = 0; e < this.children.length; e++) {
                if (t.nodes[this.children[e]] && t.nodes[this.children[e]].calcBounds) {
                    const r = t.nodes[this.children[e]].calcBounds(t, i, n);
                    n.apply(r)
                }
            }
            if (n.changed) return n;
            else return null
        }
        setAnimAction(t) {
            if (!t) return;
            this._currentAnimaction = t;
            if (t && !this._animActions[t]) {
                return null
            }
            for (let e in this._animActions[t]) {
                if (e == "translation") this._animTrans = this._animActions[t][e];
                else if (e == "rotation") this._animRot = this._animActions[t][e];
                else if (e == "scale") this._animScale = this._animActions[t][e];
                else if (e == "weights") this.animWeights = this._animActions[t][e];
                else console.log("[gltfNode] unknown anim path", e, this._animActions[t][e])
            }
        }
        setAnim(e, t, n) {
            if (!e || !t || !n) return;
            this._animActions[t] = this._animActions[t] || {};
            if (this._animActions[t][e]) y.log("[gltfNode] animation action path already exists", t, e, this._animActions[t][e]);
            this._animActions[t][e] = n;
            if (e == "translation") this._animTrans = n;
            else if (e == "rotation") this._animRot = n;
            else if (e == "scale") this._animScale = n;
            else if (e == "weights") {
                this.animWeights = this._animActions[t][e]
            } else console.warn("unknown anim path", e, n)
        }
        modelMatLocal() {
            return this._animMat || this.mat
        }
        modelMatAbs() {
            return this.absMat
        }
        transform(e, n) {
            if (!n && n != 0) n = E;
            this._lastTimeTrans = n;
            _e++;
            if (!this._animTrans && !this._animRot && !this._animScale) {
                mat4.mul(e.mMatrix, e.mMatrix, this.mat);
                this._animMat = null
            } else {
                this._animMat = this._animMat || mat4.create();
                mat4.identity(this._animMat);
                const t = true;
                if (t && this._animTrans) {
                    mat4.translate(this._animMat, this._animMat, [this._animTrans[0].getValue(n), this._animTrans[1].getValue(n), this._animTrans[2].getValue(n)])
                } else if (this._node.translation) mat4.translate(this._animMat, this._animMat, this._node.translation);
                if (t && this._animRot) {
                    if (this._animRot[0].defaultEasing == CABLES.EASING_LINEAR) CABLES.Anim.slerpQuaternion(n, this._tempQuat, this._animRot[0], this._animRot[1], this._animRot[2], this._animRot[3]);
                    else if (this._animRot[0].defaultEasing == CABLES.EASING_ABSOLUTE) {
                        this._tempQuat[0] = this._animRot[0].getValue(n);
                        this._tempQuat[1] = this._animRot[1].getValue(n);
                        this._tempQuat[2] = this._animRot[2].getValue(n);
                        this._tempQuat[3] = this._animRot[3].getValue(n)
                    } else if (this._animRot[0].defaultEasing == CABLES.EASING_CUBICSPLINE) {
                        CABLES.Anim.slerpQuaternion(n, this._tempQuat, this._animRot[0], this._animRot[1], this._animRot[2], this._animRot[3])
                    }
                    mat4.fromQuat(this._tempMat, this._tempQuat);
                    mat4.mul(this._animMat, this._animMat, this._tempMat)
                } else if (this._rot) {
                    mat4.fromQuat(this._tempRotmat, this._rot);
                    mat4.mul(this._animMat, this._animMat, this._tempRotmat)
                }
                if (t && this._animScale) {
                    if (!this._tempAnimScale) this._tempAnimScale = [1, 1, 1];
                    this._tempAnimScale[0] = this._animScale[0].getValue(n);
                    this._tempAnimScale[1] = this._animScale[1].getValue(n);
                    this._tempAnimScale[2] = this._animScale[2].getValue(n);
                    mat4.scale(this._animMat, this._animMat, this._tempAnimScale)
                } else if (this._scale) mat4.scale(this._animMat, this._animMat, this._scale);
                mat4.mul(e.mMatrix, e.mMatrix, this._animMat)
            }
            if (this.animWeights) {
                this.weights = this.weights || [];
                let t = "";
                for (let e = 0; e < this.animWeights.length; e++) {
                    this.weights[e] = this.animWeights[e].getValue(n);
                    t += this.weights[e] + "/"
                }
            }
            if (this.addTranslate) mat4.translate(e.mMatrix, e.mMatrix, this.addTranslate);
            if (this.addMulMat) mat4.mul(e.mMatrix, e.mMatrix, this.addMulMat);
            mat4.copy(this.absMat, e.mMatrix)
        }
        render(t, n, i, s, r, a, o) {
            if (!n) t.pushModelMatrix();
            if (o === undefined) o = I.time;
            if (!n || this.skinRenderer) this.transform(t, o);
            if (this.hidden && !a) {} else {
                if (this.skinRenderer) {
                    this.skinRenderer.time = o;
                    if (!i) this.mesh.render(t, s, this.skinRenderer, o, this.weights)
                } else {
                    if (this.mesh && !i) this.mesh.render(t, s, null, o, this.weights)
                }
            }
            if (!r && !this.hidden)
                for (let e = 0; e < this.children.length; e++)
                    if (I.nodes[this.children[e]]) I.nodes[this.children[e]].render(t, n, i, s, r, a, o);
            if (!n) t.popModelMatrix()
        }
    };
    let v = null;

    function x() {
        if (v) gui.mainTabs.closeTab(v.id);
        v = null
    }

    function o(t) {
        const n = [];
        for (let e = 0; e < t.length; e++) {
            n.push(Math.round(t[e] * 1e3) / 1e3)
        }
        return n.join(",")
    }

    function H(n, i, s) {
        if (!I) return;
        n += '<tr class="row">';
        let r = "";
        let a = "";
        for (let t = 1; t < s; t++) {
            a += "&nbsp;&nbsp;&nbsp;";
            let e = "identBg";
            if (t == 1) e = "identBgLevel0";
            r += '<td class="ident ' + e + '" ><div style=""></div></td>'
        }
        let e = CABLES.uuid();
        n += r;
        n += '<td colspan="' + (21 - s) + '">';
        if (i.mesh && i.mesh.meshes.length) n += '<span class="icon icon-cube"></span>&nbsp;';
        else n += '<span class="icon icon-box-select"></span> &nbsp;';
        n += i.name + "</td><td></td>";
        if (i.mesh) {
            n += "<td>";
            for (let e = 0; e < i.mesh.meshes.length; e++) {
                if (e > 0) n += ", ";
                n += i.mesh.meshes[e].name
            }
            n += "</td>";
            n += "<td>";
            n += i.hasSkin() || "-";
            n += "</td>";
            n += "<td>";
            let t = 0;
            for (let e = 0; e < i.mesh.meshes.length; e++) {
                if (t > 0) n += ", ";
                if (I.json.materials && i.mesh.meshes[e].hasOwnProperty("material")) {
                    if (I.json.materials[i.mesh.meshes[e].material]) {
                        n += I.json.materials[i.mesh.meshes[e].material].name;
                        t++
                    }
                }
            }
            if (t == 0) n += "none";
            n += "</td>"
        } else {
            n += "<td>-</td><td>-</td><td>-</td>"
        }
        n += "<td>";
        if (i._node.translation || i._node.rotation || i._node.scale) {
            let e = "";
            if (i._node.translation) e += "Translate: `" + o(i._node.translation) + "` || ";
            if (i._node.rotation) e += "Rotation: `" + o(i._node.rotation) + "` || ";
            if (i._node.scale) e += "Scale: `" + o(i._node.scale) + "` || ";
            n += '<span class="icon icon-gizmo info" data-info="' + e + '"></span> &nbsp;'
        }
        if (i._animRot || i._animScale || i._animTrans) {
            let e = "Animated: ";
            if (i._animRot) e += "Rot ";
            if (i._animScale) e += "Scale ";
            if (i._animTrans) e += "Trans ";
            n += '<span class="icon icon-clock info" data-info="' + e + '"></span>&nbsp;'
        }
        if (!i._node.translation && !i._node.rotation && !i._node.scale && !i._animRot && !i._animScale && !i._animTrans) n += "-";
        n += "</td>";
        n += "<td>";
        let t = "";
        if (i.hidden) t = "node-hidden";
        n += "<a onclick=\"gui.corePatch().getOpById('" + y.id + "').exposeNode('" + i.name + "','transform')\" class=\"treebutton\">Transform</a>";
        n += " <a onclick=\"gui.corePatch().getOpById('" + y.id + "').exposeNode('" + i.name + "','hierarchy')\" class=\"treebutton\">Hierarchy</a>";
        n += " <a onclick=\"gui.corePatch().getOpById('" + y.id + "').exposeNode('" + i.name + '\')" class="treebutton">Node</a>';
        if (i.hasSkin()) n += " <a onclick=\"gui.corePatch().getOpById('" + y.id + "').exposeNode('" + i.name + '\',false,{skin:true});" class="treebutton">Skin</a>';
        n += "</td><td>";
        n += '&nbsp;<span class="icon iconhover icon-eye ' + t + '" onclick="gui.corePatch().getOpById(\'' + y.id + "').toggleNodeVisibility('" + i.name + "');this.classList.toggle('node-hidden');\"></span>";
        n += "</td>";
        n += "</tr>";
        if (i.children) {
            for (let e = 0; e < i.children.length; e++) n = H(n, I.nodes[i.children[e]], s + 1)
        }
        return n
    }

    function W(t, e) {
        let n = "<tr>";
        n += " <td>" + e + "</td>";
        n += " <td>" + t.name + "</td>";
        n += " <td>";
        const i = JSON.stringify(t, null, 4).replaceAll('"', "").replaceAll("\n", "<br/>");
        n += "<span class=\"icon icon-info\" onclick=\"new CABLES.UI.ModalDialog({ 'html': '<pre>" + i + "</pre>', 'title': '" + t.name + "' });\"></span>&nbsp;";
        if (t.pbrMetallicRoughness && t.pbrMetallicRoughness.baseColorFactor) {
            let e = "";
            e += "" + Math.round(t.pbrMetallicRoughness.baseColorFactor[0] * 255);
            e += "," + Math.round(t.pbrMetallicRoughness.baseColorFactor[1] * 255);
            e += "," + Math.round(t.pbrMetallicRoughness.baseColorFactor[2] * 255);
            n += '<div style="width:15px;height:15px;background-color:rgb(' + e + ');display:inline-block">&nbsp;</a>'
        }
        n += ' <td style="">' + (I.shaders[e] ? "-" : "<a onclick=\"gui.corePatch().getOpById('" + y.id + "').assignMaterial('" + t.name + '\')" class="treebutton">Assign</a>') + "<td>";
        n += "<td>";
        n += "</tr>";
        return n
    }

    function e() {
        if (!I) return;
        const e = performance.now();
        const r = {};
        let a = '<div style="overflow:scroll;width:100%;height:100%">';
        a += 'File: <a href="' + CABLES.sandbox.getCablesUrl() + "/asset/patches/?filename=" + w.get() + '" target="_blank">' + CABLES.basename(w.get()) + "</a><br/>";
        a += "Generator:" + I.json.asset.generator;
        let t = 0;
        if (I.json.nodes) t = I.json.nodes.length;
        a += '<div id="groupNodes">Nodes (' + t + ")</div>";
        a += '<table id="sectionNodes" class="table treetable">';
        a += "<tr>";
        a += ' <th colspan="21">Name</th>';
        a += " <th>Mesh</th>";
        a += " <th>Skin</th>";
        a += " <th>Material</th>";
        a += " <th>Transform</th>";
        a += " <th>Expose</th>";
        a += " <th></th>";
        a += "</tr>";
        for (let e = 0; e < I.nodes.length; e++) {
            if (!I.nodes[e].isChild) a = H(a, I.nodes[e], 1)
        }
        a += "</table>";
        let n = 0;
        if (I.json.materials) n = I.json.materials.length;
        a += '<div id="groupMaterials">Materials (' + n + ")</div>";
        if (!I.json.materials || I.json.materials.length == 0) {} else {
            a += '<table id="materialtable"  class="table treetable">';
            a += "<tr>";
            a += " <th>Index</th>";
            a += " <th>Name</th>";
            a += " <th>Color</th>";
            a += " <th>Function</th>";
            a += " <th></th>";
            a += "</tr>";
            for (let e = 0; e < I.json.materials.length; e++) {
                a += W(I.json.materials[e], e)
            }
            a += "</table>"
        }
        a += '<div id="groupMeshes">Meshes (' + I.json.meshes.length + ")</div>";
        a += '<table id="meshestable"  class="table treetable">';
        a += "<tr>";
        a += " <th>Name</th>";
        a += " <th>Node</th>";
        a += " <th>Material</th>";
        a += " <th>Vertices</th>";
        a += " <th>Attributes</th>";
        a += "</tr>";
        let o = [];
        r.meshes = 0;
        r.meshTargets = 0;
        for (let s = 0; s < I.json.meshes.length; s++) {
            a += "<tr>";
            a += "<td>" + I.json.meshes[s].name + "</td>";
            a += "<td>";
            let t = 0;
            let n = "";
            for (let e = 0; e < I.json.nodes.length; e++) {
                if (I.json.nodes[e].mesh == s) {
                    t++;
                    if (t == 1) {
                        n = I.json.nodes[e].name
                    }
                }
            }
            if (t > 1) a += t + " nodes (" + n + " ...)";
            else a += n;
            a += "</td>";
            a += "<td>";
            for (let e = 0; e < I.json.meshes[s].primitives.length; e++) {
                if (I.json.meshes[s].primitives[e].hasOwnProperty("material")) {
                    if (I.json.materials[I.json.meshes[s]]) {
                        a += I.json.materials[I.json.meshes[s].primitives[e].material].name + " "
                    }
                } else a += "None"
            }
            a += "</td>";
            a += "<td>";
            let i = 0;
            for (let t = 0; t < I.json.meshes[s].primitives.length; t++) {
                if (I.json.meshes[s].primitives[t].attributes.POSITION != undefined) {
                    let e = parseInt(I.json.accessors[I.json.meshes[s].primitives[t].attributes.POSITION].count);
                    i += e;
                    a += "" + e + "<br/>"
                } else a += "-<br/>"
            }
            if (I.json.meshes[s].primitives.length > 1) a += "=" + i;
            a += "</td>";
            a += "<td>";
            for (let e = 0; e < I.json.meshes[s].primitives.length; e++) {
                a += Object.keys(I.json.meshes[s].primitives[e].attributes);
                a += " <a onclick=\"gui.corePatch().getOpById('" + y.id + "').exposeGeom('" + I.json.meshes[s].name + "'," + e + ')" class="treebutton">Geometry</a>';
                a += "<br/>";
                if (I.json.meshes[s].primitives[e].targets) {
                    a += I.json.meshes[s].primitives[e].targets.length + " targets<br/>";
                    if (I.json.meshes[s].extras && I.json.meshes[s].extras.targetNames) a += "Targetnames:<br/>" + I.json.meshes[s].extras.targetNames.join("<br/>");
                    a += "<br/>"
                }
            }
            a += "</td>";
            a += "</tr>";
            for (let n = 0; n < I.json.meshes[s].primitives.length; n++) {
                const g = I.json.accessors[I.json.meshes[s].primitives[n].indices];
                if (g) {
                    let e = g.bufferView;
                    if (o.indexOf(e) == -1) {
                        o.push(e);
                        if (I.json.bufferViews[e]) r.meshes += I.json.bufferViews[e].byteLength
                    }
                }
                for (let e in I.json.meshes[s].primitives[n].attributes) {
                    const m = I.json.meshes[s].primitives[n].attributes[e];
                    const f = I.json.accessors[m].bufferView;
                    if (o.indexOf(f) == -1) {
                        o.push(f);
                        if (I.json.bufferViews[f]) r.meshes += I.json.bufferViews[f].byteLength
                    }
                }
                if (I.json.meshes[s].primitives[n].targets)
                    for (let t = 0; t < I.json.meshes[s].primitives[n].targets.length; t++) {
                        for (let e in I.json.meshes[s].primitives[n].targets[t]) {
                            const p = I.json.meshes[s].primitives[n].targets[t][e];
                            const g = I.json.accessors[p];
                            const f = g.bufferView;
                            console.log("accessor", g);
                            if (o.indexOf(f) == -1)
                                if (I.json.bufferViews[f]) {
                                    o.push(f);
                                    r.meshTargets += I.json.bufferViews[f].byteLength
                                }
                        }
                    }
            }
        }
        a += "</table>";
        let i = 0;
        let s = 0;
        if (I.json.animations) {
            s = I.json.animations.length;
            for (let e = 0; e < I.json.animations.length; e++) i += I.json.animations[e].samplers.length
        }
        a += '<div id="groupAnims">Animations (' + s + "/" + i + ")</div>";
        if (I.json.animations) {
            a += '<table id="sectionAnim" class="table treetable">';
            a += "<tr>";
            a += "  <th>Name</th>";
            a += "  <th>Target node</th>";
            a += "  <th>Path</th>";
            a += "  <th>Interpolation</th>";
            a += "  <th>Keys</th>";
            a += "</tr>";
            r.animations = 0;
            for (let n = 0; n < I.json.animations.length; n++) {
                for (let t = 0; t < I.json.animations[n].samplers.length; t++) {
                    let e = I.json.accessors[I.json.animations[n].samplers[t].input].bufferView;
                    if (o.indexOf(e) == -1) {
                        o.push(e);
                        r.animations += I.json.bufferViews[e].byteLength
                    }
                    e = I.json.accessors[I.json.animations[n].samplers[t].output].bufferView;
                    if (o.indexOf(e) == -1) {
                        o.push(e);
                        r.animations += I.json.bufferViews[e].byteLength
                    }
                }
                for (let e = 0; e < I.json.animations[n].channels.length; e++) {
                    a += "<tr>";
                    a += "  <td> Anim " + n + ": " + I.json.animations[n].name + "</td>";
                    a += "  <td>" + I.nodes[I.json.animations[n].channels[e].target.node].name + "</td>";
                    a += "  <td>";
                    a += I.json.animations[n].channels[e].target.path + " ";
                    a += "  </td>";
                    const b = I.json.animations[n].channels[e].sampler;
                    const _ = I.json.animations[n].samplers[b];
                    a += "  <td>" + _.interpolation + "</td>";
                    a += "  <td>" + I.json.accessors[_.output].count;
                    a += "</td>";
                    a += "</tr>"
                }
            }
            a += "</table>"
        } else {}
        let l = 0;
        if (I.json.images) l = I.json.images.length;
        a += '<div id="groupImages">Images (' + l + ")</div>";
        if (I.json.images) {
            a += '<table id="sectionImages" class="table treetable">';
            a += "<tr>";
            a += "  <th>name</th>";
            a += "  <th>type</th>";
            a += "  <th>func</th>";
            a += "</tr>";
            r.images = 0;
            for (let t = 0; t < I.json.images.length; t++) {
                if (I.json.images[t].hasOwnProperty("bufferView")) {
                    r.images += I.json.bufferViews[I.json.images[t].bufferView].byteLength
                } else console.log("image has no bufferview?!");
                a += "<tr>";
                a += "<td>" + I.json.images[t].name + "</td>";
                a += "<td>" + I.json.images[t].mimeType + "</td>";
                a += "<td>";
                let e = I.json.images[t].name;
                if (e === undefined) e = I.json.images[t].bufferView;
                a += "<a onclick=\"gui.corePatch().getOpById('" + y.id + "').exposeTexture('" + e + '\')" class="treebutton">Expose</a>';
                a += "</td>";
                a += "<tr>"
            }
            a += "</table>"
        }
        let h = 0;
        if (I.json.cameras) h = I.json.cameras.length;
        a += '<div id="groupCameras">Cameras (' + h + ")</div>";
        if (I.json.cameras) {
            a += '<table id="sectionCameras" class="table treetable">';
            a += "<tr>";
            a += "  <th>name</th>";
            a += "  <th>type</th>";
            a += "  <th>info</th>";
            a += "</tr>";
            for (let e = 0; e < I.json.cameras.length; e++) {
                a += "<tr>";
                a += "<td>" + I.json.cameras[e].name + "</td>";
                a += "<td>" + I.json.cameras[e].type + "</td>";
                a += "<td>";
                if (I.json.cameras[e].perspective) {
                    a += "yfov: " + Math.round(I.json.cameras[e].perspective.yfov * 100) / 100;
                    a += ", ";
                    a += "zfar: " + Math.round(I.json.cameras[e].perspective.zfar * 100) / 100;
                    a += ", ";
                    a += "znear: " + Math.round(I.json.cameras[e].perspective.znear * 100) / 100
                }
                a += "</td>";
                a += "<tr>"
            }
            a += "</table>"
        }
        let c = 0;
        if (I.json.skins) c = I.json.skins.length;
        a += '<div id="groupSkins">Skins (' + c + ")</div>";
        if (I.json.skins) {
            a += '<table id="sectionSkins" class="table treetable">';
            a += "<tr>";
            a += "  <th>name</th>";
            a += "  <th></th>";
            a += "  <th>total joints</th>";
            a += "</tr>";
            for (let e = 0; e < I.json.skins.length; e++) {
                a += "<tr>";
                a += "<td>" + I.json.skins[e].name + "</td>";
                a += "<td>" + "</td>";
                a += "<td>" + I.json.skins[e].joints.length + "</td>";
                a += "<td>";
                a += "</td>";
                a += "<tr>"
            }
            a += "</table>"
        }
        if (I.timing) {
            a += '<div id="groupTiming">Debug Loading Timing </div>';
            a += '<table id="sectionTiming" class="table treetable">';
            a += "<tr>";
            a += "  <th>task</th>";
            a += "  <th>time used</th>";
            a += "</tr>";
            let e = 0;
            for (let e = 0; e < I.timing.length - 1; e++) {
                a += "<tr>";
                a += "  <td>" + I.timing[e][0] + "</td>";
                a += "  <td>" + (I.timing[e + 1][1] - I.timing[e][1]) + " ms</td>";
                a += "</tr>"
            }
            a += "</table>"
        }
        let u = 0;
        if (I.json.buffers) u = I.json.buffers[0].byteLength;
        a += '<div id="groupBinary">File Size Allocation (' + Math.round(u / 1024) + "k )</div>";
        a += '<table id="sectionBinary" class="table treetable">';
        a += "<tr>";
        a += "  <th>name</th>";
        a += "  <th>size</th>";
        a += "  <th>%</th>";
        a += "</tr>";
        let d = u;
        for (let e in r) {
            a += "<tr>";
            a += "<td>" + e + "</td>";
            a += "<td>" + X(r[e]) + " </td>";
            a += "<td>" + Math.round(r[e] / u * 100) + "% </td>";
            a += "<tr>";
            d -= r[e]
        }
        if (d != 0) {
            a += "<tr>";
            a += "<td>unknown</td>";
            a += "<td>" + X(d) + " </td>";
            a += "<td>" + Math.round(d / u * 100) + "% </td>";
            a += "<tr>"
        }
        a += "</table>";
        a += "</div>";
        v = new CABLES.UI.Tab("GLTF " + CABLES.basename(w.get()), {
            icon: "cube",
            infotext: "tab_gltf",
            padding: true,
            singleton: true
        });
        gui.mainTabs.addTab(v, true);
        v.addEventListener("onClose", x);
        v.html(a);
        CABLES.UI.Collapsable.setup(ele.byId("groupNodes"), ele.byId("sectionNodes"), false);
        CABLES.UI.Collapsable.setup(ele.byId("groupMaterials"), ele.byId("materialtable"), true);
        CABLES.UI.Collapsable.setup(ele.byId("groupAnims"), ele.byId("sectionAnim"), true);
        CABLES.UI.Collapsable.setup(ele.byId("groupMeshes"), ele.byId("meshestable"), true);
        CABLES.UI.Collapsable.setup(ele.byId("groupCameras"), ele.byId("sectionCameras"), true);
        CABLES.UI.Collapsable.setup(ele.byId("groupImages"), ele.byId("sectionImages"), true);
        CABLES.UI.Collapsable.setup(ele.byId("groupSkins"), ele.byId("sectionSkins"), true);
        CABLES.UI.Collapsable.setup(ele.byId("groupBinary"), ele.byId("sectionBinary"), true);
        CABLES.UI.Collapsable.setup(ele.byId("groupTiming"), ele.byId("sectionTiming"), true);
        gui.maintabPanel.show(true)
    }

    function X(e) {
        if (e > 1024) return Math.round(e / 1024) + " kb";
        if (e > 1024 * 500) return Math.round(e / 1024) + " mb";
        else return e + " bytes"
    }
    const Y = class {
        constructor(e) {
            this._mod = null;
            this._node = e;
            this._lastTime = 0;
            this._matArr = [];
            this._m = mat4.create();
            this._invBindMatrix = mat4.create();
            this.identity = true
        }
        renderFinish(e) {
            e.popModelMatrix();
            this._mod.unbind()
        }
        renderStart(e, t) {
            if (!this._mod) {
                this._mod = new CGL.ShaderModifier(e, y.name + this._node.name);
                this._mod.addModule({
                    priority: -2,
                    name: "MODULE_VERTEX_POSITION",
                    srcHeadVert: l.skin_head_vert || "",
                    srcBodyVert: l.skin_vert || ""
                });
                this._mod.addUniformVert("m4[]", "MOD_boneMats", []);
                const s = vec3.create()
            }
            const n = this._node.skin;
            const i = I.json.skins[n].joints.length * 16;
            {
                if (this._matArr.length != i) this._matArr.length = i;
                for (let e = 0; e < I.json.skins[n].joints.length; e++) {
                    const r = e * 16;
                    const a = I.json.skins[n].joints[e];
                    const o = I.nodes[a];
                    for (let e = 0; e < 16; e++) this._invBindMatrix[e] = I.accBuffers[I.json.skins[n].inverseBindMatrices][r + e];
                    mat4.mul(this._m, o.modelMatAbs(), this._invBindMatrix);
                    for (let e = 0; e < this._m.length; e++) this._matArr[r + e] = this._m[e]
                }
                this._mod.setUniformValue("MOD_boneMats", this._matArr);
                this._lastTime = t
            }
            this._mod.define("SKIN_NUM_BONES", I.json.skins[n].joints.length);
            this._mod.bind();
            e.pushModelMatrix();
            if (this.identity) mat4.identity(e.mMatrix)
        }
    };
    const Z = class {
        constructor(e) {
            this.mesh = e;
            this.tex = null;
            this.numRowsPerTarget = 0;
            this.makeTex(e.geom)
        }
        renderFinish(e) {
            e.popModelMatrix();
            this._mod.unbind()
        }
        renderStart(e, t) {
            if (!this._mod) {
                this._mod = new CGL.ShaderModifier(e, "gltftarget");
                this._mod.addModule({
                    priority: -2,
                    name: "MODULE_VERTEX_POSITION",
                    srcHeadVert: l.targets_head_vert || "",
                    srcBodyVert: l.targets_vert || ""
                });
                this._mod.addUniformVert("4f", "MOD_targetTexInfo", [0, 0, 0, 0]);
                this._mod.addUniformVert("t", "MOD_targetTex", 1);
                this._mod.addUniformVert("f[]", "MOD_weights", []);
                const n = vec3.create()
            }
            this._mod.pushTexture("MOD_targetTex", this.tex);
            this._mod.setUniformValue("MOD_weights", this.mesh.weights);
            this._mod.setUniformValue("MOD_targetTexInfo", [this.tex.width, this.tex.height, this.numRowsPerTarget, this.mesh.weights.length]);
            this._mod.define("MOD_NUM_WEIGHTS", Math.max(1, this.mesh.weights.length));
            this._mod.bind();
            e.pushModelMatrix();
            if (this.identity) mat4.identity(e.mMatrix)
        }
        makeTex(n) {
            if (!n.morphTargets || !n.morphTargets.length) return;
            let i = n.morphTargets[0].vertices.length / 3;
            let e = 0;
            this.numRowsPerTarget = 0;
            if (n.morphTargets[0].vertices && n.morphTargets[0].vertices.length) this.numRowsPerTarget++;
            if (n.morphTargets[0].vertexNormals && n.morphTargets[0].vertexNormals.length) this.numRowsPerTarget++;
            if (n.morphTargets[0].tangents && n.morphTargets[0].tangents.length) this.numRowsPerTarget++;
            if (n.morphTargets[0].bitangents && n.morphTargets[0].bitangents.length) this.numRowsPerTarget++;
            e = n.morphTargets.length * this.numRowsPerTarget;
            const s = new Float32Array(i * e * 4);
            let r = 0;
            for (let t = 0; t < n.morphTargets.length; t++) {
                if (n.morphTargets[t].vertices && n.morphTargets[t].vertices.length) {
                    for (let e = 0; e < n.morphTargets[t].vertices.length; e += 3) {
                        s[(r * i + e / 3) * 4 + 0] = n.morphTargets[t].vertices[e + 0];
                        s[(r * i + e / 3) * 4 + 1] = n.morphTargets[t].vertices[e + 1];
                        s[(r * i + e / 3) * 4 + 2] = n.morphTargets[t].vertices[e + 2];
                        s[(r * i + e / 3) * 4 + 3] = 1
                    }
                    r++
                }
                if (n.morphTargets[t].vertexNormals && n.morphTargets[t].vertexNormals.length) {
                    for (let e = 0; e < n.morphTargets[t].vertexNormals.length; e += 3) {
                        s[(r * i + e / 3) * 4 + 0] = n.morphTargets[t].vertexNormals[e + 0];
                        s[(r * i + e / 3) * 4 + 1] = n.morphTargets[t].vertexNormals[e + 1];
                        s[(r * i + e / 3) * 4 + 2] = n.morphTargets[t].vertexNormals[e + 2];
                        s[(r * i + e / 3) * 4 + 3] = 1
                    }
                    r++
                }
                if (n.morphTargets[t].tangents && n.morphTargets[t].tangents.length) {
                    for (let e = 0; e < n.morphTargets[t].tangents.length; e += 3) {
                        s[(r * i + e / 3) * 4 + 0] = n.morphTargets[t].tangents[e + 0];
                        s[(r * i + e / 3) * 4 + 1] = n.morphTargets[t].tangents[e + 1];
                        s[(r * i + e / 3) * 4 + 2] = n.morphTargets[t].tangents[e + 2];
                        s[(r * i + e / 3) * 4 + 3] = 1
                    }
                    r++
                }
                if (n.morphTargets[t].bitangents && n.morphTargets[t].bitangents.length) {
                    for (let e = 0; e < n.morphTargets[t].bitangents.length; e += 3) {
                        s[(r * i + e / 3) * 4 + 0] = n.morphTargets[t].bitangents[e + 0];
                        s[(r * i + e / 3) * 4 + 1] = n.morphTargets[t].bitangents[e + 1];
                        s[(r * i + e / 3) * 4 + 2] = n.morphTargets[t].bitangents[e + 2];
                        s[(r * i + e / 3) * 4 + 3] = 1
                    }
                    r++
                }
            }
            this.tex = new CGL.Texture(m, {
                isFloatingPointTexture: true,
                name: "targetsTexture"
            });
            this.tex.initFromData(s, i, e, CGL.Texture.FILTER_LINEAR, CGL.Texture.WRAP_REPEAT);
            console.log("morphTargets generated texture", i, e)
        }
    };
    const q = y.inTrigger("Render"),
        t = y.inString("data"),
        w = y.inUrl("glb File", [".glb"]),
        J = y.inBool("Draw", true),
        n = y.inDropDown("Camera", ["None"], "None"),
        Q = y.inString("Animation", ""),
        K = y.inTriggerButton("Show Structure"),
        i = y.inSwitch("Center", ["None", "XYZ", "XZ"], "XYZ"),
        s = y.inBool("Rescale", true),
        r = y.inFloat("Rescale Size", 2.5),
        a = y.inFloat("Time"),
        h = y.inBool("Sync to timeline", false),
        ee = y.inBool("Loop", true),
        te = y.inSwitch("Normals Format", ["XYZ", "X-ZY"], "XYZ"),
        ne = y.inSwitch("Vertices Format", ["XYZ", "XZ-Y"], "XYZ"),
        c = y.inSwitch("Calc Normals", ["Auto", "Force Smooth", "Never"]),
        u = y.inObject("Materials"),
        ie = y.inArray("Hide Nodes"),
        se = y.inBool("Use Material Properties", true),
        d = y.inBool("Active", true),
        re = y.outTrigger("Render Before"),
        g = y.outTrigger("Next"),
        ae = y.outString("Generator"),
        oe = y.outNumber("GLTF Version"),
        le = y.outArray("GLTF Extensions Used"),
        he = y.outNumber("Anim Length", 0),
        ce = y.outNumber("Anim Time", 0),
        ue = y.outObject("Json"),
        de = y.outArray("Anims"),
        ge = y.outArray("BoundingPoints"),
        me = y.outObject("Bounds"),
        fe = y.outTrigger("Finished"),
        pe = y.outBool("Loading");
    y.setPortGroup("Timing", [a, h, ee]);
    const m = y.patch.cgl;
    let f = null;
    let be = false;
    let _e = 0;
    let p = false;
    let b = null;
    let _ = [];
    let I = null;
    let T = 0;
    let E = 0;
    let O = true;
    let ve = null;
    let L = null;
    let M = null;
    const xe = vec3.create();
    let ye = 0;
    let Ce = false;
    const N = vec3.create();
    w.onChange = ne.onChange = c.onChange = te.onChange = k;
    K.onTriggered = e;
    t.onChange = Le;
    ie.onChange = B;
    Q.onChange = Ne;
    i.onChange = Ae;
    t.setUiAttribs({
        hideParam: true,
        hidePort: true
    });
    y.setPortGroup("Transform", [s, r, i]);

    function Se() {
        const t = ["None"];
        if (I) {
            for (let e = 0; e < I.nodes.length; e++) {
                if (I.nodes[e].camera >= 0) {
                    t.push(I.nodes[e].name)
                }
            }
        }
        n.uiAttribs.values = t
    }

    function Ae() {
        Ce = i.get() != "None";
        if (I && I.bounds) {
            N.set(I.bounds.center);
            N[0] = -N[0];
            N[1] = -N[1];
            N[2] = -N[2];
            if (i.get() == "XZ") N[1] = -I.bounds.minY
        }
    }
    s.onChange = function() {
        r.setUiAttribs({
            greyout: !s.get()
        })
    };
    u.onChange = function() {
        O = true
    };
    y.onDelete = function() {
        x()
    };
    h.onChange = function() {
        a.setUiAttribs({
            greyout: h.get()
        })
    };
    n.onChange = we;

    function we() {
        b = null;
        if (!I) return;
        for (let e = 0; e < I.nodes.length; e++) {
            if (I.nodes[e].name == n.get()) b = new j(I, I.nodes[e])
        }
    }
    q.onTriggered = function() {
        if (!p) return;
        if (!d.get()) return;
        if (be) {
            if (!f) f = CGL.MESHES.getSimpleCube(m, "ErrorCube");
            f.render(m.getShader())
        }
        _e = 0;
        if (h.get()) E = y.patch.timer.getTime();
        else E = Math.max(0, a.get());
        if (ee.get()) {
            E %= T;
            if (E < ye) fe.trigger()
        } else {
            if (T > 0 && E >= T) fe.trigger()
        }
        ye = E;
        m.pushModelMatrix();
        ce.set(E || 0);
        if (p && I && I.bounds) {
            if (s.get()) {
                let e = r.get() / I.bounds.maxAxis;
                I.scale = e;
                vec3.set(xe, e, e, e);
                mat4.scale(m.mMatrix, m.mMatrix, xe)
            }
            if (Ce) {
                mat4.translate(m.mMatrix, m.mMatrix, N)
            }
        }
        let e = m.frameStore.currentScene || null;
        m.frameStore.currentScene = I;
        re.trigger();
        if (p) {
            if (O) Ee();
            if (b) b.start(E);
            if (I) {
                I.time = E;
                if (I.bounds && m.shouldDrawHelpers(y)) {
                    if (CABLES.UI.renderHelper) m.pushShader(CABLES.GL_MARKER.getDefaultShader(m));
                    else m.pushShader(CABLES.GL_MARKER.getSelectedShader(m));
                    I.bounds.render(m);
                    m.popShader()
                }
                if (J.get()) {
                    for (let e = 0; e < I.nodes.length; e++)
                        if (!I.nodes[e].isChild) I.nodes[e].render(m)
                } else {
                    for (let e = 0; e < I.nodes.length; e++)
                        if (!I.nodes[e].isChild) I.nodes[e].render(m, false, true)
                }
            }
        }
        g.trigger();
        m.frameStore.currentScene = e;
        m.popModelMatrix();
        if (b) b.end()
    };

    function Ie() {
        if (!I) {
            p = true;
            be = true;
            m.patch.loading.finished(L);
            y.setUiError("nogltf", "GLTF File not found");
            return
        }
        y.setUiError("nogltf", null);
        if (I.loadingMeshes > 0) {
            setTimeout(Ie, 100);
            return
        }
        I.timing.push(["finishLoading()", Math.round(performance.now() - I.startTime)]);
        O = true;
        he.set(T);
        I.bounds = new CABLES.CG.BoundingBox;
        I.timing.push(["start calc bounds", Math.round(performance.now() - I.startTime)]);
        for (let e = 0; e < I.nodes.length; e++) {
            const t = I.nodes[e];
            t.updateMatrix();
            if (!t.isChild) t.calcBounds(I, null, I.bounds)
        }
        if (I.bounds) me.set(I.bounds);
        I.timing.push(["calced bounds", Math.round(performance.now() - I.startTime)]);
        B();
        I.timing.push(["hideNodesFromData", Math.round(performance.now() - I.startTime)]);
        if (v) e();
        I.timing.push(["printinfo", Math.round(performance.now() - I.startTime)]);
        Se();
        we();
        ge.set(_);
        if (I) {
            if (w.get() && !w.get().startsWith("data:")) {
                y.setUiAttrib({
                    extendTitle: CABLES.basename(w.get())
                })
            }
            I.loaded = Date.now()
        }
        if (I) {
            for (let e = 0; e < I.nodes.length; e++) {
                if (!I.nodes[e].isChild) {
                    I.nodes[e].render(m, false, true, true, false, true, 0)
                }
            }
            for (let e = 0; e < I.nodes.length; e++) {
                const t = I.nodes[e];
                t.children = Be(t.children)
            }
        }
        Ae();
        Ne();
        pe.set(false);
        m.patch.loading.finished(L);
        L = null;
        y.setUiAttrib({
            accBuffersDelete: CABLES.basename(w.get())
        });
        if (I.accBuffersDelete) {
            for (let e = 0; e < I.accBuffersDelete.length; e++) {
                I.accBuffers[I.accBuffersDelete[e]] = null
            }
        }
        p = true
    }

    function Te(e) {
        if (!d.get()) return;
        if (!L) L = m.patch.loading.start("gltfScene", w.get(), y);
        let t = w.get();
        let n = y.patch.getFilePath(String(w.get()));
        if (w.get() && !w.get().startsWith("data:")) {
            if (e === true) n += "?rnd=" + CABLES.generateUUID()
        }
        O = true;
        pe.set(true);
        fetch(n).then(e => {
            return e.arrayBuffer()
        }).then(e => {
            if (w.get() != t) {
                m.patch.loading.finished(L);
                L = null;
                return
            }
            _ = [];
            T = 0;
            I = G(e);
            Ie()
        });
        x();
        const i = new XMLHttpRequest;
        i.open("GET", n, true);
        i.responseType = "arraybuffer";
        m.patch.loading.addAssetLoadingTask(() => {})
    }
    y.onFileChanged = function(e) {
        if (w.get() && w.get().indexOf(e) > -1) {
            k(true)
        }
    };
    d.onChange = () => {
        if (d.get()) k();
        if (!d.get()) {
            I = null
        }
    };

    function k(e) {
        clearTimeout(ve);
        ve = setTimeout(function() {
            Te(e)
        }, 30)
    }

    function Ee() {
        if (!I) return;
        I.shaders = {};
        if (u.links.length == 1 && u.get()) {
            O = true;
            const n = u.links[0].portOut.op;
            const i = n.getPort("Shader");
            const s = n.getPort("Material Name");
            if (!i && !s) {
                const r = u.get();
                for (let t in r) {
                    if (r[t] && I.json.materials)
                        for (let e = 0; e < I.json.materials.length; e++) {
                            if (I.json.materials[e].name == t) {
                                if (I.shaders[e]) {
                                    n.warn("double material assignment:", name)
                                }
                                I.shaders[e] = r[t]
                            }
                        }
                }
            }
        }
        if (u.get()) {
            for (let e = 0; e < u.links.length; e++) {
                const t = u.links[e].portOut.op;
                const i = t.getPort("Shader");
                const s = t.getPort("Material Name");
                if (i && s && i.get()) {
                    const name = s.get();
                    if (I.json.materials)
                        for (let e = 0; e < I.json.materials.length; e++)
                            if (I.json.materials[e].name == name) {
                                if (I.shaders[e]) {
                                    t.warn("double material assignment:", name)
                                }
                                I.shaders[e] = i.get()
                            }
                }
            }
        }
        O = false;
        if (v) e()
    }

    function Oe() {
        const t = ie.get();
        if (!I || !M || !M.hiddenNodes) return;
        if (!t) {
            return
        }
        for (let e = 0; e < t.length; e++) {
            const n = I.getNode(t[e]);
            if (n) n.hidden = true
        }
    }

    function B() {
        if (!M) Le();
        if (!I) return;
        I.unHideAll();
        if (M && M.hiddenNodes) {
            for (const e in M.hiddenNodes) {
                const t = I.getNode(e);
                if (t) t.hidden = true;
                else y.verbose("node to be hidden not found", e, t)
            }
        }
        Oe()
    }

    function Le() {
        M = t.get();
        if (!M || M === "") M = {};
        else M = JSON.parse(M);
        if (I) B();
        return M
    }

    function Me() {
        t.set(JSON.stringify(M))
    }

    function Ne() {
        if (I && I.nodes) {
            for (let e = 0; e < I.nodes.length; e++) {
                I.nodes[e].setAnimAction(Q.get())
            }
        }
    }

    function ke(t, n) {
        for (let e = 0; e < I.nodes.length; e++) {
            if (I.nodes[e].children.indexOf(n) >= 0) {
                t.push(I.nodes[e]);
                if (I.nodes[e].isChild) ke(t, e)
            }
        }
    }
    y.exposeTexture = function(e) {
        const t = gui.corePatch().addOp("Ops.Gl.GLTF.GltfTexture");
        t.getPort("Name").set(e);
        R(t, 1);
        y.patch.link(y, g.name, t, "Render");
        gui.patchView.testCollision(t);
        gui.patchView.centerSelectOp(t.id, true)
    };
    y.exposeGeom = function(e, t) {
        const n = gui.corePatch().addOp("Ops.Gl.GLTF.GltfGeometry");
        n.getPort("Name").set(e);
        n.getPort("Submesh").set(t);
        R(n, 1);
        y.patch.link(y, g.name, n, "Update");
        gui.patchView.testCollision(n);
        gui.patchView.centerSelectOp(n.id, true)
    };

    function R(e, t) {
        t = t || 1;
        e.setUiAttrib({
            subPatch: y.uiAttribs.subPatch,
            translate: {
                x: y.uiAttribs.translate.x,
                y: y.uiAttribs.translate.y + t * CABLES.GLUI.glUiConfig.newOpDistanceY
            }
        })
    }
    y.exposeNode = function(n, e, i) {
        let t = e == "hierarchy";
        if (t) {
            let s = [];
            for (let e = 0; e < I.nodes.length; e++) {
                if (I.nodes[e].name == n) {
                    let t = [];
                    const r = I.nodes[e];
                    ke(t, e);
                    t = t.reverse();
                    t.push(r, r);
                    let n = g.name;
                    let i = y;
                    for (let e = 0; e < t.length; e++) {
                        const a = gui.corePatch().addOp("Ops.Gl.GLTF.GltfNode_v2");
                        a.getPort("Node Name").set(t[e].name);
                        y.patch.link(i, n, a, "Render");
                        R(a, e);
                        if (e == t.length - 1) {
                            a.getPort("Transformation").set(false)
                        } else {
                            a.getPort("Draw Mesh").set(false);
                            a.getPort("Draw Childs").set(false)
                        }
                        n = "Next";
                        i = a;
                        s.push(a);
                        gui.patchView.testCollision(a)
                    }
                }
            }
            for (let e = 0; e < s.length; e++) {
                s[e].selectChilds()
            }
        } else {
            let t = "Ops.Gl.GLTF.GltfNode_v2";
            if (i && i.skin) t = "Ops.Gl.GLTF.GltfSkin";
            if (e == "transform") t = "Ops.Gl.GLTF.GltfNodeTransform_v2";
            gui.serverOps.loadOpLibs(t, () => {
                let e = gui.corePatch().addOp(t);
                e.getPort("Node Name").set(n);
                R(e);
                y.patch.link(y, g.name, e, "Render");
                gui.patchView.testCollision(e);
                gui.patchView.centerSelectOp(e.id, true)
            })
        }
        gui.closeModal()
    };
    y.assignMaterial = function(e) {
        const t = gui.corePatch().addOp("Ops.Gl.GLTF.GltfSetMaterial");
        t.getPort("Material Name").set(e);
        y.patch.link(y, u.name, t, "Material");
        R(t);
        gui.patchView.testCollision(t);
        gui.patchView.centerSelectOp(t.id, true);
        gui.closeModal()
    };
    y.toggleNodeVisibility = function(e) {
        const t = I.getNode(e);
        t.hidden = !t.hidden;
        M.hiddenNodes = M.hiddenNodes || {};
        if (t)
            if (t.hidden) M.hiddenNodes[e] = true;
            else delete M.hiddenNodes[e];
        Me()
    };

    function Be(n) {
        const i = {},
            s = [];
        for (let e = 0, t = n.length; e < t; ++e) {
            if (!i.hasOwnProperty(n[e])) {
                s.push(n[e]);
                i[n[e]] = 1
            }
        }
        return s
    }
};
Ops.Gl.GLTF.GltfScene_v4.prototype = new CABLES.Op;
CABLES.OPS["c9cbb226-46f7-4ca6-8dab-a9d0bdca4331"] = {
    f: Ops.Gl.GLTF.GltfScene_v4,
    objName: "Ops.Gl.GLTF.GltfScene_v4"
};
Ops.Sidebar.Sidebar = function() {
    CABLES.Op.apply(this, arguments);
    const a = this;
    const n = {
        style_css: " /*\n * SIDEBAR\n  http://danielstern.ca/range.css/#/\n  https://developer.mozilla.org/en-US/docs/Web/CSS/::-webkit-progress-value\n */\n\n.sidebar-icon-undo\n{\n    width:10px;\n    height:10px;\n    background-image: url(\"data:image/svg+xml;charset=utf8, %3Csvg xmlns='http://www.w3.org/2000/svg' width='24' height='24' fill='none' stroke='grey' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Cpath d='M3 7v6h6'/%3E%3Cpath d='M21 17a9 9 0 00-9-9 9 9 0 00-6 2.3L3 13'/%3E%3C/svg%3E\");\n    background-size: 19px;\n    background-repeat: no-repeat;\n    top: -19px;\n    margin-top: -7px;\n}\n\n.icon-chevron-down {\n    top: 2px;\n    right: 9px;\n}\n\n.iconsidebar-chevron-up,.sidebar__close-button {\n\tbackground-image: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyNCIgaGVpZ2h0PSIyNCIgdmlld0JveD0iMCAwIDI0IDI0IiBmaWxsPSJub25lIiBzdHJva2U9IiM4ODg4ODgiIHN0cm9rZS13aWR0aD0iMiIgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIiBzdHJva2UtbGluZWpvaW49InJvdW5kIiBjbGFzcz0iZmVhdGhlciBmZWF0aGVyLWNoZXZyb24tdXAiPjxwb2x5bGluZSBwb2ludHM9IjE4IDE1IDEyIDkgNiAxNSI+PC9wb2x5bGluZT48L3N2Zz4=);\n}\n\n.iconsidebar-minimizebutton {\n    background-position: 98% center;\n    background-repeat: no-repeat;\n}\n\n.sidebar-cables-right\n{\n    right: 15px;\n    left: initial !important;\n}\n\n.sidebar-cables {\n    --sidebar-color: #07f78c;\n    --sidebar-width: 220px;\n    --sidebar-border-radius: 10px;\n    --sidebar-monospace-font-stack: \"SFMono-Regular\", Consolas, \"Liberation Mono\", Menlo, Courier, monospace;\n    --sidebar-hover-transition-time: .2s;\n\n    position: absolute;\n    top: 15px;\n    left: 15px;\n    border-radius: var(--sidebar-border-radius);\n    z-index: 100000;\n    color: #BBBBBB;\n    width: var(  --sidebar-width);\n    max-height: 100%;\n    box-sizing: border-box;\n    overflow-y: auto;\n    overflow-x: hidden;\n    font-size: 13px;\n    font-family: Arial;\n    line-height: 1em; /* prevent emojis from breaking height of the title */\n}\n\n.sidebar-cables::selection {\n    background-color: var(--sidebar-color);\n    color: #EEEEEE;\n}\n\n.sidebar-cables::-webkit-scrollbar {\n    background-color: transparent;\n    --cables-scrollbar-width: 8px;\n    width: var(--cables-scrollbar-width);\n}\n\n.sidebar-cables::-webkit-scrollbar-track {\n    background-color: transparent;\n    width: var(--cables-scrollbar-width);\n}\n\n.sidebar-cables::-webkit-scrollbar-thumb {\n    background-color: #333333;\n    border-radius: 4px;\n    width: var(--cables-scrollbar-width);\n}\n\n.sidebar-cables--closed {\n    width: auto;\n}\n\n.sidebar__close-button {\n    background-color: #222;\n    /*-webkit-user-select: none;  */\n    /*-moz-user-select: none;     */\n    /*-ms-user-select: none;      */\n    /*user-select: none;          */\n    /*transition: background-color var(--sidebar-hover-transition-time);*/\n    /*color: #CCCCCC;*/\n    height: 2px;\n    /*border-bottom:20px solid #222;*/\n\n    /*box-sizing: border-box;*/\n    /*padding-top: 2px;*/\n    /*text-align: center;*/\n    /*cursor: pointer;*/\n    /*border-radius: 0 0 var(--sidebar-border-radius) var(--sidebar-border-radius);*/\n    /*opacity: 1.0;*/\n    /*transition: opacity 0.3s;*/\n    /*overflow: hidden;*/\n}\n\n.sidebar__close-button-icon {\n    display: inline-block;\n    /*opacity: 0;*/\n    width: 20px;\n    height: 20px;\n    /*position: relative;*/\n    /*top: -1px;*/\n\n\n}\n\n.sidebar--closed {\n    width: auto;\n    margin-right: 20px;\n}\n\n.sidebar--closed .sidebar__close-button {\n    margin-top: 8px;\n    margin-left: 8px;\n    padding:10px;\n\n    height: 25px;\n    width:25px;\n    border-radius: 50%;\n    cursor: pointer;\n    opacity: 0.3;\n    background-repeat: no-repeat;\n    background-position: center center;\n    transform:rotate(180deg);\n}\n\n.sidebar--closed .sidebar__group\n{\n    display:none;\n\n}\n.sidebar--closed .sidebar__close-button-icon {\n    background-position: 0px 0px;\n}\n\n.sidebar__close-button:hover {\n    background-color: #111111;\n    opacity: 1.0 !important;\n}\n\n/*\n * SIDEBAR ITEMS\n */\n\n.sidebar__items {\n    /* max-height: 1000px; */\n    /* transition: max-height 0.5;*/\n    background-color: #222;\n    padding-bottom: 20px;\n}\n\n.sidebar--closed .sidebar__items {\n    /* max-height: 0; */\n    height: 0;\n    display: none;\n    pointer-interactions: none;\n}\n\n.sidebar__item__right {\n    float: right;\n}\n\n/*\n * SIDEBAR GROUP\n */\n\n.sidebar__group {\n    /*background-color: #1A1A1A;*/\n    overflow: hidden;\n    box-sizing: border-box;\n    animate: height;\n    /*background-color: #151515;*/\n    /* max-height: 1000px; */\n    /* transition: max-height 0.5s; */\n--sidebar-group-header-height: 33px;\n}\n\n.sidebar__group-items\n{\n    padding-top: 15px;\n    padding-bottom: 15px;\n}\n\n.sidebar__group--closed {\n    /* max-height: 13px; */\n    height: var(--sidebar-group-header-height);\n}\n\n.sidebar__group-header {\n    box-sizing: border-box;\n    color: #EEEEEE;\n    background-color: #151515;\n    -webkit-user-select: none;  /* Chrome all / Safari all */\n    -moz-user-select: none;     /* Firefox all */\n    -ms-user-select: none;      /* IE 10+ */\n    user-select: none;          /* Likely future */\n\n    /*height: 100%;//var(--sidebar-group-header-height);*/\n\n    padding-top: 7px;\n    text-transform: uppercase;\n    letter-spacing: 0.08em;\n    cursor: pointer;\n    /*transition: background-color var(--sidebar-hover-transition-time);*/\n    position: relative;\n}\n\n.sidebar__group-header:hover {\n  background-color: #111111;\n}\n\n.sidebar__group-header-title {\n  /*float: left;*/\n  overflow: hidden;\n  padding: 0 15px;\n  padding-top:5px;\n  padding-bottom:10px;\n  font-weight:bold;\n}\n\n.sidebar__group-header-undo {\n    float: right;\n    overflow: hidden;\n    padding-right: 15px;\n    padding-top:5px;\n    font-weight:bold;\n  }\n\n.sidebar__group-header-icon {\n    width: 17px;\n    height: 14px;\n    background-repeat: no-repeat;\n    display: inline-block;\n    position: absolute;\n    background-size: cover;\n\n    /* icon open */\n    /* feather icon: chevron up */\n    background-image: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyNCIgaGVpZ2h0PSIyNCIgdmlld0JveD0iMCAwIDI0IDI0IiBmaWxsPSJub25lIiBzdHJva2U9IiM4ODg4ODgiIHN0cm9rZS13aWR0aD0iMiIgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIiBzdHJva2UtbGluZWpvaW49InJvdW5kIiBjbGFzcz0iZmVhdGhlciBmZWF0aGVyLWNoZXZyb24tdXAiPjxwb2x5bGluZSBwb2ludHM9IjE4IDE1IDEyIDkgNiAxNSI+PC9wb2x5bGluZT48L3N2Zz4=);\n    top: 4px;\n    right: 5px;\n    opacity: 0.0;\n    transition: opacity 0.3;\n}\n\n.sidebar__group-header:hover .sidebar__group-header-icon {\n    opacity: 1.0;\n}\n\n/* icon closed */\n.sidebar__group--closed .sidebar__group-header-icon {\n    /* feather icon: chevron down */\n    background-image: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyNCIgaGVpZ2h0PSIyNCIgdmlld0JveD0iMCAwIDI0IDI0IiBmaWxsPSJub25lIiBzdHJva2U9IiM4ODg4ODgiIHN0cm9rZS13aWR0aD0iMiIgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIiBzdHJva2UtbGluZWpvaW49InJvdW5kIiBjbGFzcz0iZmVhdGhlciBmZWF0aGVyLWNoZXZyb24tZG93biI+PHBvbHlsaW5lIHBvaW50cz0iNiA5IDEyIDE1IDE4IDkiPjwvcG9seWxpbmU+PC9zdmc+);\n    top: 4px;\n    right: 5px;\n}\n\n/*\n * SIDEBAR ITEM\n */\n\n.sidebar__item\n{\n    box-sizing: border-box;\n    padding: 7px;\n    padding-left:15px;\n    padding-right:15px;\n\n    overflow: hidden;\n    position: relative;\n}\n\n.sidebar__item-label {\n    display: inline-block;\n    -webkit-user-select: none;  /* Chrome all / Safari all */\n    -moz-user-select: none;     /* Firefox all */\n    -ms-user-select: none;      /* IE 10+ */\n    user-select: none;          /* Likely future */\n    width: calc(50% - 7px);\n    margin-right: 7px;\n    margin-top: 2px;\n    text-overflow: ellipsis;\n    /* overflow: hidden; */\n}\n\n.sidebar__item-value-label {\n    font-family: var(--sidebar-monospace-font-stack);\n    display: inline-block;\n    text-overflow: ellipsis;\n    overflow: hidden;\n    white-space: nowrap;\n    max-width: 60%;\n}\n\n.sidebar__item-value-label::selection {\n    background-color: var(--sidebar-color);\n    color: #EEEEEE;\n}\n\n.sidebar__item + .sidebar__item,\n.sidebar__item + .sidebar__group,\n.sidebar__group + .sidebar__item,\n.sidebar__group + .sidebar__group {\n    /*border-top: 1px solid #272727;*/\n}\n\n/*\n * SIDEBAR ITEM TOGGLE\n */\n\n/*.sidebar__toggle */\n.icon_toggle{\n    cursor: pointer;\n}\n\n.sidebar__toggle-input {\n    --sidebar-toggle-input-color: #CCCCCC;\n    --sidebar-toggle-input-color-hover: #EEEEEE;\n    --sidebar-toggle-input-border-size: 2px;\n    display: inline;\n    float: right;\n    box-sizing: border-box;\n    border-radius: 50%;\n    cursor: pointer;\n    --toggle-size: 11px;\n    margin-top: 2px;\n    background-color: transparent !important;\n    border: var(--sidebar-toggle-input-border-size) solid var(--sidebar-toggle-input-color);\n    width: var(--toggle-size);\n    height: var(--toggle-size);\n    transition: background-color var(--sidebar-hover-transition-time);\n    transition: border-color var(--sidebar-hover-transition-time);\n}\n.sidebar__toggle:hover .sidebar__toggle-input {\n    border-color: var(--sidebar-toggle-input-color-hover);\n}\n\n.sidebar__toggle .sidebar__item-value-label {\n    -webkit-user-select: none;  /* Chrome all / Safari all */\n    -moz-user-select: none;     /* Firefox all */\n    -ms-user-select: none;      /* IE 10+ */\n    user-select: none;          /* Likely future */\n    max-width: calc(50% - 12px);\n}\n.sidebar__toggle-input::after { clear: both; }\n\n.sidebar__toggle--active .icon_toggle\n{\n\n    background-image: url(data:image/svg+xml;base64,PHN2ZyBoZWlnaHQ9IjE1cHgiIHdpZHRoPSIzMHB4IiBmaWxsPSIjMDZmNzhiIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiB2ZXJzaW9uPSIxLjEiIHg9IjBweCIgeT0iMHB4IiB2aWV3Qm94PSIwIDAgMTAwIDEwMCIgZW5hYmxlLWJhY2tncm91bmQ9Im5ldyAwIDAgMTAwIDEwMCIgeG1sOnNwYWNlPSJwcmVzZXJ2ZSI+PGcgZGlzcGxheT0ibm9uZSI+PGcgZGlzcGxheT0iaW5saW5lIj48Zz48cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZmlsbD0iIzA2Zjc4YiIgZD0iTTMwLDI3QzE3LjM1LDI3LDcsMzcuMzUsNyw1MGwwLDBjMCwxMi42NSwxMC4zNSwyMywyMywyM2g0MCBjMTIuNjUsMCwyMy0xMC4zNSwyMy0yM2wwLDBjMC0xMi42NS0xMC4zNS0yMy0yMy0yM0gzMHogTTcwLDY3Yy05LjM4OSwwLTE3LTcuNjEtMTctMTdzNy42MTEtMTcsMTctMTdzMTcsNy42MSwxNywxNyAgICAgUzc5LjM4OSw2Nyw3MCw2N3oiPjwvcGF0aD48L2c+PC9nPjwvZz48Zz48cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTMwLDI3QzE3LjM1LDI3LDcsMzcuMzUsNyw1MGwwLDBjMCwxMi42NSwxMC4zNSwyMywyMywyM2g0MCAgIGMxMi42NSwwLDIzLTEwLjM1LDIzLTIzbDAsMGMwLTEyLjY1LTEwLjM1LTIzLTIzLTIzSDMweiBNNzAsNjdjLTkuMzg5LDAtMTctNy42MS0xNy0xN3M3LjYxMS0xNywxNy0xN3MxNyw3LjYxLDE3LDE3ICAgUzc5LjM4OSw2Nyw3MCw2N3oiPjwvcGF0aD48L2c+PGcgZGlzcGxheT0ibm9uZSI+PGcgZGlzcGxheT0iaW5saW5lIj48cGF0aCBmaWxsPSIjMDZmNzhiIiBzdHJva2U9IiMwNmY3OGIiIHN0cm9rZS13aWR0aD0iNCIgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIiBkPSJNNyw1MGMwLDEyLjY1LDEwLjM1LDIzLDIzLDIzaDQwICAgIGMxMi42NSwwLDIzLTEwLjM1LDIzLTIzbDAsMGMwLTEyLjY1LTEwLjM1LTIzLTIzLTIzSDMwQzE3LjM1LDI3LDcsMzcuMzUsNyw1MEw3LDUweiI+PC9wYXRoPjwvZz48Y2lyY2xlIGRpc3BsYXk9ImlubGluZSIgZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGZpbGw9IiMwNmY3OGIiIHN0cm9rZT0iIzA2Zjc4YiIgc3Ryb2tlLXdpZHRoPSI0IiBzdHJva2UtbWl0ZXJsaW1pdD0iMTAiIGN4PSI3MCIgY3k9IjUwIiByPSIxNyI+PC9jaXJjbGU+PC9nPjxnIGRpc3BsYXk9Im5vbmUiPjxwYXRoIGRpc3BsYXk9ImlubGluZSIgZD0iTTcwLDI1SDMwQzE2LjIxNSwyNSw1LDM2LjIxNSw1LDUwczExLjIxNSwyNSwyNSwyNWg0MGMxMy43ODUsMCwyNS0xMS4yMTUsMjUtMjVTODMuNzg1LDI1LDcwLDI1eiBNNzAsNzEgICBIMzBDMTguNDIxLDcxLDksNjEuNTc5LDksNTBzOS40MjEtMjEsMjEtMjFoNDBjMTEuNTc5LDAsMjEsOS40MjEsMjEsMjFTODEuNTc5LDcxLDcwLDcxeiBNNzAsMzFjLTEwLjQ3NywwLTE5LDguNTIzLTE5LDE5ICAgczguNTIzLDE5LDE5LDE5czE5LTguNTIzLDE5LTE5UzgwLjQ3NywzMSw3MCwzMXogTTcwLDY1Yy04LjI3MSwwLTE1LTYuNzI5LTE1LTE1czYuNzI5LTE1LDE1LTE1czE1LDYuNzI5LDE1LDE1Uzc4LjI3MSw2NSw3MCw2NXoiPjwvcGF0aD48L2c+PC9zdmc+);\n    opacity: 1;\n    transform: rotate(0deg);\n}\n\n\n.icon_toggle\n{\n    float: right;\n    width:40px;\n    height:18px;\n    background-image: url(data:image/svg+xml;base64,PHN2ZyBoZWlnaHQ9IjE1cHgiIHdpZHRoPSIzMHB4IiBmaWxsPSIjYWFhYWFhIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiB2ZXJzaW9uPSIxLjEiIHg9IjBweCIgeT0iMHB4IiB2aWV3Qm94PSIwIDAgMTAwIDEwMCIgZW5hYmxlLWJhY2tncm91bmQ9Im5ldyAwIDAgMTAwIDEwMCIgeG1sOnNwYWNlPSJwcmVzZXJ2ZSI+PGcgZGlzcGxheT0ibm9uZSI+PGcgZGlzcGxheT0iaW5saW5lIj48Zz48cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZmlsbD0iI2FhYWFhYSIgZD0iTTMwLDI3QzE3LjM1LDI3LDcsMzcuMzUsNyw1MGwwLDBjMCwxMi42NSwxMC4zNSwyMywyMywyM2g0MCBjMTIuNjUsMCwyMy0xMC4zNSwyMy0yM2wwLDBjMC0xMi42NS0xMC4zNS0yMy0yMy0yM0gzMHogTTcwLDY3Yy05LjM4OSwwLTE3LTcuNjEtMTctMTdzNy42MTEtMTcsMTctMTdzMTcsNy42MSwxNywxNyAgICAgUzc5LjM4OSw2Nyw3MCw2N3oiPjwvcGF0aD48L2c+PC9nPjwvZz48Zz48cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTMwLDI3QzE3LjM1LDI3LDcsMzcuMzUsNyw1MGwwLDBjMCwxMi42NSwxMC4zNSwyMywyMywyM2g0MCAgIGMxMi42NSwwLDIzLTEwLjM1LDIzLTIzbDAsMGMwLTEyLjY1LTEwLjM1LTIzLTIzLTIzSDMweiBNNzAsNjdjLTkuMzg5LDAtMTctNy42MS0xNy0xN3M3LjYxMS0xNywxNy0xN3MxNyw3LjYxLDE3LDE3ICAgUzc5LjM4OSw2Nyw3MCw2N3oiPjwvcGF0aD48L2c+PGcgZGlzcGxheT0ibm9uZSI+PGcgZGlzcGxheT0iaW5saW5lIj48cGF0aCBmaWxsPSIjYWFhYWFhIiBzdHJva2U9IiNhYWFhYWEiIHN0cm9rZS13aWR0aD0iNCIgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIiBkPSJNNyw1MGMwLDEyLjY1LDEwLjM1LDIzLDIzLDIzaDQwICAgIGMxMi42NSwwLDIzLTEwLjM1LDIzLTIzbDAsMGMwLTEyLjY1LTEwLjM1LTIzLTIzLTIzSDMwQzE3LjM1LDI3LDcsMzcuMzUsNyw1MEw3LDUweiI+PC9wYXRoPjwvZz48Y2lyY2xlIGRpc3BsYXk9ImlubGluZSIgZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGZpbGw9IiNhYWFhYWEiIHN0cm9rZT0iI2FhYWFhYSIgc3Ryb2tlLXdpZHRoPSI0IiBzdHJva2UtbWl0ZXJsaW1pdD0iMTAiIGN4PSI3MCIgY3k9IjUwIiByPSIxNyI+PC9jaXJjbGU+PC9nPjxnIGRpc3BsYXk9Im5vbmUiPjxwYXRoIGRpc3BsYXk9ImlubGluZSIgZD0iTTcwLDI1SDMwQzE2LjIxNSwyNSw1LDM2LjIxNSw1LDUwczExLjIxNSwyNSwyNSwyNWg0MGMxMy43ODUsMCwyNS0xMS4yMTUsMjUtMjVTODMuNzg1LDI1LDcwLDI1eiBNNzAsNzEgICBIMzBDMTguNDIxLDcxLDksNjEuNTc5LDksNTBzOS40MjEtMjEsMjEtMjFoNDBjMTEuNTc5LDAsMjEsOS40MjEsMjEsMjFTODEuNTc5LDcxLDcwLDcxeiBNNzAsMzFjLTEwLjQ3NywwLTE5LDguNTIzLTE5LDE5ICAgczguNTIzLDE5LDE5LDE5czE5LTguNTIzLDE5LTE5UzgwLjQ3NywzMSw3MCwzMXogTTcwLDY1Yy04LjI3MSwwLTE1LTYuNzI5LTE1LTE1czYuNzI5LTE1LDE1LTE1czE1LDYuNzI5LDE1LDE1Uzc4LjI3MSw2NSw3MCw2NXoiPjwvcGF0aD48L2c+PC9zdmc+);\n    background-size: 50px 37px;\n    background-position: -6px -10px;\n    transform: rotate(180deg);\n    opacity: 0.4;\n}\n\n\n\n/*.sidebar__toggle--active .sidebar__toggle-input {*/\n/*    transition: background-color var(--sidebar-hover-transition-time);*/\n/*    background-color: var(--sidebar-toggle-input-color);*/\n/*}*/\n/*.sidebar__toggle--active .sidebar__toggle-input:hover*/\n/*{*/\n/*    background-color: var(--sidebar-toggle-input-color-hover);*/\n/*    border-color: var(--sidebar-toggle-input-color-hover);*/\n/*    transition: background-color var(--sidebar-hover-transition-time);*/\n/*    transition: border-color var(--sidebar-hover-transition-time);*/\n/*}*/\n\n/*\n * SIDEBAR ITEM BUTTON\n */\n\n.sidebar__button {}\n\n.sidebar__button-input {\n    -webkit-user-select: none;  /* Chrome all / Safari all */\n    -moz-user-select: none;     /* Firefox all */\n    -ms-user-select: none;      /* IE 10+ */\n    user-select: none;          /* Likely future */\n    min-height: 24px;\n    background-color: transparent;\n    color: #CCCCCC;\n    box-sizing: border-box;\n    padding-top: 3px;\n    text-align: center;\n    border-radius: 125px;\n    border:2px solid #555;\n    cursor: pointer;\n    padding-bottom: 3px;\n}\n\n.sidebar__button-input.plus, .sidebar__button-input.minus {\n    display: inline-block;\n    min-width: 20px;\n}\n\n.sidebar__button-input:hover {\n  background-color: #333;\n  border:2px solid var(--sidebar-color);\n}\n\n/*\n * VALUE DISPLAY (shows a value)\n */\n\n.sidebar__value-display {}\n\n/*\n * SLIDER\n */\n\n.sidebar__slider {\n    --sidebar-slider-input-height: 3px;\n}\n\n.sidebar__slider-input-wrapper {\n    width: 100%;\n\n    margin-top: 8px;\n    position: relative;\n}\n\n.sidebar__slider-input {\n    -webkit-appearance: none;\n    appearance: none;\n    margin: 0;\n    width: 100%;\n    height: var(--sidebar-slider-input-height);\n    background: #555;\n    cursor: pointer;\n    outline: 0;\n\n    -webkit-transition: .2s;\n    transition: background-color .2s;\n    border: none;\n}\n\n.sidebar__slider-input:focus, .sidebar__slider-input:hover {\n    border: none;\n}\n\n.sidebar__slider-input-active-track {\n    user-select: none;\n    position: absolute;\n    z-index: 11;\n    top: 0;\n    left: 0;\n    background-color: var(--sidebar-color);\n    pointer-events: none;\n    height: var(--sidebar-slider-input-height);\n    max-width: 100%;\n}\n\n/* Mouse-over effects */\n.sidebar__slider-input:hover {\n    /*background-color: #444444;*/\n}\n\n/*.sidebar__slider-input::-webkit-progress-value {*/\n/*    background-color: green;*/\n/*    color:green;*/\n\n/*    }*/\n\n/* The slider handle (use -webkit- (Chrome, Opera, Safari, Edge) and -moz- (Firefox) to override default look) */\n\n.sidebar__slider-input::-moz-range-thumb\n{\n    position: absolute;\n    height: 15px;\n    width: 15px;\n    z-index: 900 !important;\n    border-radius: 20px !important;\n    cursor: pointer;\n    background: var(--sidebar-color) !important;\n    user-select: none;\n\n}\n\n.sidebar__slider-input::-webkit-slider-thumb\n{\n    position: relative;\n    appearance: none;\n    -webkit-appearance: none;\n    user-select: none;\n    height: 15px;\n    width: 15px;\n    display: block;\n    z-index: 900 !important;\n    border: 0;\n    border-radius: 20px !important;\n    cursor: pointer;\n    background: #777 !important;\n}\n\n.sidebar__slider-input:hover ::-webkit-slider-thumb {\n    background-color: #EEEEEE !important;\n}\n\n/*.sidebar__slider-input::-moz-range-thumb {*/\n\n/*    width: 0 !important;*/\n/*    height: var(--sidebar-slider-input-height);*/\n/*    background: #EEEEEE;*/\n/*    cursor: pointer;*/\n/*    border-radius: 0 !important;*/\n/*    border: none;*/\n/*    outline: 0;*/\n/*    z-index: 100 !important;*/\n/*}*/\n\n.sidebar__slider-input::-moz-range-track {\n    background-color: transparent;\n    z-index: 11;\n}\n\n/*.sidebar__slider-input::-moz-range-thumb:hover {*/\n  /* background-color: #EEEEEE; */\n/*}*/\n\n\n/*.sidebar__slider-input-wrapper:hover .sidebar__slider-input-active-track {*/\n/*    background-color: #EEEEEE;*/\n/*}*/\n\n/*.sidebar__slider-input-wrapper:hover .sidebar__slider-input::-moz-range-thumb {*/\n/*    background-color: #fff !important;*/\n/*}*/\n\n/*.sidebar__slider-input-wrapper:hover .sidebar__slider-input::-webkit-slider-thumb {*/\n/*    background-color: #EEEEEE;*/\n/*}*/\n\n.sidebar__slider input[type=text],\n.sidebar__slider input[type=paddword]\n{\n    box-sizing: border-box;\n    /*background-color: #333333;*/\n    text-align: right;\n    color: #BBBBBB;\n    display: inline-block;\n    background-color: transparent !important;\n\n    width: 40%;\n    height: 18px;\n    outline: none;\n    border: none;\n    border-radius: 0;\n    padding: 0 0 0 4px !important;\n    margin: 0;\n}\n\n.sidebar__slider input[type=text]:active,\n.sidebar__slider input[type=text]:focus,\n.sidebar__slider input[type=text]:hover\n.sidebar__slider input[type=password]:active,\n.sidebar__slider input[type=password]:focus,\n.sidebar__slider input[type=password]:hover\n{\n\n    color: #EEEEEE;\n}\n\n/*\n * TEXT / DESCRIPTION\n */\n\n.sidebar__text .sidebar__item-label {\n    width: auto;\n    display: block;\n    max-height: none;\n    margin-right: 0;\n    line-height: 1.1em;\n}\n\n/*\n * SIDEBAR INPUT\n */\n.sidebar__text-input textarea,\n.sidebar__text-input input[type=text],\n.sidebar__text-input input[type=password] {\n    box-sizing: border-box;\n    background-color: #333333;\n    color: #BBBBBB;\n    display: inline-block;\n    width: 50%;\n    height: 18px;\n    outline: none;\n    border: none;\n    border-radius: 0;\n    border:1px solid #666;\n    padding: 0 0 0 4px !important;\n    margin: 0;\n}\n\n.sidebar__text-input textarea:focus::placeholder {\n  color: transparent;\n}\n\n.sidebar__color-picker .sidebar__item-label\n{\n    width:45%;\n}\n\n.sidebar__text-input textarea,\n.sidebar__text-input input[type=text]:active,\n.sidebar__text-input input[type=text]:focus,\n.sidebar__text-input input[type=text]:hover,\n.sidebar__text-input input[type=password]:active,\n.sidebar__text-input input[type=password]:focus,\n.sidebar__text-input input[type=password]:hover {\n    background-color: transparent;\n    color: #EEEEEE;\n}\n\n.sidebar__text-input textarea\n{\n    margin-top:10px;\n    height:60px;\n    width:100%;\n}\n\n/*\n * SIDEBAR SELECT\n */\n\n\n\n .sidebar__select {}\n .sidebar__select-select {\n    color: #BBBBBB;\n    /*-webkit-appearance: none;*/\n    /*-moz-appearance: none;*/\n    appearance: none;\n    /*box-sizing: border-box;*/\n    width: 50%;\n    /*height: 20px;*/\n    background-color: #333333;\n    /*background-image: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyNCIgaGVpZ2h0PSIyNCIgdmlld0JveD0iMCAwIDI0IDI0IiBmaWxsPSJub25lIiBzdHJva2U9IiM4ODg4ODgiIHN0cm9rZS13aWR0aD0iMiIgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIiBzdHJva2UtbGluZWpvaW49InJvdW5kIiBjbGFzcz0iZmVhdGhlciBmZWF0aGVyLWNoZXZyb24tZG93biI+PHBvbHlsaW5lIHBvaW50cz0iNiA5IDEyIDE1IDE4IDkiPjwvcG9seWxpbmU+PC9zdmc+);*/\n    background-repeat: no-repeat;\n    background-position: right center;\n    background-size: 16px 16px;\n    margin: 0;\n    /*padding: 0 2 2 6px;*/\n    border-radius: 5px;\n    border: 1px solid #777;\n    background-color: #444;\n    cursor: pointer;\n    outline: none;\n    padding-left: 5px;\n\n }\n\n.sidebar__select-select:hover,\n.sidebar__select-select:active,\n.sidebar__select-select:inactive {\n    background-color: #444444;\n    color: #EEEEEE;\n}\n\n/*.sidebar__select-select option*/\n/*{*/\n/*    background-color: #444444;*/\n/*    color: #bbb;*/\n/*}*/\n\n.sidebar__select-select option:checked\n{\n    background-color: #000;\n    color: #FFF;\n}\n\n\n/*\n * COLOR PICKER\n */\n\n\n .sidebar__color-picker input[type=text] {\n    box-sizing: border-box;\n    background-color: #333333;\n    color: #BBBBBB;\n    display: inline-block;\n    width: calc(50% - 21px); /* 50% minus space of picker circle */\n    height: 18px;\n    outline: none;\n    border: none;\n    border-radius: 0;\n    padding: 0 0 0 4px !important;\n    margin: 0;\n    margin-right: 7px;\n}\n\n.sidebar__color-picker input[type=text]:active,\n.sidebar__color-picker input[type=text]:focus,\n.sidebar__color-picker input[type=text]:hover {\n    background-color: #444444;\n    color: #EEEEEE;\n}\n\ndiv.sidebar__color-picker-color-input,\n.sidebar__color-picker input[type=color],\n.sidebar__palette-picker input[type=color] {\n    display: inline-block;\n    border-radius: 100%;\n    height: 14px;\n    width: 14px;\n\n    padding: 0;\n    border: none;\n    /*border:2px solid red;*/\n    border-color: transparent;\n    outline: none;\n    background: none;\n    appearance: none;\n    -moz-appearance: none;\n    -webkit-appearance: none;\n    cursor: pointer;\n    position: relative;\n    top: 3px;\n}\n.sidebar__color-picker input[type=color]:focus,\n.sidebar__palette-picker input[type=color]:focus {\n    outline: none;\n}\n.sidebar__color-picker input[type=color]::-moz-color-swatch,\n.sidebar__palette-picker input[type=color]::-moz-color-swatch {\n    border: none;\n}\n.sidebar__color-picker input[type=color]::-webkit-color-swatch-wrapper,\n.sidebar__palette-picker input[type=color]::-webkit-color-swatch-wrapper {\n    padding: 0;\n}\n.sidebar__color-picker input[type=color]::-webkit-color-swatch,\n.sidebar__palette-picker input[type=color]::-webkit-color-swatch {\n    border: none;\n    border-radius: 100%;\n}\n\n/*\n * Palette Picker\n */\n.sidebar__palette-picker .sidebar__palette-picker-color-input.first {\n    margin-left: 0;\n}\n.sidebar__palette-picker .sidebar__palette-picker-color-input.last {\n    margin-right: 0;\n}\n.sidebar__palette-picker .sidebar__palette-picker-color-input {\n    margin: 0 4px;\n}\n\n.sidebar__palette-picker .circlebutton {\n    width: 14px;\n    height: 14px;\n    border-radius: 1em;\n    display: inline-block;\n    top: 3px;\n    position: relative;\n}\n\n/*\n * Preset\n */\n.sidebar__item-presets-preset\n{\n    padding:4px;\n    cursor:pointer;\n    padding-left:8px;\n    padding-right:8px;\n    margin-right:4px;\n    background-color:#444;\n}\n\n.sidebar__item-presets-preset:hover\n{\n    background-color:#666;\n}\n\n.sidebar__greyout\n{\n    background: #222;\n    opacity: 0.8;\n    width: 100%;\n    height: 100%;\n    position: absolute;\n    z-index: 1000;\n    right: 0;\n    top: 0;\n}\n\n.sidebar_tabs\n{\n    background-color: #151515;\n    padding-bottom: 0px;\n}\n\n.sidebar_switchs\n{\n    float: right;\n}\n\n.sidebar_tab\n{\n    float:left;\n    background-color: #151515;\n    border-bottom:1px solid transparent;\n    padding-right:7px;\n    padding-left:7px;\n    padding-bottom: 5px;\n    padding-top: 5px;\n    cursor:pointer;\n}\n\n.sidebar_tab_active\n{\n    background-color: #272727;\n    color:white;\n}\n\n.sidebar_tab:hover\n{\n    border-bottom:1px solid #777;\n    color:white;\n}\n\n\n.sidebar_switch\n{\n    float:left;\n    background-color: #444;\n    padding-right:7px;\n    padding-left:7px;\n    padding-bottom: 5px;\n    padding-top: 5px;\n    cursor:pointer;\n}\n\n.sidebar_switch:last-child\n{\n    border-top-right-radius: 7px;\n    border-bottom-right-radius: 7px;\n}\n\n.sidebar_switch:first-child\n{\n    border-top-left-radius: 7px;\n    border-bottom-left-radius: 7px;\n}\n\n\n.sidebar_switch_active\n{\n    background-color: #999;\n    color:white;\n}\n\n.sidebar_switch:hover\n{\n    color:white;\n}\n\n"
    };
    const i = "cables-sidebar-style";
    const s = "cables-sidebar-dynamic-style";
    const o = "sidebar-cables";
    const l = "sidebar" + CABLES.uuid();
    const h = "sidebar__items";
    const c = "sidebar__close-button";
    const r = "";
    const u = "";
    let d = null;
    let R = null;
    let g = null;
    const e = a.inValueBool("Visible", true);
    const t = a.inValueSlider("Opacity", 1);
    const m = a.inValueBool("Default Minimized");
    const f = a.inValueSlider("Minimized Opacity", .5);
    const p = a.inValueBool("Show undo button", false);
    const b = a.inValueBool("Show Minimize", false);
    const _ = a.inString("Title", "");
    const v = a.inValueBool("Side");
    const x = a.outObject("childs");
    x.setUiAttribs({
        title: "Children"
    });
    const y = a.outBool("Opfened");
    y.setUiAttribs({
        title: "Opened"
    });
    let C = document.querySelector("." + l);
    if (!C) {
        C = N()
    }
    const S = C.querySelector("." + h);
    x.set({
        parentElement: S,
        parentOp: a
    });
    E();
    B();
    M();
    e.onChange = L;
    t.onChange = O;
    m.onChange = E;
    f.onChange = A;
    p.onChange = I;
    a.onDelete = V;

    function A() {
        M()
    }
    b.onChange = w;

    function w(e) {
        if (!e || e.uiAttribs) e = document.querySelector(".sidebar-cables .sidebar__group-header");
        if (!e) return;
        const t = document.querySelector(".sidebar-cables .sidebar__group-header .sidebar__group-header-undo");
        if (b.get()) {
            e.classList.add("iconsidebar-chevron-up");
            e.classList.add("iconsidebar-minimizebutton");
            if (t) t.style.marginRight = "20px"
        } else {
            e.classList.remove("iconsidebar-chevron-up");
            e.classList.remove("iconsidebar-minimizebutton");
            if (t) t.style.marginRight = "initial"
        }
    }
    v.onChange = function() {
        if (v.get()) C.classList.add("sidebar-cables-right");
        else C.classList.remove("sidebar-cables-right")
    };

    function I() {
        const e = document.querySelector(".sidebar-cables .sidebar__group-header");
        if (e) {
            T(e)
        }
    }

    function T(e) {
        if (e) {
            const t = document.querySelector(".sidebar-cables .sidebar__group-header .sidebar__group-header-undo");
            if (t) {
                if (!p.get()) {
                    t.remove()
                }
            } else {
                if (p.get()) {
                    const n = document.createElement("span");
                    n.classList.add("sidebar__group-header-undo");
                    n.classList.add("sidebar-icon-undo");
                    n.addEventListener("click", function(e) {
                        e.stopPropagation();
                        const t = document.querySelectorAll(".sidebar-cables .sidebar__reloadable");
                        const n = document.createEvent("MouseEvents");
                        n.initEvent("dblclick", true, true);
                        t.forEach(e => {
                            e.dispatchEvent(n)
                        })
                    });
                    e.appendChild(n)
                }
            }
        }
        w(e)
    }

    function E() {
        if (!d) {
            return
        }
        if (m.get()) {
            C.classList.add("sidebar--closed");
            if (e.get()) {
                y.set(false)
            }
        } else {
            C.classList.remove("sidebar--closed");
            if (e.get()) {
                y.set(true)
            }
        }
    }

    function O() {
        const e = t.get();
        C.style.opacity = e
    }

    function L() {
        if (e.get()) {
            C.style.display = "block";
            if (!C.classList.contains("sidebar--closed")) {
                y.set(true)
            }
        } else {
            C.style.display = "none";
            y.set(false)
        }
    }
    v.onChanged = function() {};

    function M() {
        const e = document.querySelectorAll("." + s);
        if (e) {
            e.forEach(function(e) {
                e.parentNode.removeChild(e)
            })
        }
        const t = document.createElement("style");
        t.classList.add(s);
        let n = ".sidebar--closed .sidebar__close-button { ";
        n += "opacity: " + f.get();
        n += "}";
        const i = document.createTextNode(n);
        t.appendChild(i);
        document.body.appendChild(t)
    }

    function N() {
        const e = document.createElement("div");
        e.classList.add(o);
        e.classList.add(l);
        const t = a.patch.cgl.canvas.parentElement;
        const n = document.createElement("div");
        n.classList.add("sidebar__group");
        e.appendChild(n);
        const i = document.createElement("div");
        i.classList.add("sidebar__group-header");
        e.appendChild(i);
        const s = document.createElement("span");
        s.classList.add("sidebar__group-header-title");
        g = document.createElement("span");
        g.classList.add("sidebar__group-header-title-text");
        g.innerHTML = _.get();
        s.appendChild(g);
        i.appendChild(s);
        T(i);
        w(i);
        n.appendChild(i);
        e.appendChild(n);
        n.addEventListener("click", k);
        if (!t) {
            a.warn("[sidebar] no canvas parentelement found...");
            return
        }
        t.appendChild(e);
        const r = document.createElement("div");
        r.classList.add(h);
        e.appendChild(r);
        d = document.createElement("div");
        d.classList.add(c);
        d.addEventListener("click", k);
        e.appendChild(d);
        return e
    }
    _.onChange = function() {
        if (g) g.innerHTML = _.get()
    };

    function j(e) {}

    function k(e) {
        e.stopPropagation();
        if (!C) {
            a.logError("Sidebar could not be closed...");
            return
        }
        C.classList.toggle("sidebar--closed");
        const t = e.target;
        let n = r;
        if (C.classList.contains("sidebar--closed")) {
            n = u;
            y.set(false)
        } else {
            y.set(true)
        }
    }

    function B() {
        const e = document.querySelectorAll("." + i);
        if (e) {
            e.forEach(function(e) {
                e.parentNode.removeChild(e)
            })
        }
        const t = document.createElement("style");
        t.innerHTML = n.style_css;
        t.classList.add(i);
        document.body.appendChild(t)
    }

    function V() {
        P(C)
    }

    function P(e) {
        if (e && e.parentNode && e.parentNode.removeChild) e.parentNode.removeChild(e)
    }
};
Ops.Sidebar.Sidebar.prototype = new CABLES.Op;
CABLES.OPS["5a681c35-78ce-4cb3-9858-bc79c34c6819"] = {
    f: Ops.Sidebar.Sidebar,
    objName: "Ops.Sidebar.Sidebar"
};
Ops.Sidebar.TextInput_v2 = function() {
    CABLES.Op.apply(this, arguments);
    const t = this;
    const e = {};
    const n = t.inObject("Link"),
        i = t.inString("Text", "Text"),
        s = t.inString("Default", ""),
        r = t.inString("Placeholder", ""),
        a = t.inSwitch("Type", ["text", "password"], "text"),
        o = t.inBool("TextArea", false),
        l = t.inBool("Grey Out", false),
        h = t.inBool("Visible", true),
        c = t.inTriggerButton("Clear"),
        u = t.outObject("Children"),
        d = t.outString("Result", s.get()),
        g = t.outBool("Focus");
    const m = document.createElement("div");
    m.dataset.op = t.id;
    m.classList.add("cablesEle");
    m.classList.add("sidebar__item");
    m.classList.add("sidebar__text-input");
    m.classList.add("sidebar__reloadable");
    const f = document.createElement("div");
    f.classList.add("sidebar__item-label");
    const p = document.createTextNode(i.get());
    f.appendChild(p);
    m.appendChild(f);
    f.addEventListener("dblclick", function() {
        d.set(s.get());
        b.value = s.get()
    });
    let b = null;
    v();
    t.toWorkPortsNeedToBeLinked(n);
    o.onChange = v;
    a.onChange = _;

    function _() {
        b.setAttribute("type", a.get());
        b.setAttribute("value", s.get());
        b.setAttribute("placeholder", r.get())
    }

    function v() {
        if (b) b.remove();
        if (!o.get()) {
            b = document.createElement("input")
        } else {
            b = document.createElement("textarea");
            A()
        }
        b.classList.add("sidebar__text-input-input");
        _();
        m.appendChild(b);
        b.addEventListener("input", S);
        b.addEventListener("focus", y);
        b.addEventListener("blur", C)
    }
    const x = document.createElement("div");
    x.classList.add("sidebar__greyout");
    m.appendChild(x);
    x.style.display = "none";
    c.onTriggered = () => {
        b.value = "";
        d.set(b.value)
    };

    function y() {
        g.set(true)
    }

    function C() {
        g.set(false)
    }
    r.onChange = () => {
        b.setAttribute("placeholder", r.get())
    };
    l.onChange = function() {
        x.style.display = l.get() ? "block" : "none"
    };
    h.onChange = function() {
        m.style.display = h.get() ? "block" : "none"
    };
    n.onChange = I;
    i.onChange = w;
    s.onChange = A;
    t.onDelete = O;

    function S(e) {
        d.set(e.target.value)
    }

    function A() {
        const e = s.get();
        d.set(e);
        b.value = e
    }

    function w() {
        const e = i.get();
        f.textContent = e;
        if (CABLES.UI) {
            t.setTitle("Text Input: " + e)
        }
    }

    function I() {
        u.set(null);
        const e = n.get();
        if (e && e.parentElement) {
            e.parentElement.appendChild(m);
            u.set(e)
        } else {
            if (m.parentElement) {
                m.parentElement.removeChild(m)
            }
        }
    }

    function T(e) {
        if (e) {
            e.style.display = "block"
        }
    }

    function E(e) {
        if (e) {
            e.style.display = "none"
        }
    }

    function O() {
        L(m)
    }

    function L(e) {
        if (e && e.parentNode && e.parentNode.removeChild) {
            e.parentNode.removeChild(e)
        }
    }
};
Ops.Sidebar.TextInput_v2.prototype = new CABLES.Op;
CABLES.OPS["6538a190-e73c-451b-964e-d010ee267aa9"] = {
    f: Ops.Sidebar.TextInput_v2,
    objName: "Ops.Sidebar.TextInput_v2"
};
Ops.Date.DateTimestamp = function() {
    CABLES.Op.apply(this, arguments);
    const e = this;
    const t = {};
    const n = e.inValueInt("Year"),
        i = e.inValueInt("Month"),
        s = e.inValueInt("Day"),
        r = e.inValueInt("Hour"),
        a = e.inValueInt("Minute"),
        o = e.outNumber("Timestamp");
    n.onChange = i.onChange = s.onChange = r.onChange = a.onChange = l;

    function l() {
        const e = new Date;
        const t = new Date(Date.UTC(n.get(), i.get() - 1, s.get(), r.get(), a.get()) + e.getTimezoneOffset() * 60 * 1e3);
        o.set(t.getTime())
    }
};
Ops.Date.DateTimestamp.prototype = new CABLES.Op;
CABLES.OPS["e86a668b-db87-472e-9484-3fd102ccbf8a"] = {
    f: Ops.Date.DateTimestamp,
    objName: "Ops.Date.DateTimestamp"
};
Ops.Sidebar.SideBarStyle = function() {
    CABLES.Op.apply(this, arguments);
    const e = this;
    const t = {};
    const n = e.inObject("link"),
        i = e.inInt("Width", 220),
        s = e.inFloat("Round Corners", 10),
        r = e.inString("Special Color", "#07f78c"),
        a = e.outObject("childs");
    r.onChange = s.onChange = i.onChange = l;
    n.onChange = h;
    e.onDelete = d;
    e.toWorkNeedsParent("Ops.Sidebar.Sidebar");
    let o = null;

    function l() {
        if (!o) return;
        o.style.setProperty("--sidebar-width", i.get() + "px");
        o.style.setProperty("--sidebar-color", r.get());
        o.style.setProperty("--sidebar-border-radius", Math.round(s.get()) + "px");
        e.patch.emitEvent("sidebarStylesChanged")
    }

    function h() {
        a.set(null);
        const e = n.get();
        if (e && e.parentElement) {
            a.set(e);
            o = e.parentElement.parentElement;
            l()
        } else {
            o = null
        }
    }

    function c(e) {
        if (!e) return;
        e.style.display = "block"
    }

    function u(e) {
        if (!e) return;
        e.style.display = "none"
    }

    function d() {}
};
Ops.Sidebar.SideBarStyle.prototype = new CABLES.Op;
CABLES.OPS["87d78a59-c8d4-4269-a3f8-af273741aae4"] = {
    f: Ops.Sidebar.SideBarStyle,
    objName: "Ops.Sidebar.SideBarStyle"
};
Ops.Sidebar.SideBarSwitch = function() {
    CABLES.Op.apply(this, arguments);
    const t = this;
    const e = {};
    const n = t.inObject("link"),
        i = t.inArray("Names"),
        s = t.inSwitch("Style", ["Tabs", "Switch"], "Switch"),
        r = t.inString("Text", "Switch"),
        a = t.inInt("Input", 0),
        o = t.inTriggerButton("Set Default"),
        l = t.inBool("Grey Out", false),
        h = t.inValue("Default", 0),
        c = t.outObject("childs"),
        u = t.outNumber("Index", -1),
        d = t.outString("String");
    let g = null;
    const m = document.createElement("div");
    m.classList.add("sidebar__item");
    m.dataset.op = t.id;
    m.classList.add("cablesEle");
    h.setUiAttribs({
        greyout: true
    });
    const f = document.createElement("div");
    f.classList.add("sidebar__item-label");
    const p = document.createTextNode(r.get());
    f.appendChild(p);
    m.appendChild(f);
    const b = document.createElement("div");
    m.appendChild(b);
    const _ = document.createElement("div");
    _.classList.add("sidebar__greyout");
    m.appendChild(_);
    _.style.display = "none";
    n.onChange = w;
    t.onDelete = E;
    t.toWorkNeedsParent("Ops.Sidebar.Sidebar");
    t.setPortGroup("Default Item", [h, o]);
    const v = [];
    i.onChange = x;
    s.onChange = y;
    y();
    r.onChange = () => {
        f.innerHTML = r.get()
    };
    l.onChange = function() {
        _.style.display = l.get() ? "block" : "none"
    };

    function x() {
        v.length = 0;
        b.innerHTML = "";
        g = null;
        const n = i.get();
        if (!n) return;
        for (let t = 0; t < n.length; t++) {
            const e = C(String(n[t]));
            if (t == h.get()) S(e)
        }
    }
    o.onTriggered = () => {
        h.set(u.get());
        t.refreshParams()
    };

    function y() {
        if (s.get() == "Tabs") {
            m.classList.add("sidebar_tabs");
            b.classList.remove("sidebar_switchs");
            f.style.display = "none"
        } else {
            m.classList.remove("sidebar_tabs");
            b.classList.add("sidebar_switchs");
            f.style.display = "inline-block"
        }
        r.setUiAttribs({
            greyout: s.get() == "Tabs"
        });
        x()
    }

    function C(e) {
        const t = document.createElement("div");
        if (s.get() == "Tabs") t.classList.add("sidebar_tab");
        else t.classList.add("sidebar_switch");
        t.id = "tabEle" + v.length;
        t.innerHTML = e;
        t.dataset.index = v.length;
        t.dataset.txt = e;
        t.addEventListener("click", A);
        b.appendChild(t);
        v.push(t);
        return t
    }
    a.onChange = () => {
        if (v.length > a.get()) A({
            target: v[a.get()]
        })
    };

    function S(e) {
        if (e) {
            g = e;
            t.log(e.dataset.index);
            u.set(parseInt(e.dataset.index));
            d.set(e.dataset.txt);
            if (s.get() == "Tabs") e.classList.add("sidebar_tab_active");
            else e.classList.add("sidebar_switch_active")
        }
    }

    function A(e) {
        if (g)
            if (s.get() == "Tabs") g.classList.remove("sidebar_tab_active");
            else g.classList.remove("sidebar_switch_active");
        S(e.target)
    }

    function w() {
        c.set(null);
        const e = n.get();
        if (e && e.parentElement) {
            e.parentElement.appendChild(m);
            c.set(e)
        } else {
            if (m.parentElement) m.parentElement.removeChild(m)
        }
    }

    function I(e) {
        if (!e) return;
        e.style.display = "block"
    }

    function T(e) {
        if (!e) return;
        e.style.display = "none"
    }

    function E() {
        O(m)
    }

    function O(e) {
        if (e && e.parentNode && e.parentNode.removeChild) {
            e.parentNode.removeChild(e)
        }
    }
};
Ops.Sidebar.SideBarSwitch.prototype = new CABLES.Op;
CABLES.OPS["ebc8c92c-5fa6-4598-a9c6-b8e12f22f7c2"] = {
    f: Ops.Sidebar.SideBarSwitch,
    objName: "Ops.Sidebar.SideBarSwitch"
};
Ops.Sidebar.NumberInput_v2 = function() {
    CABLES.Op.apply(this, arguments);
    const n = this;
    const e = {};
    const t = n.inObject("Link");
    const i = n.inString("Text", "Number");
    const s = n.inValue("Input", 0);
    const r = n.inTriggerButton("Set Default");
    const a = n.inValue("Default", 0);
    a.setUiAttribs({
        hidePort: true,
        greyout: true
    });
    const o = n.outObject("Children");
    const l = n.outNumber("Result", a.get());
    const h = document.createElement("div");
    h.addEventListener("dblclick", function() {
        l.set(parseFloat(a.get()));
        s.set(parseFloat(a.get()))
    });
    h.dataset.op = n.id;
    h.classList.add("cablesEle");
    h.classList.add("sidebar__item");
    h.classList.add("sidebar__text-input");
    h.classList.add("sidebar__reloadable");
    const c = document.createElement("div");
    c.classList.add("sidebar__item-label");
    const u = document.createTextNode(i.get());
    c.appendChild(u);
    h.appendChild(c);
    const d = document.createElement("input");
    d.classList.add("sidebar__text-input-input");
    d.setAttribute("type", "text");
    d.setAttribute("value", a.get());
    h.appendChild(d);
    d.addEventListener("input", f);
    t.onChange = _;
    i.onChange = b;
    a.onChange = p;
    n.onDelete = y;
    s.onChange = m;
    r.onTriggered = g;

    function g() {
        a.set(parseFloat(s.get()));
        n.refreshParams()
    }

    function m() {
        let e = parseFloat(s.get());
        if (isNaN(e)) {
            e = 0
        }
        d.value = e;
        l.set(e)
    }

    function f(e) {
        let t = parseFloat(e.target.value);
        if (isNaN(t)) {
            t = 0
        }
        l.set(t);
        s.set(t);
        n.refreshParams()
    }

    function p() {}

    function b() {
        const e = i.get();
        c.textContent = e;
        if (CABLES.UI) {
            n.setTitle("Number Input: " + e)
        }
    }

    function _() {
        o.set(null);
        const e = t.get();
        if (e && e.parentElement) {
            e.parentElement.appendChild(h);
            o.set(e)
        } else {
            if (h.parentElement) {
                h.parentElement.removeChild(h)
            }
        }
    }

    function v(e) {
        if (e) {
            e.style.display = "block"
        }
    }

    function x(e) {
        if (e) {
            e.style.display = "none"
        }
    }

    function y() {
        C(h)
    }

    function C(e) {
        if (e && e.parentNode && e.parentNode.removeChild) {
            e.parentNode.removeChild(e)
        }
    }
};
Ops.Sidebar.NumberInput_v2.prototype = new CABLES.Op;
CABLES.OPS["c4f3f1d7-de07-4c06-921e-32baeef4fc68"] = {
    f: Ops.Sidebar.NumberInput_v2,
    objName: "Ops.Sidebar.NumberInput_v2"
};
Ops.Sidebar.ColorPicker_v3 = function() {
    CABLES.Op.apply(this, arguments);
    const n = this;
    const e = {
        colorrick_css: ".colorRick_dialog\n{\n    --width:256px;\n    --height:256px;\n    --width-hue:20px;\n    --pad:10px;\n    --colorblock-height:20px;\n    --inputcontainer-height:120px;\n\n    background-color: #333;\n    width:calc(var(--width) + 3*var(--pad) + var(--width-hue));\n    height:calc(var(--height) + var(--colorblock-height) + 30px + var(--inputcontainer-height));\n    position: absolute;\n    border-radius: 10px;\n    overflow: hidden;\n    z-index: 999999;\n\n}\n\n.colorRick_dialog *\n{\n    font-size: 13px;\n}\n\n.colorRick_area\n{\n    width:var(--width);\n    height:var(--height);\n    left:var(--pad);\n    top:var(--pad);\n    background: linear-gradient(to right, rgb(255, 255, 255), rgb(0, 255, 11));\n    position: absolute;\n    cursor:pointer;\n}\n\n.colorRick_brightness\n{\n    background: linear-gradient(hsla(0,0%,100%,0),#000);\n    width:100%;\n    height:100%;\n    pointer-events: none;\n}\n\n.colorRick_hue\n{\n    cursor:pointer;\n    top:var(--pad);\n    background:linear-gradient(red,#f0f 17%,#00f 34%,#0ff 50%,#0f0 67%,#ff0 84%,red);\n    height:var(--height);\n\n    width:var(--width-hue);\n    position: absolute;\n    left:calc(var(--width) + var(--pad) + var(--pad));\n}\n\n.colorRick_preview\n{\n    position: absolute;\n    width:calc(var(--width) / 10 * 9);\n    height:var(--colorblock-height);\n    top:calc(var(--height) + 20px);\n    margin-left:10px;\n}\n\n.colorRick_preview_orig\n{\n    margin-left:calc(calc(var(--width) / 10 * 9) + 10px);\n    width:calc(var(--width) / 10);\n    cursor:pointer;\n}\n\n.colorRick_cursor\n{\n    width:4px;\n    height:4px;\n    border:1px solid transparent;\n    background-color: white;\n    position: absolute;\n    pointer-events: none;\n    border-radius: 100%;\n}\n\n.colorRick_cursor_hue\n{\n    position: absolute;\n    width:24px;\n    margin-left: -2px;\n    height:0px;\n    border-top:1px solid white;\n    border-bottom:1px solid white;\n    position: absolute;\n    pointer-events: none;\n}\n\n.colorRick_inputcontainer\n{\n    position: absolute;\n\n    height:var(--inputcontainer-height);\n    /* top:250px; */\n    top:calc(var(--height) + 20px + 20px + 10px);\n    left:0px;\n    width:100%;\n    background-color: #000;\n    padding:10px;\n}\n\n.colorRick_inputcontainer table\n{\n    width:var(--width);\n}\n\n.colorRick_inputcontainer, .colorRick_inputcontainer table\n{\n    color:#999;\n}\n\n.colorRick_input\n{\n    background-color: #444;\n    border:0px solid transparent;\n    opacity: 1;\n    color:#ddd;\n}\n\n.colorRick_input_small\n{\n    width:60px;\n    margin-left:10px;\n}\n\n.colorRick_input_hex\n{\n    width:100px;\n}\n\n.colorRick_invalid\n{\n    opacity: 0.5;\n}\n\n.colorRick_inputcontainer table\n{\n    /* width:90%; */\n}\n\n.colorRick_inputcontainer table,.colorRick_inputcontainer table td, .colorRick_inputcontainer table tr\n{\n    /* pointer-events: none; */\n    user-select: none;\n\n    vertical-align: top;\n}\n\n.colorRick_inputcontainer table td.right\n{\n    text-align: right;\n    height: 30px;\n}\n"
    };
    const t = "#07F78C";
    const i = n.inObject("Link");
    const s = n.inString("Text", "Hex Color");
    const r = I(t);
    const a = n.inValueSlider("Input Red", r[0]);
    const o = n.inValueSlider("Input Green", r[1]);
    const l = n.inValueSlider("Input Blue", r[2]);
    const h = n.inTriggerButton("Set Default");
    const c = n.inValueString("Default", t);
    c.setUiAttribs({
        hidePort: true,
        greyout: true
    });
    const u = n.outObject("Children");
    const d = n.outNumber("Red", 0);
    const g = n.outNumber("Green", 0);
    const m = n.outNumber("Blue", 0);
    const f = n.outString("Hex", t);
    const p = document.createElement("div");
    p.dataset.op = n.id;
    p.classList.add("cablesEle");
    p.addEventListener("dblclick", function() {
        let e = c.get();
        y.setAttribute("value", e);
        if (e) {
            if (e.length === 6 && e.charAt(0) !== "#") {
                e = "#" + e
            }
            if (e.length === 7) {
                y.value = e;
                C.value = e;
                M(e)
            }
        }
    });
    p.classList.add("sidebar__item");
    p.classList.add("sidebar__color-picker");
    p.classList.add("sidebar__reloadable");
    const b = document.createElement("style");
    b.type = "text/css";
    b.textContent = e.colorrick_css;
    const _ = document.getElementsByTagName("body")[0];
    _.appendChild(b);
    const v = document.createElement("div");
    v.classList.add("sidebar__item-label");
    const x = document.createTextNode(s.get());
    v.appendChild(x);
    p.appendChild(v);
    const y = document.createElement("input");
    y.classList.add("sidebar__color-picker-input");
    y.setAttribute("type", "text");
    y.setAttribute("value", c.get());
    p.appendChild(y);
    y.addEventListener("input", L);
    const C = document.createElement("div");
    C.classList.add("sidebar__color-picker-color-input");
    C.style.backgroundColor = c.get();
    C.addEventListener("click", function() {
        new ColorRick({
            ele: this,
            color: this.style.backgroundColor || "#ff0000",
            onChange: e => {
                const t = e.hex();
                this.style.backgroundColor = t;
                M(t);
                y.value = t;
                f.set(t);
                O(t);
                n.refreshParams()
            }
        })
    });
    p.appendChild(C);
    y.addEventListener("input", L);
    N();
    i.onChange = B;
    s.onChange = k;
    c.onChange = N;
    n.onDelete = V;
    h.onTriggered = w;
    a.onChange = S;
    o.onChange = S;
    l.onChange = S;

    function S() {
        const e = A();
        C.style.backgroundColor = e;
        y.value = e;
        M(e)
    }

    function A() {
        const e = CABLES.clamp(a.get(), 0, 1);
        const t = CABLES.clamp(o.get(), 0, 1);
        const n = CABLES.clamp(l.get(), 0, 1);
        const i = E(e, t, n);
        return i
    }

    function w() {
        const e = A();
        c.set(e);
        f.set(e);
        n.refreshParams()
    }

    function I(e) {
        if (!e || e.length !== 7) {
            return
        }
        return e.match(/[A-Za-z0-9]{2}/g).map(function(e) {
            return parseInt(e, 16) / 255
        })
    }

    function T(e) {
        const t = e.toString(16);
        return t.length == 1 ? "0" + t : t
    }

    function E(e, t, n) {
        return "#" + T(Math.floor(255 * e)) + T(Math.floor(255 * t)) + T(Math.floor(255 * n))
    }

    function O(e) {
        const t = I(e);
        a.set(t[0]);
        o.set(t[1]);
        l.set(t[2]);
        f.set(e)
    }

    function L(e) {
        let t = e.target.value;
        if (t.length === 6 && t.charAt(0) !== "#") {
            t = "#" + t
        }
        if (t.length === 7) {
            C.value = t;
            M(t);
            O(t);
            f.set(t);
            n.refreshParams()
        }
    }

    function M(e) {
        const t = I(e);
        f.set(e);
        d.set(t[0]);
        g.set(t[1]);
        m.set(t[2])
    }

    function N() {
        let e = c.get();
        y.setAttribute("value", e);
        if (e) {
            if (e.length === 6 && e.charAt(0) !== "#") {
                e = "#" + e
            }
            if (e.length === 7) {
                y.value = e;
                C.value = e;
                M(e)
            }
        }
    }

    function k() {
        const e = s.get();
        v.textContent = e;
        if (CABLES.UI) n.setTitle("Color Picker: " + e)
    }

    function B() {
        u.set(null);
        const e = i.get();
        if (e && e.parentElement) {
            e.parentElement.appendChild(p);
            u.set(e)
        } else {
            if (p.parentElement) {
                p.parentElement.removeChild(p)
            }
        }
    }

    function R(e) {
        if (e) {
            e.style.display = "block"
        }
    }

    function j(e) {
        if (e) {
            e.style.display = "none"
        }
    }

    function V() {
        P(p)
    }

    function P(e) {
        if (e && e.parentNode && e.parentNode.removeChild) {
            e.parentNode.removeChild(e)
        }
    }
};
Ops.Sidebar.ColorPicker_v3.prototype = new CABLES.Op;
CABLES.OPS["52dc1ef8-deb0-4664-a924-4c5548aa8a55"] = {
    f: Ops.Sidebar.ColorPicker_v3,
    objName: "Ops.Sidebar.ColorPicker_v3"
};
Ops.Array.StringToArray_v2 = function() {
    CABLES.Op.apply(this, arguments);
    const i = this;
    const e = {};
    const s = i.inStringEditor("text", "1,2,3"),
        r = i.inString("separator", ","),
        a = i.inValueBool("Numbers", true),
        o = i.inValueBool("Trim", true),
        l = i.inBool("Split Lines", false),
        h = i.outTrigger("Parsed"),
        c = i.outArray("array"),
        u = i.outNumber("length");
    s.setUiAttribs({
        ignoreBigPort: true
    });
    s.onChange = r.onChange = a.onChange = o.onChange = t;
    l.onChange = () => {
        r.setUiAttribs({
            greyout: l.get()
        });
        t()
    };
    t();

    function t() {
        if (!s.get()) {
            c.set(null);
            c.set([]);
            u.set(0);
            return
        }
        let e = s.get();
        if (o.get() && e) {
            e = e.replace(/^\s+|\s+$/g, "");
            e = e.trim()
        }
        let n;
        let t = r.get();
        if (r.get() === "\\n") t = "\n";
        if (l.get()) n = e.split("\n");
        else n = e.split(t);
        if (n[n.length - 1] === "") n.length -= 1;
        u.set(n.length);
        if (o.get()) {
            for (let e = 0; e < n.length; e++) {
                n[e] = n[e].replace(/^\s+|\s+$/g, "");
                n[e] = n[e].trim()
            }
        }
        i.setUiError("notnum", null);
        if (a.get()) {
            let t = false;
            for (let e = 0; e < n.length; e++) {
                n[e] = Number(n[e]);
                if (!CABLES.UTILS.isNumeric(n[e])) {
                    t = true
                }
            }
            if (t) {
                i.setUiError("notnum", "Parse Error / Not all values numerical!")
            }
        }
        c.setRef(n);
        h.trigger()
    }
};
Ops.Array.StringToArray_v2.prototype = new CABLES.Op;
CABLES.OPS["c974de41-4ce4-4432-b94d-724741109c71"] = {
    f: Ops.Array.StringToArray_v2,
    objName: "Ops.Array.StringToArray_v2"
};
Ops.String.String_v2 = function() {
    CABLES.Op.apply(this, arguments);
    const e = this;
    const t = {};
    const n = e.inString("value", ""),
        i = e.outString("String");
    n.onChange = function() {
        i.set(n.get())
    }
};
Ops.String.String_v2.prototype = new CABLES.Op;
CABLES.OPS["d697ff82-74fd-4f31-8f54-295bc64e713d"] = {
    f: Ops.String.String_v2,
    objName: "Ops.String.String_v2"
};
Ops.Gl.SaveScreenShot_v3 = function() {
    CABLES.Op.apply(this, arguments);
    const e = this;
    const t = {};
    const n = e.inString("Filename", "cables"),
        i = e.inTriggerButton("Screenshot"),
        s = e.outTrigger("Finished");
    const r = e.patch.cgl;
    i.onTriggered = function() {
        r.saveScreenshot(n.get(), function() {
            s.trigger();
            e.patch.resume()
        })
    }
};
Ops.Gl.SaveScreenShot_v3.prototype = new CABLES.Op;
CABLES.OPS["76843a4d-947f-41ca-9c8f-0faa6ce7380a"] = {
    f: Ops.Gl.SaveScreenShot_v3,
    objName: "Ops.Gl.SaveScreenShot_v3"
};
Ops.Trigger.TriggerOnce = function() {
    CABLES.Op.apply(this, arguments);
    const e = this;
    const t = {};
    const n = e.inTriggerButton("Exec"),
        i = e.inTriggerButton("Reset"),
        s = e.outTrigger("Next"),
        r = e.outBoolNum("Was Triggered");
    let a = false;
    e.toWorkPortsNeedToBeLinked(n);
    i.onTriggered = function() {
        a = false;
        r.set(a)
    };
    n.onTriggered = function() {
        if (a) return;
        a = true;
        s.trigger();
        r.set(a)
    }
};
Ops.Trigger.TriggerOnce.prototype = new CABLES.Op;
CABLES.OPS["cf3544e4-e392-432b-89fd-fcfb5c974388"] = {
    f: Ops.Trigger.TriggerOnce,
    objName: "Ops.Trigger.TriggerOnce"
};
Ops.Sidebar.Button_v2 = function() {
    CABLES.Op.apply(this, arguments);
    const t = this;
    const e = {};
    const n = t.inObject("link");
    const i = t.inString("Text", "Button");
    const s = t.outObject("childs");
    const r = t.outTrigger("Pressed Trigger");
    const a = t.inBool("Grey Out", false);
    const o = t.inBool("Visible", true);
    const l = document.createElement("div");
    l.dataset.op = t.id;
    l.classList.add("cablesEle");
    l.classList.add("sidebar__item");
    l.classList.add("sidebar--button");
    const h = document.createElement("div");
    h.classList.add("sidebar__button-input");
    l.appendChild(h);
    h.addEventListener("click", d);
    const c = document.createTextNode(i.get());
    h.appendChild(c);
    t.toWorkNeedsParent("Ops.Sidebar.Sidebar");
    n.onChange = m;
    i.onChange = g;
    t.onDelete = b;
    const u = document.createElement("div");
    u.classList.add("sidebar__greyout");
    l.appendChild(u);
    u.style.display = "none";
    a.onChange = function() {
        u.style.display = a.get() ? "block" : "none"
    };
    o.onChange = function() {
        l.style.display = o.get() ? "block" : "none"
    };

    function d() {
        r.trigger()
    }

    function g() {
        const e = i.get();
        h.textContent = e;
        if (CABLES.UI) {
            t.setTitle("Button: " + e)
        }
    }

    function m() {
        s.set(null);
        const e = n.get();
        if (e && e.parentElement) {
            e.parentElement.appendChild(l);
            s.set(e)
        } else {
            if (l.parentElement) {
                l.parentElement.removeChild(l)
            }
        }
    }

    function f(e) {
        if (e) {
            e.style.display = "block"
        }
    }

    function p(e) {
        if (e) {
            e.style.display = "none"
        }
    }

    function b() {
        _(l)
    }

    function _(e) {
        if (e && e.parentNode && e.parentNode.removeChild) {
            e.parentNode.removeChild(e)
        }
    }
};
Ops.Sidebar.Button_v2.prototype = new CABLES.Op;
CABLES.OPS["5e9c6933-0605-4bf7-8671-a016d917f327"] = {
    f: Ops.Sidebar.Button_v2,
    objName: "Ops.Sidebar.Button_v2"
};
Ops.Gl.LineFont_v2 = function() {
    CABLES.Op.apply(this, arguments);
    const l = this;
    const e = {};
    const t = l.inTrigger("render"),
        n = l.inString("Text", "cables"),
        h = l.inValue("Letter Spacing", 1),
        i = l.inSwitch("align", ["left", "center", "right"], "left"),
        s = l.inBool("Render", true),
        c = l.outArray("Lines", null, 3);
    let u = [];
    let d = 0;
    const r = [];
    const g = vec3.create();
    const m = l.patch.cgl;
    const f = [{
        l: [
            [182.667, 349.057, 164.167, 349.057],
            [160.333, 360.557, 171.333, 326.89, 175.333, 326.89, 186, 360.557]
        ]
    }, {
        l: [
            [174.333, 343.057, 160.255, 343.057],
            [160.333, 326.89, 175.5, 326.89, 178.333, 330.724, 178.333, 340.724, 174.333, 343.057, 180.5, 346.807, 180.5, 357.474, 176, 360.557, 160.167, 360.557, 160.333, 326.89]
        ]
    }, {
        l: [
            [180.583, 331.307, 175.917, 326.807, 166, 326.807, 160.083, 332.557, 160.083, 354.557, 165.833, 360.474, 175.917, 360.474, 180.5, 355.807]
        ]
    }, {
        l: [
            [160.083, 327.057, 160.083, 360.557, 175.417, 360.557, 180.708, 355.265, 180.708, 332.974, 175.104, 327.057, 160.083, 327.057]
        ]
    }, {
        l: [
            [175.167, 343.932, 160.436, 343.932],
            [177.917, 326.807, 164.5, 326.807, 160.436, 330.872, 160.436, 356.845, 164.014, 360.422, 177.917, 360.422]
        ]
    }, {
        l: [
            [176.792, 326.932, 164.125, 326.932, 160.167, 330.891, 160.167, 360.683],
            [173.458, 345.599, 160.167, 345.599]
        ]
    }, {
        l: [
            [180.455, 332.395, 175.391, 328.33, 166.194, 328.33, 160.167, 334.357, 160.167, 355.933, 165.792, 360.557, 176.038, 360.557, 181.62, 354.976, 181.62, 344.811, 173.122, 344.811]
        ]
    }, {
        l: [
            [160.167, 326.89, 160.167, 360.557],
            [160.5, 343.723, 182.333, 343.723],
            [182.333, 326.89, 182.333, 360.974]
        ]
    }, {
        l: [
            [160.167, 326.807, 160.167, 360.641]
        ]
    }, {
        l: [
            [159.833, 326.89, 166.833, 326.89, 166.833, 362.057, 163.962, 364.928, 159.833, 364.928]
        ]
    }, {
        l: [
            [160.167, 326.807, 160.167, 360.974],
            [178.917, 326.807, 160.167, 348.474],
            [164.905, 342.998, 180.333, 360.64]
        ]
    }, {
        l: [
            [160.167, 326.974, 160.167, 360.558, 176.083, 360.558]
        ]
    }, {
        l: [
            [160.167, 360.557, 160.247, 326.89, 164.997, 326.89, 175.5, 360.557, 178, 360.557, 188.58, 326.89, 193.33, 326.89, 193.25, 360.557]
        ]
    }, {
        l: [
            [160.167, 360.599, 160.167, 326.933, 164.629, 326.933, 178.333, 360.599, 182.083, 360.599, 182.083, 326.933]
        ]
    }, {
        l: [
            [160.283, 332.448, 165.764, 326.967, 178.405, 326.967, 183.668, 332.23, 183.668, 354.365, 177.434, 360.599, 166.367, 360.599, 160.167, 354.399, 160.283, 332.448]
        ]
    }, {
        l: [
            [160.167, 360.432, 160.167, 327.015, 175.955, 327.015, 179.667, 330.728, 179.667, 341.015, 175.602, 345.08, 160.167, 345.08]
        ]
    }, {
        l: [
            [184.504, 361.693, 180.517, 357.706],
            [160.283, 332.413, 165.764, 326.932, 178.405, 326.932, 183.668, 332.195, 183.668, 354.33, 177.434, 360.564, 166.367, 360.564, 160.167, 354.364, 160.283, 332.413]
        ]
    }, {
        l: [
            [179.667, 360.307, 173.5, 344.955],
            [160.167, 360.307, 160.167, 326.89, 175.955, 326.89, 179.667, 330.603, 179.667, 340.89, 175.602, 344.955, 160.167, 344.955]
        ]
    }, {
        l: [
            [179.979, 326.87, 165.895, 326.87, 160.167, 332.598, 160.167, 338.307, 179.292, 349.057, 179.292, 355.223, 173.917, 360.598, 160.167, 360.598]
        ]
    }, {
        l: [
            [170.417, 326.89, 170.417, 360.974],
            [180.5, 326.89, 160.167, 326.89]
        ]
    }, {
        l: [
            [160.167, 327.14, 160.167, 356.845, 164.108, 360.786, 178.125, 360.786, 182.012, 356.899, 181.958, 327.14]
        ]
    }, {
        l: [
            [160.167, 326.901, 170.167, 360.797, 174.417, 360.797, 184.667, 326.734]
        ]
    }, {
        l: [
            [203.5, 326.89, 195.208, 360.557, 191.458, 360.557, 184, 326.89, 179.758, 326.89, 172.208, 360.557, 168.458, 360.557, 160.167, 326.89]
        ]
    }, {
        l: [
            [181.333, 360.64, 159.667, 326.807],
            [159.667, 360.557, 181.75, 326.807]
        ]
    }, {
        l: [
            [160.167, 326.891, 168.508, 347.224, 173.992, 347.224, 182.917, 326.891],
            [171.333, 347.224, 171.333, 360.641]
        ]
    }, {
        l: [
            [161.167, 326.807, 180.5, 326.807, 180.5, 332.473, 161.167, 355.223, 161.167, 360.557, 180.5, 360.557]
        ]
    }, {
        l: [
            [167.591, 326.89, 173.076, 326.89, 180.5, 334.315, 180.5, 353.132, 173.076, 360.557, 167.591, 360.557, 160.167, 353.132, 160.167, 334.315, 167.591, 326.89]
        ]
    }, {
        l: [
            [160.167, 334.315, 167.549, 326.932, 170.333, 326.89, 170.417, 360.557]
        ]
    }, {
        l: [
            [164.066, 330.415, 167.591, 326.89, 180.5, 326.89, 180.5, 330.603, 160.167, 351.224, 160.167, 360.557, 180.5, 360.599]
        ]
    }, {
        l: [
            [169.583, 342.932, 180.5, 342.932],
            [163.129, 331.353, 167.591, 326.89, 180.5, 326.89, 180.5, 360.557, 167.591, 360.557, 162.837, 355.803]
        ]
    }, {
        l: [
            [178.076, 326.89, 178.076, 360.599],
            [160.167, 326.89, 160.167, 338.474, 165.104, 343.412, 178.5, 343.412]
        ]
    }, {
        l: [
            [180.5, 326.89, 160.098, 326.958, 160.167, 342.932, 180.5, 342.932, 180.5, 353.132, 173.076, 360.557, 160.167, 360.557]
        ]
    }, {
        l: [
            [173.076, 326.89, 167.591, 326.89, 160.167, 333.89, 160.167, 353.132, 167.591, 360.557, 173.417, 360.557, 180.671, 353.303, 180.671, 342.932, 160.167, 342.932]
        ]
    }, {
        l: [
            [163.591, 326.89, 180.5, 326.89, 170.417, 360.557]
        ]
    }, {
        l: [
            [180.5, 334.315, 173.076, 326.89, 167.591, 326.89, 160.167, 334.315, 180.5, 353.132, 173.076, 360.557, 167.591, 360.557, 160.167, 353.132, 180.5, 334.315]
        ]
    }, {
        l: [
            [167.591, 360.557, 173.076, 360.557, 180.5, 353.132, 180.5, 334.315, 173.076, 326.89, 167.591, 326.89, 160.167, 334.315, 160.167, 342.932, 180.5, 342.932]
        ]
    }, {
        l: [
            [182.496, 351.137, 173.076, 360.557, 167.591, 360.557, 160.167, 353.132, 160.167, 348.087, 173.922, 339.533, 172.229, 326.89, 165.167, 326.89, 165.052, 339.515, 184.292, 359.432]
        ]
    }, {
        l: [
            [160.167, 326.932, 160.167, 333.557],
            [162.879, 326.932, 162.879, 333.557]
        ]
    }, {
        l: [
            [160.167, 342.932, 160.167, 346.224],
            [160.167, 354.224, 160.167, 360.557]
        ]
    }, {
        l: [
            [160.167, 342.932, 160.167, 346.224],
            [160.167, 354.224, 160.167, 357.974]
        ]
    }, {
        l: [
            [160.167, 360.557, 170.417, 360.557]
        ]
    }, {
        l: [
            [160.167, 342.932, 170, 342.932],
            [164.833, 347.849, 164.833, 338.015]
        ]
    }, {
        l: [
            [160.167, 342.932, 170, 342.932]
        ]
    }, {
        l: [
            [180.5, 326.89, 160.167, 360.557]
        ]
    }, {
        l: [
            [160.167, 360.599, 163.417, 360.599]
        ]
    }, {
        l: [
            [165.163, 360.557, 160.167, 365.553]
        ]
    }, {
        l: [
            [160.167, 360.557, 167.591, 353.132, 167.591, 334.315, 160.167, 326.89]
        ]
    }, {
        l: [
            [167.591, 326.89, 160.167, 334.315, 160.167, 353.132, 167.591, 360.557]
        ]
    }, {
        l: [
            [170.333, 363.481, 170.333, 368.966],
            [160.167, 334.315, 167.591, 326.89, 173.076, 326.89, 180.5, 334.315, 180.5, 342.932, 170.333, 353.132, 170.333, 360.557]
        ]
    }, {
        l: [
            [160.167, 353.557, 160.167, 326.89],
            [160.167, 357.64, 160.167, 360.557]
        ]
    }];

    function p(e) {
        _ += e;
        vec3.set(g, e, 0, 0);
        mat4.translate(m.mMatrix, m.mMatrix, g)
    }
    let b = 0;
    i.onChange = function() {
        if (i.get() == "left") b = 0;
        if (i.get() == "center") b = 1;
        if (i.get() == "right") b = 2
    };
    let a = 0;
    let o = null;
    let _ = 0;

    function v(t, e) {
        o = m.getShader();
        if (!o) return;
        a = o.glPrimitive;
        o.glPrimitive = m.gl.LINE_STRIP;
        if (t >= f.length) t = 0;
        if (!e) {
            for (let e = 0; e < f[t].linesArr.length; e += 3) {
                u.push(f[t].linesArr[e + 0] + _, f[t].linesArr[e + 1], f[t].linesArr[e + 2])
            }
            for (let e = 0; e < f[t].m.length; e++) {
                if (s.get()) f[t].m[e].render(l.patch.cgl.getShader())
            }
            p(f[t].w * h.get())
        } else {
            d += f[t].w * h.get()
        }
        o.glPrimitive = a
    }
    t.onTriggered = function() {
        d = 0;
        if (!n.get()) return;
        let s = .15;
        vec3.set(g, .3, 0, 0);
        m.pushModelMatrix();
        let r = 97;
        let a = 48;
        let o = n.get() + "";
        for (let e = 0; e < 2; e++) {
            _ = 0;
            u.length = 0;
            let i = e === 0;
            if (!i) {
                if (b == 1) p(-d / 2 + .04 * h.get());
                if (b == 2) p(-d + .08 * h.get())
            }
            for (let n = 0; n < o.length; n++) {
                let e = 0;
                let t = o.toLowerCase().charCodeAt(n);
                if (t == 38) v(36, i);
                else if (t == 39) v(37, i);
                else if (t == 34) v(37, i);
                else if (t == 59) v(38, i);
                else if (t == 58) v(39, i);
                else if (t == 95) v(40, i);
                else if (t == 43) v(41, i);
                else if (t == 45) v(42, i);
                else if (t == 47) v(43, i);
                else if (t == 46) v(44, i);
                else if (t == 44) v(45, i);
                else if (t == 41) v(46, i);
                else if (t == 40) v(47, i);
                else if (t == 63) v(48, i);
                else if (t == 33) v(49, i);
                else if (t >= a && t <= a + 10) {
                    v(t - a + 26, i)
                } else if (t >= r && t - r < f.length) {
                    v(t - r, i)
                } else if (t == 32) {
                    if (i) d += s;
                    else p(s)
                } else {
                    v(48, i)
                }
            }
        }
        c.set(null);
        c.set(u);
        m.popModelMatrix()
    };

    function x(n) {
        let i = 0,
            s = 0;
        let r = 0;
        for (let t = 0; t < f[n].l.length; t++) {
            for (let e = 0; e < f[n].l[t].length; e += 2) {
                i += f[n].l[t][e];
                s += f[n].l[t][e + 1];
                r++
            }
        }
        i /= r;
        s /= r;
        return [i, s]
    }

    function y(n) {
        let i = 9999999;
        for (let t = 0; t < f[n].l.length; t++) {
            for (let e = 0; e < f[n].l[t].length; e += 2) {
                i = Math.min(i, f[n].l[t][e])
            }
        }
        return i
    }

    function C(n) {
        let i = 9999999;
        let s = -9999999;
        for (let t = 0; t < f[n].l.length; t++) {
            for (let e = 0; e < f[n].l[t].length; e += 2) {
                i = Math.min(i, f[n].l[t][e]);
                s = Math.max(s, f[n].l[t][e])
            }
        }
        return s - i
    }
    r.length = 0;
    let S = [];
    let A = x(0);
    let w = x(1);
    S = [(A[0] + w[0]) / 2, (A[1] + w[1]) / 2];
    for (let o = 0; o < f.length; o++) {
        f[o].w = C(o) * .002;
        f[o].m = [];
        let a = [];
        for (let r = 0; r < f[o].l.length; r++) {
            let t = 0;
            let n = [];
            let i = [];
            for (let e = 0; e < f[o].l[r].length - 2; e += 2) {
                a.push((f[o].l[r][e] - y(o)) * .005, (f[o].l[r][e + 1] - S[1]) * -.005, 0);
                a.push((f[o].l[r][e + 2] - y(o)) * .005, (f[o].l[r][e + 3] - S[1]) * -.005, 0)
            }
            for (let e = 0; e < f[o].l[r].length; e += 2) {
                i.push((f[o].l[r][e] - y(o)) * .005);
                i.push((f[o].l[r][e + 1] - S[1]) * -.005);
                i.push(0);
                n.push(t);
                t++
            }
            f[o].linesArr = a;
            let e = new CGL.Geometry(l.name);
            e.vertices = i;
            e.verticesIndices = n;
            let s = new CGL.Mesh(l.patch.cgl, e);
            f[o].m.push(s)
        }
        c.set([]);
        f[o].w += .1
    }
};
Ops.Gl.LineFont_v2.prototype = new CABLES.Op;
CABLES.OPS["a3615010-05af-45bc-bf98-6972c2de21bc"] = {
    f: Ops.Gl.LineFont_v2,
    objName: "Ops.Gl.LineFont_v2"
};
Ops.Gl.Textures.WebcamTexture_v3 = function() {
    CABLES.Op.apply(this, arguments);
    const t = this;
    const R = {
        texcopy_frag: "UNI sampler2D tex;\nIN vec2 texCoord;\n\n\nvoid main()\n{\n    vec2 tc=vec2(texCoord.x,texCoord.y);\n\n    #ifdef FLIPX\n        tc.x=1.0-texCoord.x;\n    #endif\n    #ifdef FLIPY\n        tc.y=1.0-texCoord.y;\n    #endif\n    outColor=texture(tex,tc);\n}"
    };
    const j = t.inTrigger("Render"),
        n = t.inBool("Active", true),
        r = t.inValueBool("Generate Texture", true),
        a = t.inDropDown("Webcam Input", ["Default"], "Default"),
        o = t.inValueInt("Requested Width", 1280),
        l = t.inValueInt("Requested Height", 720),
        e = t.inValueBool("Flip X", false),
        i = t.inValueBool("Flip Y", false),
        s = t.inValueBool("Show HTML Element", false),
        h = t.inStringEditor("CSS", "z-index:99999;\nposition:absolute;\n", "inline-css"),
        c = t.inValueBool("Element Flip X", false),
        u = t.inValueBool("Element Flip Y", false),
        V = t.outTrigger("Next"),
        d = t.outTexture("Texture"),
        P = t.outNumber("Ratio"),
        g = t.outBoolNum("Available"),
        D = t.outNumber("Size Width"),
        U = t.outNumber("Size Height"),
        m = t.outString("Error"),
        G = t.outObject("HTML Element", null, "element"),
        F = t.outArray("Available devices"),
        z = t.outString("Active device"),
        $ = t.outTrigger("Texture updated");
    t.setPortGroup("Camera", [a, o, l]);
    t.setPortGroup("Texture", [e, i]);
    t.setPortGroup("Video Element", [s, h, c, u]);
    let f = 0;
    const p = t.patch.cgl;
    const H = CGL.Texture.getEmptyTexture(p);
    const b = document.createElement("video");
    const W = "webcam" + t.id;
    b.setAttribute("id", W);
    b.setAttribute("autoplay", "");
    b.setAttribute("muted", "");
    b.setAttribute("playsinline", "");
    b.setAttribute("style", h.get());
    t.patch.cgl.canvas.parentElement.appendChild(b);
    let _ = null;
    let v = false;
    let x = false;
    let y = false;
    let C = false;
    let S = null;
    let A = null;
    let w = null;
    let I = false;
    let X = false;
    let Y = null;
    let T = null;
    d.set(H);
    e.onChange = i.onChange = O;
    a.onChange = o.onChange = l.onChange = B;
    c.onChange = u.onChange = J;
    t.onDelete = q;
    s.onChange = h.onChange = L;
    Z();
    L();
    t.on("loadedValueSet", E);
    n.onChange = E;

    function E() {
        setTimeout(() => {
            if (n.get()) te()
        }, 50)
    }

    function O() {
        if (!T) T = new CGL.CopyTexture(p, "webcamFlippedTexture", {
            shader: R.texcopy_frag
        });
        T.bgShader.toggleDefine("FLIPX", e.get());
        T.bgShader.toggleDefine("FLIPY", !i.get())
    }

    function Z() {
        if (_) _.delete();
        _ = new CGL.Texture(p, {
            name: "webcam"
        });
        if (b) _.setSize(b.videoWidth, b.videoHeight)
    }

    function q() {
        if (b) b.remove()
    }

    function L() {
        if (!s.get()) b.setAttribute("style", "display:none;");
        else b.setAttribute("style", h.get());
        h.setUiAttribs({
            greyout: !s.get()
        });
        c.setUiAttribs({
            greyout: !s.get()
        });
        u.setUiAttribs({
            greyout: !s.get()
        })
    }

    function J() {
        if (c.get() && !u.get()) b.style.transform = "scaleX(-1)";
        else if (!c.get() && u.get()) b.style.transform = "scaleY(-1)";
        else if (c.get() && u.get()) b.style.transform = "scale(-1, -1)";
        else b.style.transform = "unset"
    }

    function M(e) {
        if (y && C) {
            if (e) {
                I = true;
                b.play()
            } else {
                I = false;
                b.pause()
            }
        }
    }
    r.onChange = () => {
        M(r.get())
    };

    function Q() {
        p.gl.bindTexture(p.gl.TEXTURE_2D, _.tex);
        p.gl.texImage2D(p.gl.TEXTURE_2D, 0, p.gl.RGBA, p.gl.RGBA, p.gl.UNSIGNED_BYTE, b);
        p.gl.bindTexture(p.gl.TEXTURE_2D, null);
        if (!T) O();
        if (T) d.setRef(T.copy(_))
    }

    function K() {
        if (!A) return;
        M(false);
        g.set(false);
        A.getTracks().forEach(e => {
            e.stop()
        });
        A = null
    }

    function N(s) {
        A = s;
        b.srcObject = s;
        b.onloadedmetadata = e => {
            z.set(s.getTracks()[0].label);
            if (a.get() != "Default" && s.getTracks()[0].label != a.get() && f < 3) {
                f++;
                return B()
            }
            const t = s.getTracks()[0].getSettings();
            x = false;
            const n = t.width || o.get();
            const i = t.height || l.get();
            U.set(i);
            D.set(n);
            P.set(t.aspectRatio || n / i);
            m.set("");
            b.setAttribute("width", t.width);
            b.setAttribute("height", t.height);
            G.set(b);
            _.setSize(n, i);
            g.set(true);
            M(r.get())
        }
    }

    function ee() {
        const e = k();
        const t = e.video.width == b.videoWidth && e.video.height == b.videoHeight;
        return t
    }

    function k() {
        let n = {
            audio: false,
            video: {}
        };
        if (C) {
            let t = a.get();
            let e = null;
            if (!t || t === "Default" || t === "...") {
                e = Object.values(w)[0]
            } else {
                e = w.filter(e => {
                    return e.label === t
                });
                if (e) {
                    e = e[0]
                } else {
                    e = Object.values(w)[t]
                }
                if (!e) {
                    e = Object.values(w)[0]
                }
            }
            n.video = {
                deviceId: {
                    exact: e.deviceId
                }
            }
        }
        const e = o.get();
        const t = l.get();
        let i = {
            min: 640
        };
        let s = {
            min: 480
        };
        if (e) i.ideal = e;
        if (t) s.ideal = t;
        n.video.width = i;
        n.video.height = s;
        return n
    }

    function B() {
        if (!n.get()) return;
        K();
        x = true;
        const e = k();
        navigator.getUserMedia = navigator.getUserMedia || navigator.webkitGetUserMedia;
        if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {
            navigator.mediaDevices.getUserMedia(e).then(N).catch(e => {
                x = false;
                t.logError(e.name + ": " + e.message, e);
                m.set(e.name + ": " + e.message)
            })
        } else if (navigator.getUserMedia) {
            x = false;
            navigator.getUserMedia(e, N, () => {
                return g.set(false)
            })
        }
    }

    function te() {
        if (!n.get()) return;
        v = true;
        S = p.patch.loading.start("Webcam inputs", "", t);
        const e = k();
        navigator.mediaDevices.getUserMedia(e).then(e => {
            return navigator.mediaDevices.enumerateDevices()
        }).then(e => {
            w = e.filter(e => {
                return e.kind === "videoinput"
            });
            v = false;
            a.uiAttribs.values = w.map((e, t) => {
                return e.label || t
            });
            a.uiAttribs.values.unshift("Default");
            F.set(a.uiAttribs.values);
            p.patch.loading.finished(S);
            C = true;
            B();
            y = true
        }).catch(e => {
            v = false;
            t.error("error", e);
            m.set(e.name + ": " + e.message);
            p.patch.loading.finished(S);
            C = false
        })
    }
    j.onTriggered = () => {
        if (!v && n.get()) {
            if (y && C && I) {
                Q();
                $.trigger()
            }
            if (!y && C) {
                B()
            }
        }
        V.trigger()
    }
};
Ops.Gl.Textures.WebcamTexture_v3.prototype = new CABLES.Op;
CABLES.OPS["71c0468d-e942-4574-a91d-b3d7271922d0"] = {
    f: Ops.Gl.Textures.WebcamTexture_v3,
    objName: "Ops.Gl.Textures.WebcamTexture_v3"
};
Ops.Gl.TextureEffects.ImageCompose_v4 = function() {
    CABLES.Op.apply(this, arguments);
    const n = this;
    const e = {
        imgcomp_frag: "IN vec2 texCoord;\nUNI vec4 bgColor;\nUNI sampler2D tex;\n#ifdef USE_UVTEX\nUNI sampler2D UVTex;\n#endif\n\nvoid main()\n{\n\n    #ifndef USE_TEX\n        outColor=bgColor;\n    #endif\n    #ifdef USE_TEX\n        #ifndef USE_UVTEX\n        outColor=texture(tex,texCoord);\n        #else\n        outColor=texture(tex,texture(UVTex,texCoord).xy);\n        #endif\n    #endif\n\n\n\n}\n"
    };
    const t = n.patch.cgl,
        i = n.inTrigger("Render"),
        s = n.inTexture("Base Texture"),
        r = n.inTexture("UV Texture"),
        a = n.inSwitch("Size", ["Auto", "Canvas", "Manual"], "Auto"),
        o = n.inValueInt("Width", 640),
        l = n.inValueInt("Height", 480),
        h = n.inSwitch("Filter", ["nearest", "linear", "mipmap"], "linear"),
        c = n.inValueSelect("Wrap", ["clamp to edge", "repeat", "mirrored repeat"], "repeat"),
        u = n.inDropDown("Pixel Format", CGL.Texture.PIXELFORMATS, CGL.Texture.PFORMATSTR_RGBA8UB),
        d = n.inValueSlider("R", 0),
        g = n.inValueSlider("G", 0),
        m = n.inValueSlider("B", 0),
        f = n.inValueSlider("A", 0),
        p = n.outTrigger("Next"),
        b = n.outTexture("texture_out", CGL.Texture.getEmptyTexture(t)),
        _ = n.outNumber("Aspect Ratio"),
        v = n.outNumber("Texture Width"),
        x = n.outNumber("Texture Height");
    n.setPortGroup("Texture Size", [a, o, l]);
    n.setPortGroup("Texture Parameters", [c, h, u]);
    d.setUiAttribs({
        colorPick: true
    });
    n.setPortGroup("Color", [d, g, m, f]);
    n.toWorkPortsNeedToBeLinked(i);
    const R = [0, 0, 0, 0];
    let y = null;
    let C = null;
    let S = true;
    let j = false;
    let A = null;
    let V = null;
    let P = null;
    let D = null;
    c.onChange = h.onChange = u.onChange = U;
    s.onLinkChanged = a.onChange = r.onChange = N;
    i.onTriggered = n.preRender = B;
    N();

    function w() {
        if (y) y.delete();
        if (C) C.delete();
        y = new CGL.TextureEffect(t, {
            isFloatingPointTexture: CGL.Texture.isPixelFormatFloat(u.get())
        });
        C = new CGL.Texture(t, {
            name: "image_compose_v2_" + n.id,
            isFloatingPointTexture: CGL.Texture.isPixelFormatFloat(u.get()),
            pixelFormat: u.get(),
            filter: I(),
            wrap: T(),
            width: E(),
            height: O()
        });
        y.setSourceTexture(C);
        v.set(E());
        x.set(O());
        _.set(E() / O());
        b.set(CGL.Texture.getEmptyTexture(t));
        S = false;
        N()
    }

    function I() {
        if (h.get() == "nearest") return CGL.Texture.FILTER_NEAREST;
        else if (h.get() == "linear") return CGL.Texture.FILTER_LINEAR;
        else if (h.get() == "mipmap") return CGL.Texture.FILTER_MIPMAP
    }

    function T() {
        if (c.get() == "repeat") return CGL.Texture.WRAP_REPEAT;
        else if (c.get() == "mirrored repeat") return CGL.Texture.WRAP_MIRRORED_REPEAT;
        else if (c.get() == "clamp to edge") return CGL.Texture.WRAP_CLAMP_TO_EDGE
    }

    function E() {
        if (s.get() && a.get() == "Auto") return s.get().width;
        else if (a.get() == "Auto" || a.get() == "Canvas") return t.canvasWidth;
        else if (a.get() == "ViewPort") return t.getViewPort()[2];
        return Math.ceil(o.get())
    }

    function O() {
        if (s.get() && a.get() == "Auto") return s.get().height;
        else if (a.get() == "Auto" || a.get() == "Canvas") return t.canvasHeight;
        else if (a.get() == "ViewPort") return t.getViewPort()[3];
        else return Math.ceil(l.get())
    }

    function U() {
        S = true
    }

    function G() {
        if ((E() != C.width || O() != C.height || C.isFloatingPoint() != CGL.Texture.isPixelFormatFloat(u.get()) || C.pixelFormat != u.get() || C.filter != I() || C.wrap != T()) && (E() !== 0 && O() !== 0)) {
            w();
            y.setSourceTexture(C);
            b.set(CGL.Texture.getEmptyTexture(t));
            b.set(C);
            L();
            k()
        }
    }

    function L() {
        let e = null;
        if (a.get() == "Manual") {
            e = null
        } else if (a.get() == "Auto") {
            if (s.get()) e = "Input Texture";
            else e = "Canvas Size";
            e += ": " + E() + " x " + O()
        }
        let t = false;
        t = a.uiAttribs.info != e;
        a.setUiAttribs({
            info: e
        });
        if (t) n.refreshParams()
    }

    function M() {
        if (A) A.toggleDefine("USE_TEX", s.isLinked());
        if (A) A.toggleDefine("USE_UVTEX", r.isLinked())
    }

    function N() {
        d.setUiAttribs({
            greyout: s.isLinked()
        });
        m.setUiAttribs({
            greyout: s.isLinked()
        });
        g.setUiAttribs({
            greyout: s.isLinked()
        });
        f.setUiAttribs({
            greyout: s.isLinked()
        });
        o.setUiAttribs({
            greyout: a.get() == "Auto"
        });
        l.setUiAttribs({
            greyout: a.get() == "Auto"
        });
        o.setUiAttribs({
            hideParam: a.get() != "Manual"
        });
        l.setUiAttribs({
            hideParam: a.get() != "Manual"
        });
        if (C)
            if (CGL.Texture.isPixelFormatFloat(u.get()) && I() == CGL.Texture.FILTER_MIPMAP) n.setUiError("fpmipmap", "Don't use mipmap and 32bit at the same time, many systems do not support this.");
            else n.setUiError("fpmipmap", null);
        L();
        M();
        k()
    }

    function k() {
        if (C)
            if (s.isLinked() && s.get() && C.textureType != s.get().textureType && (C.textureType != CGL.Texture.TYPE_FLOAT || s.get().textureType == CGL.Texture.TYPE_FLOAT)) n.setUiError("textypediff", "Drawing 32bit texture into an 8 bit can result in data/precision loss", 1);
            else n.setUiError("textypediff", null)
    }
    n.preRender = () => {
        B()
    };

    function F() {
        if (!A) {
            A = new CGL.Shader(t, "copytextureshader");
            A.setSource(A.getDefaultVertexShader(), e.imgcomp_frag);
            V = new CGL.Uniform(A, "t", "tex", 0);
            P = new CGL.Uniform(A, "t", "UVTex", 1);
            D = new CGL.Uniform(A, "4f", "bgColor", d, g, m, f);
            M()
        }
        t.pushShader(A);
        t.currentTextureEffect.bind();
        if (s.get()) t.setTexture(0, s.get().tex);
        if (r.get()) t.setTexture(1, r.get().tex);
        t.currentTextureEffect.finish();
        t.popShader()
    }

    function B() {
        if (!y || S) w();
        t.pushBlend(false);
        G();
        const e = t.currentTextureEffect;
        t.currentTextureEffect = y;
        t.currentTextureEffect.imgCompVer = 3;
        t.currentTextureEffect.width = o.get();
        t.currentTextureEffect.height = l.get();
        y.setSourceTexture(C);
        y.startEffect(s.get() || CGL.Texture.getEmptyTexture(t, j), true);
        F();
        p.trigger();
        t.pushViewPort(0, 0, o.get(), l.get());
        b.setRef(y.getCurrentSourceTexture());
        y.endEffect();
        t.popViewPort();
        t.popBlend(false);
        t.currentTextureEffect = e
    }
};
Ops.Gl.TextureEffects.ImageCompose_v4.prototype = new CABLES.Op;
CABLES.OPS["17212e2b-d692-464c-8f8d-2d511dd3410a"] = {
    f: Ops.Gl.TextureEffects.ImageCompose_v4,
    objName: "Ops.Gl.TextureEffects.ImageCompose_v4"
};
Ops.Gl.TextureEffects.Kaleidoscope_v2 = function() {
    CABLES.Op.apply(this, arguments);
    const e = this;
    const t = {
        kaleidoscope_frag: "IN vec2 texCoord;\nUNI sampler2D tex;\n\nUNI float sides;\nUNI float angle;\nUNI float amount;\n\nUNI float slidex;\nUNI float slidey;\nUNI float centerX;\nUNI float centerY;\nUNI float aspect;\n\nconst float tau = 6.28318530718;\n\n{{CGL.BLENDMODES3}}\n\nvoid main()\n{\n    vec2 center=vec2(centerX,centerY/aspect);\n\n\tvec2 loc = texCoord;\n\tloc.y/=aspect;\n\n\tfloat r = distance(center, loc);\n\tfloat a = atan ((loc.y-center.y),(loc.x-center.x));\n\n\t// kaleidoscope\n\ta = mod(a, tau/sides);\n\ta = abs(a - tau/sides/2.);\n\n\tloc.x = r * cos(a + tau * angle);\n\tloc.y = r * sin(a + tau * angle);\n\n\tloc = (center + loc) *2.1;\n\n\tloc.x = mod(loc.x + slidex, 1.0);\n\tloc.y = mod(loc.y + slidey, 1.0);\n\n\tif(loc.x < 0.0)loc.x = mod(abs(loc.x),1.0);\n\tif(loc.y < 0.0)loc.y = mod(abs(loc.y),1.0);\n\n\tif(loc.x > 1.0) loc.x = mod(abs(1.0-loc.x),1.0);\n\tif(loc.y > 1.0) loc.y = mod(abs(1.0-loc.y),1.0);\n\n\tvec4 col=texture(tex,loc);\n\tvec4 base=texture(tex,texCoord);\n\tbase.a=0.0;\n    outColor= cgl_blendPixel(base,col,amount);\n\n}\n"
    };
    const n = e.inTrigger("Render"),
        i = CGL.TextureEffect.AddBlendSelect(e, "Blend Mode", "normal"),
        s = e.inValueSlider("Amount", 1),
        r = e.inValue("Sides", 10),
        a = e.inValueSlider("Angle", 0),
        o = e.inValueSlider("Slide X", 0),
        l = e.inValueSlider("Slide Y", 0),
        h = e.inValueSlider("Center X", .5),
        c = e.inValueSlider("Center Y", .5),
        u = e.inBool("Aspect Ratio", true),
        d = e.outTrigger("Next");
    let g = e.patch.cgl;
    let m = new CGL.Shader(g, e.name);
    const f = new CGL.Uniform(m, "f", "sides", r),
        p = new CGL.Uniform(m, "f", "angle", a),
        b = new CGL.Uniform(m, "f", "slidex", o),
        _ = new CGL.Uniform(m, "f", "slidey", l),
        v = new CGL.Uniform(m, "f", "centerX", h),
        x = new CGL.Uniform(m, "f", "centerY", c),
        y = new CGL.Uniform(m, "f", "amount", s),
        C = new CGL.Uniform(m, "f", "aspect", 1);
    CGL.TextureEffect.setupBlending(e, m, i, s);
    m.setSource(m.getDefaultVertexShader(), t.kaleidoscope_frag);
    let S = new CGL.Uniform(m, "t", "tex", 0);
    n.onTriggered = function() {
        if (!CGL.TextureEffect.checkOpInEffect(e, 3)) return;
        g.pushShader(m);
        g.currentTextureEffect.bind();
        g.setTexture(0, g.currentTextureEffect.getCurrentSourceTexture().tex);
        if (u.get()) C.setValue(g.currentTextureEffect.aspectRatio);
        else C.setValue(1);
        g.currentTextureEffect.finish();
        g.popShader();
        d.trigger()
    }
};
Ops.Gl.TextureEffects.Kaleidoscope_v2.prototype = new CABLES.Op;
CABLES.OPS["3c900fc2-8508-4531-a365-43224f7751c8"] = {
    f: Ops.Gl.TextureEffects.Kaleidoscope_v2,
    objName: "Ops.Gl.TextureEffects.Kaleidoscope_v2"
};
Ops.Gl.Meshes.Rectangle_v4 = function() {
    CABLES.Op.apply(this, arguments);
    const e = this;
    const t = {};
    const n = e.inTrigger("render"),
        i = e.inValueBool("Render Mesh", true),
        T = e.inValue("width", 1),
        E = e.inValue("height", 1),
        O = e.inSwitch("pivot x", ["left", "center", "right"], "center"),
        L = e.inSwitch("pivot y", ["top", "center", "bottom"], "center"),
        M = e.inSwitch("axis", ["xy", "xz"], "xy"),
        N = e.inBool("Flip TexCoord X", false),
        k = e.inBool("Flip TexCoord Y", true),
        B = e.inValueInt("num columns", 1),
        R = e.inValueInt("num rows", 1),
        s = e.outTrigger("trigger"),
        j = e.outObject("geometry", null, "geometry");
    j.ignoreValueSerialize = true;
    const r = e.patch.cgl;
    const V = new CGL.Geometry("rectangle");
    i.setUiAttribs({
        title: "Render"
    });
    n.setUiAttribs({
        title: "Trigger"
    });
    s.setUiAttribs({
        title: "Next"
    });
    e.setPortGroup("Pivot", [O, L, M]);
    e.setPortGroup("Size", [T, E]);
    e.setPortGroup("Structure", [B, R]);
    e.toWorkPortsNeedToBeLinked(n);
    e.toWorkShouldNotBeChild("Ops.Gl.TextureEffects.ImageCompose", CABLES.OP_PORT_TYPE_TRIGGER);
    const P = 0;
    const D = 1;
    let U = P;
    let G = null;
    let F = true;
    let z = true;
    const a = vec3.create();
    vec3.set(a, 1, 1, 1);
    M.onChange = O.onChange = L.onChange = N.onChange = k.onChange = R.onChange = B.onChange = o;
    $();
    T.onChange = E.onChange = () => {
        if (z) $();
        else F = true
    };

    function $() {
        if (U === P) vec3.set(a, T.get(), E.get(), 1);
        if (U === D) vec3.set(a, T.get(), 1, E.get())
    }
    j.onLinkChanged = () => {
        z = !j.isLinked();
        $();
        F = true
    };

    function o() {
        F = true
    }
    n.onTriggered = () => {
        if (F) l();
        if (G && i.get()) {
            if (z) {
                r.pushModelMatrix();
                mat4.scale(r.mMatrix, r.mMatrix, a)
            }
            G.render(e.patch.cgl.getShader());
            if (z) r.popModelMatrix()
        }
        s.trigger()
    };
    e.onDelete = () => {
        if (G) G.dispose();
        o()
    };

    function l() {
        if (M.get() == "xy") U = P;
        if (M.get() == "xz") U = D;
        $();
        let n = T.get();
        let i = E.get();
        if (z) n = i = 1;
        let s = 0;
        let r = 0;
        if (O.get() == "center") s = 0;
        else if (O.get() == "right") s = -n / 2;
        else if (O.get() == "left") s = +n / 2;
        if (L.get() == "center") r = 0;
        else if (L.get() == "top") r = -i / 2;
        else if (L.get() == "bottom") r = +i / 2;
        const a = Math.max(1, Math.round(R.get()));
        const o = Math.max(1, Math.round(B.get()));
        const l = n / o;
        const h = i / a;
        const c = [];
        const u = new Float32Array((o + 1) * (a + 1) * 2);
        const d = new Float32Array((o + 1) * (a + 1) * 3);
        const g = new Float32Array((o + 1) * (a + 1) * 3);
        const m = new Float32Array((o + 1) * (a + 1) * 3);
        const f = new Float32Array((o + 1) * (a + 1) * 3);
        let p = 0;
        let b = 0;
        let _ = 0;
        let v = 0;
        let x = 0;
        for (let t = 0; t <= a; t++) {
            for (let e = 0; e <= o; e++) {
                d[b++] = e * l - n / 2 + s;
                if (U == D) d[b++] = 0;
                d[b++] = t * h - i / 2 + r;
                if (U == P) d[b++] = 0;
                u[p++] = e / o;
                u[p++] = t / a;
                if (U == P) {
                    g[_++] = 0;
                    g[_++] = 0;
                    g[_++] = 1;
                    m[v++] = 1;
                    m[v++] = 0;
                    m[v++] = 0;
                    f[x++] = 0;
                    f[x++] = 1;
                    f[x++] = 0
                } else if (U == D) {
                    g[_++] = 0;
                    g[_++] = 1;
                    g[_++] = 0;
                    f[x++] = 0;
                    f[x++] = 0;
                    f[x++] = 1
                }
            }
        }
        c.length = o * a * 6;
        let y = 0;
        for (let t = 0; t < o; t++) {
            for (let e = 0; e < a; e++) {
                const C = t + (o + 1) * e;
                const S = C;
                const A = C + 1;
                const w = C + o + 1;
                const I = C + 1 + o + 1;
                if (U == P) {
                    c[y++] = S;
                    c[y++] = A;
                    c[y++] = w;
                    c[y++] = w;
                    c[y++] = A;
                    c[y++] = I
                } else if (U == D) {
                    c[y++] = S;
                    c[y++] = w;
                    c[y++] = A;
                    c[y++] = A;
                    c[y++] = w;
                    c[y++] = I
                }
            }
        }
        if (k.get())
            for (let e = 0; e < u.length; e += 2) u[e + 1] = 1 - u[e + 1];
        if (N.get())
            for (let e = 0; e < u.length; e += 2) u[e] = 1 - u[e];
        V.clear();
        V.vertices = d;
        V.texCoords = u;
        V.verticesIndices = c;
        V.vertexNormals = g;
        V.tangents = m;
        V.biTangents = f;
        if (!G) G = e.patch.cg.createMesh(V);
        else G.setGeom(V);
        j.setRef(V);
        F = false
    }
};
Ops.Gl.Meshes.Rectangle_v4.prototype = new CABLES.Op;
CABLES.OPS["cc8c3ede-7103-410b-849f-a645793cab39"] = {
    f: Ops.Gl.Meshes.Rectangle_v4,
    objName: "Ops.Gl.Meshes.Rectangle_v4"
};
Ops.Gl.Shader.BasicMaterial_v3 = function() {
    CABLES.Op.apply(this, arguments);
    const e = this;
    const t = {
        basicmaterial_frag: "{{MODULES_HEAD}}\n\nIN vec2 texCoord;\n\n#ifdef VERTEX_COLORS\nIN vec4 vertCol;\n#endif\n\n#ifdef HAS_TEXTURES\n    IN vec2 texCoordOrig;\n    #ifdef HAS_TEXTURE_DIFFUSE\n        UNI sampler2D tex;\n    #endif\n    #ifdef HAS_TEXTURE_OPACITY\n        UNI sampler2D texOpacity;\n   #endif\n#endif\n\n\n\nvoid main()\n{\n    {{MODULE_BEGIN_FRAG}}\n    vec4 col=color;\n\n\n    #ifdef HAS_TEXTURES\n        vec2 uv=texCoord;\n\n        #ifdef CROP_TEXCOORDS\n            if(uv.x<0.0 || uv.x>1.0 || uv.y<0.0 || uv.y>1.0) discard;\n        #endif\n\n        #ifdef HAS_TEXTURE_DIFFUSE\n            col=texture(tex,uv);\n\n            #ifdef COLORIZE_TEXTURE\n                col.r*=color.r;\n                col.g*=color.g;\n                col.b*=color.b;\n            #endif\n        #endif\n        col.a*=color.a;\n        #ifdef HAS_TEXTURE_OPACITY\n            #ifdef TRANSFORMALPHATEXCOORDS\n                uv=texCoordOrig;\n            #endif\n            #ifdef ALPHA_MASK_IALPHA\n                col.a*=1.0-texture(texOpacity,uv).a;\n            #endif\n            #ifdef ALPHA_MASK_ALPHA\n                col.a*=texture(texOpacity,uv).a;\n            #endif\n            #ifdef ALPHA_MASK_LUMI\n                col.a*=dot(vec3(0.2126,0.7152,0.0722), texture(texOpacity,uv).rgb);\n            #endif\n            #ifdef ALPHA_MASK_R\n                col.a*=texture(texOpacity,uv).r;\n            #endif\n            #ifdef ALPHA_MASK_G\n                col.a*=texture(texOpacity,uv).g;\n            #endif\n            #ifdef ALPHA_MASK_B\n                col.a*=texture(texOpacity,uv).b;\n            #endif\n            // #endif\n        #endif\n    #endif\n\n    {{MODULE_COLOR}}\n\n    #ifdef DISCARDTRANS\n        if(col.a<0.2) discard;\n    #endif\n\n    #ifdef VERTEX_COLORS\n        col*=vertCol;\n    #endif\n\n    outColor = col;\n}\n",
        basicmaterial_vert: "\n{{MODULES_HEAD}}\n\nOUT vec2 texCoord;\nOUT vec2 texCoordOrig;\n\nUNI mat4 projMatrix;\nUNI mat4 modelMatrix;\nUNI mat4 viewMatrix;\n\n#ifdef HAS_TEXTURES\n    UNI float diffuseRepeatX;\n    UNI float diffuseRepeatY;\n    UNI float texOffsetX;\n    UNI float texOffsetY;\n#endif\n\n#ifdef VERTEX_COLORS\n    in vec4 attrVertColor;\n    out vec4 vertCol;\n\n#endif\n\n\nvoid main()\n{\n    mat4 mMatrix=modelMatrix;\n    mat4 mvMatrix;\n\n    norm=attrVertNormal;\n    texCoordOrig=attrTexCoord;\n    texCoord=attrTexCoord;\n    #ifdef HAS_TEXTURES\n        texCoord.x=texCoord.x*diffuseRepeatX+texOffsetX;\n        texCoord.y=(1.0-texCoord.y)*diffuseRepeatY+texOffsetY;\n    #endif\n\n    #ifdef VERTEX_COLORS\n        vertCol=attrVertColor;\n    #endif\n\n    vec4 pos = vec4(vPosition, 1.0);\n\n    #ifdef BILLBOARD\n       vec3 position=vPosition;\n       mvMatrix=viewMatrix*modelMatrix;\n\n       gl_Position = projMatrix * mvMatrix * vec4((\n           position.x * vec3(\n               mvMatrix[0][0],\n               mvMatrix[1][0],\n               mvMatrix[2][0] ) +\n           position.y * vec3(\n               mvMatrix[0][1],\n               mvMatrix[1][1],\n               mvMatrix[2][1]) ), 1.0);\n    #endif\n\n    {{MODULE_VERTEX_POSITION}}\n\n    #ifndef BILLBOARD\n        mvMatrix=viewMatrix * mMatrix;\n    #endif\n\n\n    #ifndef BILLBOARD\n        // gl_Position = projMatrix * viewMatrix * modelMatrix * pos;\n        gl_Position = projMatrix * mvMatrix * pos;\n    #endif\n}\n"
    };
    const n = e.inTrigger("render");
    const i = e.outTrigger("trigger");
    const s = e.outObject("shader", null, "shader");
    s.ignoreValueSerialize = true;
    e.toWorkPortsNeedToBeLinked(n);
    e.toWorkShouldNotBeChild("Ops.Gl.TextureEffects.ImageCompose", CABLES.OP_PORT_TYPE_FUNCTION);
    const r = e.patch.cgl;
    const a = new CGL.Shader(r, "basicmaterialnew");
    a.addAttribute({
        type: "vec3",
        name: "vPosition"
    });
    a.addAttribute({
        type: "vec2",
        name: "attrTexCoord"
    });
    a.addAttribute({
        type: "vec3",
        name: "attrVertNormal",
        nameFrag: "norm"
    });
    a.addAttribute({
        type: "float",
        name: "attrVertIndex"
    });
    a.setModules(["MODULE_VERTEX_POSITION", "MODULE_COLOR", "MODULE_BEGIN_FRAG"]);
    a.setSource(t.basicmaterial_vert, t.basicmaterial_frag);
    s.setRef(a);
    n.onTriggered = T;
    const o = e.inValueSlider("r", Math.random());
    const l = e.inValueSlider("g", Math.random());
    const h = e.inValueSlider("b", Math.random());
    const c = e.inValueSlider("a", 1);
    o.setUiAttribs({
        colorPick: true
    });
    const u = a.addUniformFrag("4f", "color", o, l, h, c);
    a.uniformColorDiffuse = u;
    const d = e.inTexture("texture");
    let g = null;
    d.onChange = O;
    const m = e.inValueBool("colorizeTexture", false);
    const f = e.inValueBool("Vertex Colors", false);
    const p = e.inTexture("textureOpacity");
    let b = null;
    const _ = e.inSwitch("Alpha Mask Source", ["Luminance", "R", "G", "B", "A", "1-A"], "Luminance");
    _.setUiAttribs({
        greyout: true
    });
    p.onChange = E;
    const v = e.inValueBool("Opacity TexCoords Transform", false);
    const x = e.inValueBool("Discard Transparent Pixels");
    const y = e.inValue("diffuseRepeatX", 1),
        C = e.inValue("diffuseRepeatY", 1),
        S = e.inValue("Tex Offset X", 0),
        A = e.inValue("Tex Offset Y", 0),
        w = e.inBool("Crop TexCoords", false);
    a.addUniformFrag("f", "diffuseRepeatX", y);
    a.addUniformFrag("f", "diffuseRepeatY", C);
    a.addUniformFrag("f", "texOffsetX", S);
    a.addUniformFrag("f", "texOffsetY", A);
    const I = e.inValueBool("billboard", false);
    _.onChange = I.onChange = x.onChange = v.onChange = w.onChange = f.onChange = m.onChange = L;
    e.setPortGroup("Color", [o, l, h, c]);
    e.setPortGroup("Color Texture", [d, f, m]);
    e.setPortGroup("Opacity", [p, _, x, v]);
    e.setPortGroup("Texture Transform", [y, C, S, A, w]);
    E();
    O();
    e.preRender = function() {
        a.bind();
        T()
    };

    function T() {
        if (!a) return;
        r.pushShader(a);
        a.popTextures();
        if (g && d.get()) a.pushTexture(g, d.get());
        if (b && p.get()) a.pushTexture(b, p.get());
        i.trigger();
        r.popShader()
    }

    function E() {
        if (p.get()) {
            if (b !== null) return;
            a.removeUniform("texOpacity");
            a.define("HAS_TEXTURE_OPACITY");
            if (!b) b = new CGL.Uniform(a, "t", "texOpacity");
            _.setUiAttribs({
                greyout: false
            });
            v.setUiAttribs({
                greyout: false
            })
        } else {
            a.removeUniform("texOpacity");
            a.removeDefine("HAS_TEXTURE_OPACITY");
            b = null;
            _.setUiAttribs({
                greyout: true
            });
            v.setUiAttribs({
                greyout: true
            })
        }
        L()
    }

    function O() {
        if (d.get()) {
            if (!a.hasDefine("HAS_TEXTURE_DIFFUSE")) a.define("HAS_TEXTURE_DIFFUSE");
            if (!g) g = new CGL.Uniform(a, "t", "texDiffuse");
            y.setUiAttribs({
                greyout: false
            });
            C.setUiAttribs({
                greyout: false
            });
            S.setUiAttribs({
                greyout: false
            });
            A.setUiAttribs({
                greyout: false
            });
            m.setUiAttribs({
                greyout: false
            })
        } else {
            a.removeUniform("texDiffuse");
            a.removeDefine("HAS_TEXTURE_DIFFUSE");
            g = null;
            y.setUiAttribs({
                greyout: true
            });
            C.setUiAttribs({
                greyout: true
            });
            S.setUiAttribs({
                greyout: true
            });
            A.setUiAttribs({
                greyout: true
            });
            m.setUiAttribs({
                greyout: true
            })
        }
    }

    function L() {
        a.toggleDefine("VERTEX_COLORS", f.get());
        a.toggleDefine("CROP_TEXCOORDS", w.get());
        a.toggleDefine("COLORIZE_TEXTURE", m.get());
        a.toggleDefine("TRANSFORMALPHATEXCOORDS", v.get());
        a.toggleDefine("DISCARDTRANS", x.get());
        a.toggleDefine("BILLBOARD", I.get());
        a.toggleDefine("ALPHA_MASK_ALPHA", _.get() == "A");
        a.toggleDefine("ALPHA_MASK_IALPHA", _.get() == "1-A");
        a.toggleDefine("ALPHA_MASK_LUMI", _.get() == "Luminance");
        a.toggleDefine("ALPHA_MASK_R", _.get() == "R");
        a.toggleDefine("ALPHA_MASK_G", _.get() == "G");
        a.toggleDefine("ALPHA_MASK_B", _.get() == "B")
    }
};
Ops.Gl.Shader.BasicMaterial_v3.prototype = new CABLES.Op;
CABLES.OPS["ec55d252-3843-41b1-b731-0482dbd9e72b"] = {
    f: Ops.Gl.Shader.BasicMaterial_v3,
    objName: "Ops.Gl.Shader.BasicMaterial_v3"
};
window.addEventListener("load", function(e) {
    CABLES.jsLoaded = new Event("CABLES.jsLoaded");
    document.dispatchEvent(CABLES.jsLoaded)
});
(function e(t, n) {
    if (typeof exports === "object" && typeof module === "object") module.exports = n();
    else if (typeof define === "function" && define.amd) define([], n);
    else if (typeof exports === "object") exports["ColorRick"] = n();
    else t["ColorRick"] = n()
})(self, function() {
    return (() => {
        var __webpack_modules__ = {
            "./index.js": (module, __unused_webpack_exports, __webpack_require__) => {
                eval('\n// window.chroma = require("chroma-js");\nconst chroma = __webpack_require__(/*! chroma-js */ "./node_modules/chroma-js/chroma.js");\n// import chroma from "chroma-js";\n\n\nclass ColorRick\n{\n    constructor(options)\n    {\n        this._elements=[];\n\n        this.options=options;\n\n        this._areaWidth=256;\n        this._areaHeight=150;\n\n        this._elContainer = document.createElement("div");\n        this._elContainer.classList.add("colorRick_dialog");\n        document.body.appendChild(this._elContainer);\n        this._elements.push(this._elContainer);\n\n        this._elContainer.style.setProperty(\'--width\', this._areaWidth + "px");\n        this._elContainer.style.setProperty(\'--height\', this._areaHeight + "px");\n\n\n        this._elArea = document.createElement("div");\n        this._elArea.classList.add("colorRick_area");\n        this._elContainer.appendChild(this._elArea);\n        this._elements.push(this._elArea);\n\n        this._elAreaCursor = document.createElement("div");\n        this._elAreaCursor.classList.add("colorRick_cursor");\n        this._elArea.appendChild(this._elAreaCursor);\n        this._elements.push(this._elAreaCursor);\n\n        this._elBrightness = document.createElement("div");\n        this._elBrightness.classList.add("colorRick_brightness");\n        this._elArea.appendChild(this._elBrightness);\n        this._elements.push(this._elBrightness);\n\n\n        this._elHue = document.createElement("div");\n        this._elHue.classList.add("colorRick_hue");\n        this._elContainer.appendChild(this._elHue);\n        this._elements.push(this._elHue);\n\n        this._elHueCursor = document.createElement("div");\n        this._elHueCursor.classList.add("colorRick_cursor_hue");\n        this._elHue.appendChild(this._elHueCursor);\n        this._elements.push(this._elHueCursor);\n\n        this._elColorBox = document.createElement("div");\n        this._elColorBox.classList.add("colorRick_preview");\n        this._elContainer.appendChild(this._elColorBox);\n        this._elements.push(this._elColorBox);\n\n        this._elColorBoxOrig = document.createElement("div");\n        this._elColorBoxOrig.classList.add("colorRick_preview");\n        this._elColorBoxOrig.classList.add("colorRick_preview_orig");\n        this._elContainer.appendChild(this._elColorBoxOrig);\n        this._elements.push(this._elColorBoxOrig);\n\n        this._elInputContainer = document.createElement("div");\n        this._elInputContainer.classList.add("colorRick_inputcontainer");\n        this._elContainer.appendChild(this._elInputContainer);\n        this._elements.push(this._elInputContainer);\n\n        const inputs=\n            "<table>"+\n                "<tr>"+\n                    "<td>"+\n                        "HEX"+\n                    "</td>"+\n                    "<td class=\\"right\\">"+\n                        "<input id=\\"colorRick_input_hex\\" class=\\"colorRick_input colorRick_input_hex\\" />"+\n                    "</td>"+\n                "</tr>"+\n                "<tr>"+\n                    "<td>"+\n                        "RGB"+\n                    "</td>"+\n                    "<td class=\\"right\\">"+\n                        "<input id=\\"colorRick_input_r\\" class=\\"colorRick_input colorRick_input_small\\" />"+\n                        "<input id=\\"colorRick_input_g\\" class=\\"colorRick_input colorRick_input_small\\" />"+\n                        "<input id=\\"colorRick_input_b\\" class=\\"colorRick_input colorRick_input_small\\" />"+\n                    "</td>"+\n                "</tr>"+\n                "<tr>"+\n                    "<td>"+\n                        "HSV"+\n                    "</td>"+\n                    "<td class=\\"right\\">"+\n                        "<input id=\\"colorRick_input_h\\" class=\\"colorRick_input colorRick_input_small\\" />"+\n                        "<input id=\\"colorRick_input_s\\" class=\\"colorRick_input colorRick_input_small\\" />"+\n                        "<input id=\\"colorRick_input_v\\" class=\\"colorRick_input colorRick_input_small\\" />"+\n                    "</td>"+\n                "</tr>"+\n            "</table>";\n\n\n        this._elInputContainer.innerHTML=inputs;\n\n        this._inputHex=document.getElementById("colorRick_input_hex");\n\n        this._inputR=document.getElementById("colorRick_input_r");\n        this._inputG=document.getElementById("colorRick_input_g");\n        this._inputB=document.getElementById("colorRick_input_b");\n\n        this._inputH=document.getElementById("colorRick_input_h");\n        this._inputS=document.getElementById("colorRick_input_s");\n        this._inputV=document.getElementById("colorRick_input_v");\n\n        this._elements.push(this._inputHex);\n        this._elements.push(this._inputR,this._inputG,this._inputB);\n        this._elements.push(this._inputH,this._inputS,this._inputV);\n        \n\n        this._color=chroma("white");\n\n\n        if(this.options.color)\n        {\n            this.setColor(this.options.color);\n        }\n\n        this._elColorBoxOrig.style.backgroundColor=this._color.hex();\n\n        this.updateColorField();\n\n\n\n        this._inputR.addEventListener("input",(e)=>\n        {\n            this._setColorFromRgbInputs();\n        });\n\n        this._inputG.addEventListener("input",(e)=>\n        {\n            this._setColorFromRgbInputs();\n        });\n\n        this._inputB.addEventListener("input",(e)=>\n        {\n            this._setColorFromRgbInputs();\n        });\n\n\n        this._inputH.addEventListener("input",(e)=>\n        {\n            this._setColorFromHsvInputs();\n        });\n\n        this._inputS.addEventListener("input",(e)=>\n        {\n            this._setColorFromHsvInputs();\n        });\n\n        this._inputV.addEventListener("input",(e)=>\n        {\n            this._setColorFromHsvInputs();\n        });\n\n\n\n\n        this._inputHex.addEventListener("input",(e)=>\n        {\n            if(this.validateHexInput()) this.setColor(this.validateHexInput())\n        });\n\n        this._inputHex.addEventListener("blur",(e)=>\n        {\n            if(!this.validateHexInput()) \n            {\n                this._inputHex.classList.remove("colorRick_invalid");\n                this._inputHex.value=this._color.hex();\n            }\n\n        });\n\n        this._elHue.addEventListener("pointerdown",this._onHueMouse.bind(this));\n        this._elHue.addEventListener("pointermove",this._onHueMouse.bind(this));\n\n        this._elHue.addEventListener("wheel",(e)=>\n        {\n            const speed=0.2;\n            \n            if(e.deltaY>0)this._hue-=speed;\n            else this._hue+=speed;\n            this._inputH.value=this._hue;\n\n            this._setColorFromHsvInputs();\n            \n            e.preventDefault();\n        });\n\n        if(this.options.ele)\n        {\n            const r=this.options.ele.getBoundingClientRect();\n\n            const padding=30;\n            const containerSize=this._elContainer.getBoundingClientRect();\n            const leftAligned=(r.x+padding)>window.innerWidth-containerSize.width;\n\n            if(!leftAligned) this._elContainer.style.left=(r.x+padding)+"px";\n            else this._elContainer.style.left=(r.x-containerSize.width)+"px";\n            \n            if(r.y+containerSize.height>window.innerHeight) this._elContainer.style.top=(window.innerHeight-containerSize.height-10)+"px";\n            else this._elContainer.style.top=(r.y)+"px";\n        }\n\n        this._elHue.addEventListener("pointerdown",(e)=> { this._elHue.setPointerCapture(e.pointerId); });\n        this._elHue.addEventListener("pointerup",(e)=> { this._elHue.releasePointerCapture(e.pointerId); });\n\n        this._elArea.addEventListener("pointerdown",this._onAreaMouse.bind(this));\n        this._elArea.addEventListener("pointermove",this._onAreaMouse.bind(this));\n        this._elArea.addEventListener("wheel",(e)=>\n        {\n            const speed=0.001;\n            \n            if(e.deltaY>0)this._hueV-=speed;\n            else this._hueV+=speed;\n\n            this._inputV.value=this._hueV;\n\n            this.updateColorField();\n            e.preventDefault();\n        });\n        this._elArea.addEventListener("pointerdown",(e)=> { this._elArea.setPointerCapture(e.pointerId); });\n        this._elArea.addEventListener("pointerup",(e)=> { this._elArea.releasePointerCapture(e.pointerId); });\n\n        document.addEventListener("pointerdown",this._clickOutside.bind(this));\n\n        this._elColorBoxOrig.addEventListener("click",()=>{\n            this.setColor(this._elColorBoxOrig.style.backgroundColor);\n        });\n    }\n\n    _clickOutside(e)\n    {\n        if(this._elContainer.contains(e.target)) return true;\n\n        this.close();\n    }\n\n    validateHexInput()\n    {\n        let v=this._inputHex.value;\n        if(v.indexOf("#")==-1) v="#"+v;\n        const valid=v.length==7;\n\n        if(valid) \n        {\n            this._inputHex.classList.remove("colorRick_invalid");\n            return v;\n        }\n        else this._inputHex.classList.add("colorRick_invalid");\n    }\n\n    setHsvInputs(h,s,v)\n    {\n\n        if(parseFloat(h)!=parseFloat(h))\n        {\n            console.log(" NOT A NUMBER")\n            console.log(new Error().stack)\n        }\n        this._inputH.value=parseFloat(h)||0;\n        this._inputS.value=parseFloat(s)||0;\n        this._inputV.value=parseFloat(v)||0;\n    }\n\n    _setColorFromHsvInputs()\n    {\n        this._hue=this._inputH.value||0;\n        this._hueS=this._inputS.value;\n        this._hueV=this._inputV.value;\n\n        this.updateColorField();\n    }\n\n    _setColorFromRgbInputs()\n    {\n        this.setColor([parseInt(this._inputR.value),parseInt(this._inputG.value),parseInt(this._inputB.value)]);\n    }\n\n    setColor(c)\n    {\n        this._color=chroma(c);\n        this._hue=this._color.hsv()[0];\n        this._hueS=this._color.hsv()[1];\n        this._hueV=this._color.hsv()[2];\n\n        this.setHsvInputs(this._color.hsv()[0], this._inputS.value=this._color.hsv()[1], this._inputV.value=this._color.hsv()[2]);\n\n        this.updateColorField();\n    }\n\n    updateCursors()\n    {\n        if(this._color.luminance()>0.55)this._elAreaCursor.style.backgroundColor="black";\n        else this._elAreaCursor.style.backgroundColor="white";\n\n        this._elHueCursor.style.top=(this._areaHeight-(this._hue/360*this._areaHeight))+"px";\n        this._elAreaCursor.style.marginLeft=(this._color.hsv()[1]*this._areaWidth-3)+"px";\n        this._elAreaCursor.style.marginTop=(this._areaHeight-(this._color.hsv()[2]*this._areaHeight)-3)+"px";\n    }\n\n    validateHSV()\n    {\n\n    }\n\n    updateColorField()\n    {\n        if(this._hue!=this._hue)this._hue=0;\n        if(this._hue<0)this._hue=0;\n        if(this._hue>360)this._hue=360;\n\n        if(this._hueV!=this._hueV)this._hueV=0.0001;\n        if(this._hueV<0)this._hueV=0.0001;\n        if(this._hueV>1)this._hueV=1;\n\n        if(this._hueS!=this._hueS)this._hueS=0.0001;\n        if(this._hueS<0)this._hueS=0.0001;\n        if(this._hueS>1)this._hueS=1;\n\n        this._color=chroma(this._hue%360, this._hueS, this._hueV, \'hsv\');\n\n        if(this.options.onChange && this._currentHex!=this._color.hex())this.options.onChange(this._color);\n        this._currentHex=this._color.hex();\n\n        const rgb_bgcol=chroma(this._hue%360, 1,1, \'hsv\').rgb();\n        this._elArea.style.background="linear-gradient(to right, rgb(255, 255, 255), rgb("+rgb_bgcol[0]+", "+rgb_bgcol[1]+", "+rgb_bgcol[2]+"))"\n\n        this._elColorBox.style.backgroundColor=this._color.hex();\n        this._inputHex.value=this._color.hex();\n\n        this._inputR.value=this._color.rgb()[0];\n        this._inputG.value=this._color.rgb()[1];\n        this._inputB.value=this._color.rgb()[2];\n\n        this.updateCursors();\n    }\n\n    close()\n    {\n        document.removeEventListener("pointerdown",this._clickOutside.bind(this));\n\n        for(let i=0;i<this._elements.length;i++) this._elements[i].remove();\n    }\n\n    _onHueMouse(e)\n    {\n        if(e.buttons==1)\n        {\n            const y=Math.min(this._areaHeight,Math.max(0,e.offsetY));\n\n            this._hue=(1.0-(y/this._areaHeight))*360;\n\n            this.setHsvInputs(this._hue,this._hueS,this._hueV);\n\n            this.updateColorField();\n        }\n    }\n\n    _onAreaMouse(e)\n    {\n        if(e.buttons==1)\n        {\n            const x=Math.min(this._areaWidth,Math.max(0,e.offsetX));\n            const y=Math.min(this._areaHeight,Math.max(0,e.offsetY));\n            \n            this._hueV=1.0-(y/this._areaHeight);\n            this._hueS=(x/this._areaWidth);\n\n            this._inputS.value=this._hueS;\n            this._inputV.value=this._hueV;\n            this._setColorFromHsvInputs();\n            \n        }\n    }\n};\n\nmodule.exports=ColorRick;\n\n\n\n//# sourceURL=webpack://ColorRick/./index.js?')
            },
            "./node_modules/chroma-js/chroma.js": function(module) {
                eval("/**\n * chroma.js - JavaScript library for color conversions\n *\n * Copyright (c) 2011-2019, Gregor Aisch\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * 1. Redistributions of source code must retain the above copyright notice, this\n * list of conditions and the following disclaimer.\n *\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n * this list of conditions and the following disclaimer in the documentation\n * and/or other materials provided with the distribution.\n *\n * 3. The name Gregor Aisch may not be used to endorse or promote products\n * derived from this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL GREGOR AISCH OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,\n * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY\n * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,\n * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *\n * -------------------------------------------------------\n *\n * chroma.js includes colors from colorbrewer2.org, which are released under\n * the following license:\n *\n * Copyright (c) 2002 Cynthia Brewer, Mark Harrower,\n * and The Pennsylvania State University.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n * either express or implied. See the License for the specific\n * language governing permissions and limitations under the License.\n *\n * ------------------------------------------------------\n *\n * Named colors are taken from X11 Color Names.\n * http://www.w3.org/TR/css3-color/#svg-color\n *\n * @preserve\n */\n\n(function (global, factory) {\n     true ? module.exports = factory() :\n    0;\n}(this, (function () { 'use strict';\n\n    var limit = function (x, min, max) {\n        if ( min === void 0 ) min=0;\n        if ( max === void 0 ) max=1;\n\n        return x < min ? min : x > max ? max : x;\n    };\n\n    var clip_rgb = function (rgb) {\n        rgb._clipped = false;\n        rgb._unclipped = rgb.slice(0);\n        for (var i=0; i<=3; i++) {\n            if (i < 3) {\n                if (rgb[i] < 0 || rgb[i] > 255) { rgb._clipped = true; }\n                rgb[i] = limit(rgb[i], 0, 255);\n            } else if (i === 3) {\n                rgb[i] = limit(rgb[i], 0, 1);\n            }\n        }\n        return rgb;\n    };\n\n    // ported from jQuery's $.type\n    var classToType = {};\n    for (var i = 0, list = ['Boolean', 'Number', 'String', 'Function', 'Array', 'Date', 'RegExp', 'Undefined', 'Null']; i < list.length; i += 1) {\n        var name = list[i];\n\n        classToType[(\"[object \" + name + \"]\")] = name.toLowerCase();\n    }\n    var type = function(obj) {\n        return classToType[Object.prototype.toString.call(obj)] || \"object\";\n    };\n\n    var unpack = function (args, keyOrder) {\n        if ( keyOrder === void 0 ) keyOrder=null;\n\n    \t// if called with more than 3 arguments, we return the arguments\n        if (args.length >= 3) { return Array.prototype.slice.call(args); }\n        // with less than 3 args we check if first arg is object\n        // and use the keyOrder string to extract and sort properties\n    \tif (type(args[0]) == 'object' && keyOrder) {\n    \t\treturn keyOrder.split('')\n    \t\t\t.filter(function (k) { return args[0][k] !== undefined; })\n    \t\t\t.map(function (k) { return args[0][k]; });\n    \t}\n    \t// otherwise we just return the first argument\n    \t// (which we suppose is an array of args)\n        return args[0];\n    };\n\n    var last = function (args) {\n        if (args.length < 2) { return null; }\n        var l = args.length-1;\n        if (type(args[l]) == 'string') { return args[l].toLowerCase(); }\n        return null;\n    };\n\n    var PI = Math.PI;\n\n    var utils = {\n    \tclip_rgb: clip_rgb,\n    \tlimit: limit,\n    \ttype: type,\n    \tunpack: unpack,\n    \tlast: last,\n    \tPI: PI,\n    \tTWOPI: PI*2,\n    \tPITHIRD: PI/3,\n    \tDEG2RAD: PI / 180,\n    \tRAD2DEG: 180 / PI\n    };\n\n    var input = {\n    \tformat: {},\n    \tautodetect: []\n    };\n\n    var last$1 = utils.last;\n    var clip_rgb$1 = utils.clip_rgb;\n    var type$1 = utils.type;\n\n\n    var Color = function Color() {\n        var args = [], len = arguments.length;\n        while ( len-- ) args[ len ] = arguments[ len ];\n\n        var me = this;\n        if (type$1(args[0]) === 'object' &&\n            args[0].constructor &&\n            args[0].constructor === this.constructor) {\n            // the argument is already a Color instance\n            return args[0];\n        }\n\n        // last argument could be the mode\n        var mode = last$1(args);\n        var autodetect = false;\n\n        if (!mode) {\n            autodetect = true;\n            if (!input.sorted) {\n                input.autodetect = input.autodetect.sort(function (a,b) { return b.p - a.p; });\n                input.sorted = true;\n            }\n            // auto-detect format\n            for (var i = 0, list = input.autodetect; i < list.length; i += 1) {\n                var chk = list[i];\n\n                mode = chk.test.apply(chk, args);\n                if (mode) { break; }\n            }\n        }\n\n        if (input.format[mode]) {\n            var rgb = input.format[mode].apply(null, autodetect ? args : args.slice(0,-1));\n            me._rgb = clip_rgb$1(rgb);\n        } else {\n            throw new Error('unknown format: '+args);\n        }\n\n        // add alpha channel\n        if (me._rgb.length === 3) { me._rgb.push(1); }\n    };\n\n    Color.prototype.toString = function toString () {\n        if (type$1(this.hex) == 'function') { return this.hex(); }\n        return (\"[\" + (this._rgb.join(',')) + \"]\");\n    };\n\n    var Color_1 = Color;\n\n    var chroma = function () {\n    \tvar args = [], len = arguments.length;\n    \twhile ( len-- ) args[ len ] = arguments[ len ];\n\n    \treturn new (Function.prototype.bind.apply( chroma.Color, [ null ].concat( args) ));\n    };\n\n    chroma.Color = Color_1;\n    chroma.version = '2.1.2';\n\n    var chroma_1 = chroma;\n\n    var unpack$1 = utils.unpack;\n    var max = Math.max;\n\n    var rgb2cmyk = function () {\n        var args = [], len = arguments.length;\n        while ( len-- ) args[ len ] = arguments[ len ];\n\n        var ref = unpack$1(args, 'rgb');\n        var r = ref[0];\n        var g = ref[1];\n        var b = ref[2];\n        r = r / 255;\n        g = g / 255;\n        b = b / 255;\n        var k = 1 - max(r,max(g,b));\n        var f = k < 1 ? 1 / (1-k) : 0;\n        var c = (1-r-k) * f;\n        var m = (1-g-k) * f;\n        var y = (1-b-k) * f;\n        return [c,m,y,k];\n    };\n\n    var rgb2cmyk_1 = rgb2cmyk;\n\n    var unpack$2 = utils.unpack;\n\n    var cmyk2rgb = function () {\n        var args = [], len = arguments.length;\n        while ( len-- ) args[ len ] = arguments[ len ];\n\n        args = unpack$2(args, 'cmyk');\n        var c = args[0];\n        var m = args[1];\n        var y = args[2];\n        var k = args[3];\n        var alpha = args.length > 4 ? args[4] : 1;\n        if (k === 1) { return [0,0,0,alpha]; }\n        return [\n            c >= 1 ? 0 : 255 * (1-c) * (1-k), // r\n            m >= 1 ? 0 : 255 * (1-m) * (1-k), // g\n            y >= 1 ? 0 : 255 * (1-y) * (1-k), // b\n            alpha\n        ];\n    };\n\n    var cmyk2rgb_1 = cmyk2rgb;\n\n    var unpack$3 = utils.unpack;\n    var type$2 = utils.type;\n\n\n\n    Color_1.prototype.cmyk = function() {\n        return rgb2cmyk_1(this._rgb);\n    };\n\n    chroma_1.cmyk = function () {\n        var args = [], len = arguments.length;\n        while ( len-- ) args[ len ] = arguments[ len ];\n\n        return new (Function.prototype.bind.apply( Color_1, [ null ].concat( args, ['cmyk']) ));\n    };\n\n    input.format.cmyk = cmyk2rgb_1;\n\n    input.autodetect.push({\n        p: 2,\n        test: function () {\n            var args = [], len = arguments.length;\n            while ( len-- ) args[ len ] = arguments[ len ];\n\n            args = unpack$3(args, 'cmyk');\n            if (type$2(args) === 'array' && args.length === 4) {\n                return 'cmyk';\n            }\n        }\n    });\n\n    var unpack$4 = utils.unpack;\n    var last$2 = utils.last;\n    var rnd = function (a) { return Math.round(a*100)/100; };\n\n    /*\n     * supported arguments:\n     * - hsl2css(h,s,l)\n     * - hsl2css(h,s,l,a)\n     * - hsl2css([h,s,l], mode)\n     * - hsl2css([h,s,l,a], mode)\n     * - hsl2css({h,s,l,a}, mode)\n     */\n    var hsl2css = function () {\n        var args = [], len = arguments.length;\n        while ( len-- ) args[ len ] = arguments[ len ];\n\n        var hsla = unpack$4(args, 'hsla');\n        var mode = last$2(args) || 'lsa';\n        hsla[0] = rnd(hsla[0] || 0);\n        hsla[1] = rnd(hsla[1]*100) + '%';\n        hsla[2] = rnd(hsla[2]*100) + '%';\n        if (mode === 'hsla' || (hsla.length > 3 && hsla[3]<1)) {\n            hsla[3] = hsla.length > 3 ? hsla[3] : 1;\n            mode = 'hsla';\n        } else {\n            hsla.length = 3;\n        }\n        return (mode + \"(\" + (hsla.join(',')) + \")\");\n    };\n\n    var hsl2css_1 = hsl2css;\n\n    var unpack$5 = utils.unpack;\n\n    /*\n     * supported arguments:\n     * - rgb2hsl(r,g,b)\n     * - rgb2hsl(r,g,b,a)\n     * - rgb2hsl([r,g,b])\n     * - rgb2hsl([r,g,b,a])\n     * - rgb2hsl({r,g,b,a})\n     */\n    var rgb2hsl = function () {\n        var args = [], len = arguments.length;\n        while ( len-- ) args[ len ] = arguments[ len ];\n\n        args = unpack$5(args, 'rgba');\n        var r = args[0];\n        var g = args[1];\n        var b = args[2];\n\n        r /= 255;\n        g /= 255;\n        b /= 255;\n\n        var min = Math.min(r, g, b);\n        var max = Math.max(r, g, b);\n\n        var l = (max + min) / 2;\n        var s, h;\n\n        if (max === min){\n            s = 0;\n            h = Number.NaN;\n        } else {\n            s = l < 0.5 ? (max - min) / (max + min) : (max - min) / (2 - max - min);\n        }\n\n        if (r == max) { h = (g - b) / (max - min); }\n        else if (g == max) { h = 2 + (b - r) / (max - min); }\n        else if (b == max) { h = 4 + (r - g) / (max - min); }\n\n        h *= 60;\n        if (h < 0) { h += 360; }\n        if (args.length>3 && args[3]!==undefined) { return [h,s,l,args[3]]; }\n        return [h,s,l];\n    };\n\n    var rgb2hsl_1 = rgb2hsl;\n\n    var unpack$6 = utils.unpack;\n    var last$3 = utils.last;\n\n\n    var round = Math.round;\n\n    /*\n     * supported arguments:\n     * - rgb2css(r,g,b)\n     * - rgb2css(r,g,b,a)\n     * - rgb2css([r,g,b], mode)\n     * - rgb2css([r,g,b,a], mode)\n     * - rgb2css({r,g,b,a}, mode)\n     */\n    var rgb2css = function () {\n        var args = [], len = arguments.length;\n        while ( len-- ) args[ len ] = arguments[ len ];\n\n        var rgba = unpack$6(args, 'rgba');\n        var mode = last$3(args) || 'rgb';\n        if (mode.substr(0,3) == 'hsl') {\n            return hsl2css_1(rgb2hsl_1(rgba), mode);\n        }\n        rgba[0] = round(rgba[0]);\n        rgba[1] = round(rgba[1]);\n        rgba[2] = round(rgba[2]);\n        if (mode === 'rgba' || (rgba.length > 3 && rgba[3]<1)) {\n            rgba[3] = rgba.length > 3 ? rgba[3] : 1;\n            mode = 'rgba';\n        }\n        return (mode + \"(\" + (rgba.slice(0,mode==='rgb'?3:4).join(',')) + \")\");\n    };\n\n    var rgb2css_1 = rgb2css;\n\n    var unpack$7 = utils.unpack;\n    var round$1 = Math.round;\n\n    var hsl2rgb = function () {\n        var assign;\n\n        var args = [], len = arguments.length;\n        while ( len-- ) args[ len ] = arguments[ len ];\n        args = unpack$7(args, 'hsl');\n        var h = args[0];\n        var s = args[1];\n        var l = args[2];\n        var r,g,b;\n        if (s === 0) {\n            r = g = b = l*255;\n        } else {\n            var t3 = [0,0,0];\n            var c = [0,0,0];\n            var t2 = l < 0.5 ? l * (1+s) : l+s-l*s;\n            var t1 = 2 * l - t2;\n            var h_ = h / 360;\n            t3[0] = h_ + 1/3;\n            t3[1] = h_;\n            t3[2] = h_ - 1/3;\n            for (var i=0; i<3; i++) {\n                if (t3[i] < 0) { t3[i] += 1; }\n                if (t3[i] > 1) { t3[i] -= 1; }\n                if (6 * t3[i] < 1)\n                    { c[i] = t1 + (t2 - t1) * 6 * t3[i]; }\n                else if (2 * t3[i] < 1)\n                    { c[i] = t2; }\n                else if (3 * t3[i] < 2)\n                    { c[i] = t1 + (t2 - t1) * ((2 / 3) - t3[i]) * 6; }\n                else\n                    { c[i] = t1; }\n            }\n            (assign = [round$1(c[0]*255),round$1(c[1]*255),round$1(c[2]*255)], r = assign[0], g = assign[1], b = assign[2]);\n        }\n        if (args.length > 3) {\n            // keep alpha channel\n            return [r,g,b,args[3]];\n        }\n        return [r,g,b,1];\n    };\n\n    var hsl2rgb_1 = hsl2rgb;\n\n    var RE_RGB = /^rgb\\(\\s*(-?\\d+),\\s*(-?\\d+)\\s*,\\s*(-?\\d+)\\s*\\)$/;\n    var RE_RGBA = /^rgba\\(\\s*(-?\\d+),\\s*(-?\\d+)\\s*,\\s*(-?\\d+)\\s*,\\s*([01]|[01]?\\.\\d+)\\)$/;\n    var RE_RGB_PCT = /^rgb\\(\\s*(-?\\d+(?:\\.\\d+)?)%,\\s*(-?\\d+(?:\\.\\d+)?)%\\s*,\\s*(-?\\d+(?:\\.\\d+)?)%\\s*\\)$/;\n    var RE_RGBA_PCT = /^rgba\\(\\s*(-?\\d+(?:\\.\\d+)?)%,\\s*(-?\\d+(?:\\.\\d+)?)%\\s*,\\s*(-?\\d+(?:\\.\\d+)?)%\\s*,\\s*([01]|[01]?\\.\\d+)\\)$/;\n    var RE_HSL = /^hsl\\(\\s*(-?\\d+(?:\\.\\d+)?),\\s*(-?\\d+(?:\\.\\d+)?)%\\s*,\\s*(-?\\d+(?:\\.\\d+)?)%\\s*\\)$/;\n    var RE_HSLA = /^hsla\\(\\s*(-?\\d+(?:\\.\\d+)?),\\s*(-?\\d+(?:\\.\\d+)?)%\\s*,\\s*(-?\\d+(?:\\.\\d+)?)%\\s*,\\s*([01]|[01]?\\.\\d+)\\)$/;\n\n    var round$2 = Math.round;\n\n    var css2rgb = function (css) {\n        css = css.toLowerCase().trim();\n        var m;\n\n        if (input.format.named) {\n            try {\n                return input.format.named(css);\n            } catch (e) {\n                // eslint-disable-next-line\n            }\n        }\n\n        // rgb(250,20,0)\n        if ((m = css.match(RE_RGB))) {\n            var rgb = m.slice(1,4);\n            for (var i=0; i<3; i++) {\n                rgb[i] = +rgb[i];\n            }\n            rgb[3] = 1;  // default alpha\n            return rgb;\n        }\n\n        // rgba(250,20,0,0.4)\n        if ((m = css.match(RE_RGBA))) {\n            var rgb$1 = m.slice(1,5);\n            for (var i$1=0; i$1<4; i$1++) {\n                rgb$1[i$1] = +rgb$1[i$1];\n            }\n            return rgb$1;\n        }\n\n        // rgb(100%,0%,0%)\n        if ((m = css.match(RE_RGB_PCT))) {\n            var rgb$2 = m.slice(1,4);\n            for (var i$2=0; i$2<3; i$2++) {\n                rgb$2[i$2] = round$2(rgb$2[i$2] * 2.55);\n            }\n            rgb$2[3] = 1;  // default alpha\n            return rgb$2;\n        }\n\n        // rgba(100%,0%,0%,0.4)\n        if ((m = css.match(RE_RGBA_PCT))) {\n            var rgb$3 = m.slice(1,5);\n            for (var i$3=0; i$3<3; i$3++) {\n                rgb$3[i$3] = round$2(rgb$3[i$3] * 2.55);\n            }\n            rgb$3[3] = +rgb$3[3];\n            return rgb$3;\n        }\n\n        // hsl(0,100%,50%)\n        if ((m = css.match(RE_HSL))) {\n            var hsl = m.slice(1,4);\n            hsl[1] *= 0.01;\n            hsl[2] *= 0.01;\n            var rgb$4 = hsl2rgb_1(hsl);\n            rgb$4[3] = 1;\n            return rgb$4;\n        }\n\n        // hsla(0,100%,50%,0.5)\n        if ((m = css.match(RE_HSLA))) {\n            var hsl$1 = m.slice(1,4);\n            hsl$1[1] *= 0.01;\n            hsl$1[2] *= 0.01;\n            var rgb$5 = hsl2rgb_1(hsl$1);\n            rgb$5[3] = +m[4];  // default alpha = 1\n            return rgb$5;\n        }\n    };\n\n    css2rgb.test = function (s) {\n        return RE_RGB.test(s) ||\n            RE_RGBA.test(s) ||\n            RE_RGB_PCT.test(s) ||\n            RE_RGBA_PCT.test(s) ||\n            RE_HSL.test(s) ||\n            RE_HSLA.test(s);\n    };\n\n    var css2rgb_1 = css2rgb;\n\n    var type$3 = utils.type;\n\n\n\n\n    Color_1.prototype.css = function(mode) {\n        return rgb2css_1(this._rgb, mode);\n    };\n\n    chroma_1.css = function () {\n        var args = [], len = arguments.length;\n        while ( len-- ) args[ len ] = arguments[ len ];\n\n        return new (Function.prototype.bind.apply( Color_1, [ null ].concat( args, ['css']) ));\n    };\n\n    input.format.css = css2rgb_1;\n\n    input.autodetect.push({\n        p: 5,\n        test: function (h) {\n            var rest = [], len = arguments.length - 1;\n            while ( len-- > 0 ) rest[ len ] = arguments[ len + 1 ];\n\n            if (!rest.length && type$3(h) === 'string' && css2rgb_1.test(h)) {\n                return 'css';\n            }\n        }\n    });\n\n    var unpack$8 = utils.unpack;\n\n    input.format.gl = function () {\n        var args = [], len = arguments.length;\n        while ( len-- ) args[ len ] = arguments[ len ];\n\n        var rgb = unpack$8(args, 'rgba');\n        rgb[0] *= 255;\n        rgb[1] *= 255;\n        rgb[2] *= 255;\n        return rgb;\n    };\n\n    chroma_1.gl = function () {\n        var args = [], len = arguments.length;\n        while ( len-- ) args[ len ] = arguments[ len ];\n\n        return new (Function.prototype.bind.apply( Color_1, [ null ].concat( args, ['gl']) ));\n    };\n\n    Color_1.prototype.gl = function() {\n        var rgb = this._rgb;\n        return [rgb[0]/255, rgb[1]/255, rgb[2]/255, rgb[3]];\n    };\n\n    var unpack$9 = utils.unpack;\n\n    var rgb2hcg = function () {\n        var args = [], len = arguments.length;\n        while ( len-- ) args[ len ] = arguments[ len ];\n\n        var ref = unpack$9(args, 'rgb');\n        var r = ref[0];\n        var g = ref[1];\n        var b = ref[2];\n        var min = Math.min(r, g, b);\n        var max = Math.max(r, g, b);\n        var delta = max - min;\n        var c = delta * 100 / 255;\n        var _g = min / (255 - delta) * 100;\n        var h;\n        if (delta === 0) {\n            h = Number.NaN;\n        } else {\n            if (r === max) { h = (g - b) / delta; }\n            if (g === max) { h = 2+(b - r) / delta; }\n            if (b === max) { h = 4+(r - g) / delta; }\n            h *= 60;\n            if (h < 0) { h += 360; }\n        }\n        return [h, c, _g];\n    };\n\n    var rgb2hcg_1 = rgb2hcg;\n\n    var unpack$a = utils.unpack;\n    var floor = Math.floor;\n\n    /*\n     * this is basically just HSV with some minor tweaks\n     *\n     * hue.. [0..360]\n     * chroma .. [0..1]\n     * grayness .. [0..1]\n     */\n\n    var hcg2rgb = function () {\n        var assign, assign$1, assign$2, assign$3, assign$4, assign$5;\n\n        var args = [], len = arguments.length;\n        while ( len-- ) args[ len ] = arguments[ len ];\n        args = unpack$a(args, 'hcg');\n        var h = args[0];\n        var c = args[1];\n        var _g = args[2];\n        var r,g,b;\n        _g = _g * 255;\n        var _c = c * 255;\n        if (c === 0) {\n            r = g = b = _g;\n        } else {\n            if (h === 360) { h = 0; }\n            if (h > 360) { h -= 360; }\n            if (h < 0) { h += 360; }\n            h /= 60;\n            var i = floor(h);\n            var f = h - i;\n            var p = _g * (1 - c);\n            var q = p + _c * (1 - f);\n            var t = p + _c * f;\n            var v = p + _c;\n            switch (i) {\n                case 0: (assign = [v, t, p], r = assign[0], g = assign[1], b = assign[2]); break\n                case 1: (assign$1 = [q, v, p], r = assign$1[0], g = assign$1[1], b = assign$1[2]); break\n                case 2: (assign$2 = [p, v, t], r = assign$2[0], g = assign$2[1], b = assign$2[2]); break\n                case 3: (assign$3 = [p, q, v], r = assign$3[0], g = assign$3[1], b = assign$3[2]); break\n                case 4: (assign$4 = [t, p, v], r = assign$4[0], g = assign$4[1], b = assign$4[2]); break\n                case 5: (assign$5 = [v, p, q], r = assign$5[0], g = assign$5[1], b = assign$5[2]); break\n            }\n        }\n        return [r, g, b, args.length > 3 ? args[3] : 1];\n    };\n\n    var hcg2rgb_1 = hcg2rgb;\n\n    var unpack$b = utils.unpack;\n    var type$4 = utils.type;\n\n\n\n\n\n\n    Color_1.prototype.hcg = function() {\n        return rgb2hcg_1(this._rgb);\n    };\n\n    chroma_1.hcg = function () {\n        var args = [], len = arguments.length;\n        while ( len-- ) args[ len ] = arguments[ len ];\n\n        return new (Function.prototype.bind.apply( Color_1, [ null ].concat( args, ['hcg']) ));\n    };\n\n    input.format.hcg = hcg2rgb_1;\n\n    input.autodetect.push({\n        p: 1,\n        test: function () {\n            var args = [], len = arguments.length;\n            while ( len-- ) args[ len ] = arguments[ len ];\n\n            args = unpack$b(args, 'hcg');\n            if (type$4(args) === 'array' && args.length === 3) {\n                return 'hcg';\n            }\n        }\n    });\n\n    var unpack$c = utils.unpack;\n    var last$4 = utils.last;\n    var round$3 = Math.round;\n\n    var rgb2hex = function () {\n        var args = [], len = arguments.length;\n        while ( len-- ) args[ len ] = arguments[ len ];\n\n        var ref = unpack$c(args, 'rgba');\n        var r = ref[0];\n        var g = ref[1];\n        var b = ref[2];\n        var a = ref[3];\n        var mode = last$4(args) || 'auto';\n        if (a === undefined) { a = 1; }\n        if (mode === 'auto') {\n            mode = a < 1 ? 'rgba' : 'rgb';\n        }\n        r = round$3(r);\n        g = round$3(g);\n        b = round$3(b);\n        var u = r << 16 | g << 8 | b;\n        var str = \"000000\" + u.toString(16); //#.toUpperCase();\n        str = str.substr(str.length - 6);\n        var hxa = '0' + round$3(a * 255).toString(16);\n        hxa = hxa.substr(hxa.length - 2);\n        switch (mode.toLowerCase()) {\n            case 'rgba': return (\"#\" + str + hxa);\n            case 'argb': return (\"#\" + hxa + str);\n            default: return (\"#\" + str);\n        }\n    };\n\n    var rgb2hex_1 = rgb2hex;\n\n    var RE_HEX = /^#?([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})$/;\n    var RE_HEXA = /^#?([A-Fa-f0-9]{8}|[A-Fa-f0-9]{4})$/;\n\n    var hex2rgb = function (hex) {\n        if (hex.match(RE_HEX)) {\n            // remove optional leading #\n            if (hex.length === 4 || hex.length === 7) {\n                hex = hex.substr(1);\n            }\n            // expand short-notation to full six-digit\n            if (hex.length === 3) {\n                hex = hex.split('');\n                hex = hex[0]+hex[0]+hex[1]+hex[1]+hex[2]+hex[2];\n            }\n            var u = parseInt(hex, 16);\n            var r = u >> 16;\n            var g = u >> 8 & 0xFF;\n            var b = u & 0xFF;\n            return [r,g,b,1];\n        }\n\n        // match rgba hex format, eg #FF000077\n        if (hex.match(RE_HEXA)) {\n            if (hex.length === 5 || hex.length === 9) {\n                // remove optional leading #\n                hex = hex.substr(1);\n            }\n            // expand short-notation to full eight-digit\n            if (hex.length === 4) {\n                hex = hex.split('');\n                hex = hex[0]+hex[0]+hex[1]+hex[1]+hex[2]+hex[2]+hex[3]+hex[3];\n            }\n            var u$1 = parseInt(hex, 16);\n            var r$1 = u$1 >> 24 & 0xFF;\n            var g$1 = u$1 >> 16 & 0xFF;\n            var b$1 = u$1 >> 8 & 0xFF;\n            var a = Math.round((u$1 & 0xFF) / 0xFF * 100) / 100;\n            return [r$1,g$1,b$1,a];\n        }\n\n        // we used to check for css colors here\n        // if _input.css? and rgb = _input.css hex\n        //     return rgb\n\n        throw new Error((\"unknown hex color: \" + hex));\n    };\n\n    var hex2rgb_1 = hex2rgb;\n\n    var type$5 = utils.type;\n\n\n\n\n    Color_1.prototype.hex = function(mode) {\n        return rgb2hex_1(this._rgb, mode);\n    };\n\n    chroma_1.hex = function () {\n        var args = [], len = arguments.length;\n        while ( len-- ) args[ len ] = arguments[ len ];\n\n        return new (Function.prototype.bind.apply( Color_1, [ null ].concat( args, ['hex']) ));\n    };\n\n    input.format.hex = hex2rgb_1;\n    input.autodetect.push({\n        p: 4,\n        test: function (h) {\n            var rest = [], len = arguments.length - 1;\n            while ( len-- > 0 ) rest[ len ] = arguments[ len + 1 ];\n\n            if (!rest.length && type$5(h) === 'string' && [3,4,5,6,7,8,9].indexOf(h.length) >= 0) {\n                return 'hex';\n            }\n        }\n    });\n\n    var unpack$d = utils.unpack;\n    var TWOPI = utils.TWOPI;\n    var min = Math.min;\n    var sqrt = Math.sqrt;\n    var acos = Math.acos;\n\n    var rgb2hsi = function () {\n        var args = [], len = arguments.length;\n        while ( len-- ) args[ len ] = arguments[ len ];\n\n        /*\n        borrowed from here:\n        http://hummer.stanford.edu/museinfo/doc/examples/humdrum/keyscape2/rgb2hsi.cpp\n        */\n        var ref = unpack$d(args, 'rgb');\n        var r = ref[0];\n        var g = ref[1];\n        var b = ref[2];\n        r /= 255;\n        g /= 255;\n        b /= 255;\n        var h;\n        var min_ = min(r,g,b);\n        var i = (r+g+b) / 3;\n        var s = i > 0 ? 1 - min_/i : 0;\n        if (s === 0) {\n            h = NaN;\n        } else {\n            h = ((r-g)+(r-b)) / 2;\n            h /= sqrt((r-g)*(r-g) + (r-b)*(g-b));\n            h = acos(h);\n            if (b > g) {\n                h = TWOPI - h;\n            }\n            h /= TWOPI;\n        }\n        return [h*360,s,i];\n    };\n\n    var rgb2hsi_1 = rgb2hsi;\n\n    var unpack$e = utils.unpack;\n    var limit$1 = utils.limit;\n    var TWOPI$1 = utils.TWOPI;\n    var PITHIRD = utils.PITHIRD;\n    var cos = Math.cos;\n\n    /*\n     * hue [0..360]\n     * saturation [0..1]\n     * intensity [0..1]\n     */\n    var hsi2rgb = function () {\n        var args = [], len = arguments.length;\n        while ( len-- ) args[ len ] = arguments[ len ];\n\n        /*\n        borrowed from here:\n        http://hummer.stanford.edu/museinfo/doc/examples/humdrum/keyscape2/hsi2rgb.cpp\n        */\n        args = unpack$e(args, 'hsi');\n        var h = args[0];\n        var s = args[1];\n        var i = args[2];\n        var r,g,b;\n\n        if (isNaN(h)) { h = 0; }\n        if (isNaN(s)) { s = 0; }\n        // normalize hue\n        if (h > 360) { h -= 360; }\n        if (h < 0) { h += 360; }\n        h /= 360;\n        if (h < 1/3) {\n            b = (1-s)/3;\n            r = (1+s*cos(TWOPI$1*h)/cos(PITHIRD-TWOPI$1*h))/3;\n            g = 1 - (b+r);\n        } else if (h < 2/3) {\n            h -= 1/3;\n            r = (1-s)/3;\n            g = (1+s*cos(TWOPI$1*h)/cos(PITHIRD-TWOPI$1*h))/3;\n            b = 1 - (r+g);\n        } else {\n            h -= 2/3;\n            g = (1-s)/3;\n            b = (1+s*cos(TWOPI$1*h)/cos(PITHIRD-TWOPI$1*h))/3;\n            r = 1 - (g+b);\n        }\n        r = limit$1(i*r*3);\n        g = limit$1(i*g*3);\n        b = limit$1(i*b*3);\n        return [r*255, g*255, b*255, args.length > 3 ? args[3] : 1];\n    };\n\n    var hsi2rgb_1 = hsi2rgb;\n\n    var unpack$f = utils.unpack;\n    var type$6 = utils.type;\n\n\n\n\n\n\n    Color_1.prototype.hsi = function() {\n        return rgb2hsi_1(this._rgb);\n    };\n\n    chroma_1.hsi = function () {\n        var args = [], len = arguments.length;\n        while ( len-- ) args[ len ] = arguments[ len ];\n\n        return new (Function.prototype.bind.apply( Color_1, [ null ].concat( args, ['hsi']) ));\n    };\n\n    input.format.hsi = hsi2rgb_1;\n\n    input.autodetect.push({\n        p: 2,\n        test: function () {\n            var args = [], len = arguments.length;\n            while ( len-- ) args[ len ] = arguments[ len ];\n\n            args = unpack$f(args, 'hsi');\n            if (type$6(args) === 'array' && args.length === 3) {\n                return 'hsi';\n            }\n        }\n    });\n\n    var unpack$g = utils.unpack;\n    var type$7 = utils.type;\n\n\n\n\n\n\n    Color_1.prototype.hsl = function() {\n        return rgb2hsl_1(this._rgb);\n    };\n\n    chroma_1.hsl = function () {\n        var args = [], len = arguments.length;\n        while ( len-- ) args[ len ] = arguments[ len ];\n\n        return new (Function.prototype.bind.apply( Color_1, [ null ].concat( args, ['hsl']) ));\n    };\n\n    input.format.hsl = hsl2rgb_1;\n\n    input.autodetect.push({\n        p: 2,\n        test: function () {\n            var args = [], len = arguments.length;\n            while ( len-- ) args[ len ] = arguments[ len ];\n\n            args = unpack$g(args, 'hsl');\n            if (type$7(args) === 'array' && args.length === 3) {\n                return 'hsl';\n            }\n        }\n    });\n\n    var unpack$h = utils.unpack;\n    var min$1 = Math.min;\n    var max$1 = Math.max;\n\n    /*\n     * supported arguments:\n     * - rgb2hsv(r,g,b)\n     * - rgb2hsv([r,g,b])\n     * - rgb2hsv({r,g,b})\n     */\n    var rgb2hsl$1 = function () {\n        var args = [], len = arguments.length;\n        while ( len-- ) args[ len ] = arguments[ len ];\n\n        args = unpack$h(args, 'rgb');\n        var r = args[0];\n        var g = args[1];\n        var b = args[2];\n        var min_ = min$1(r, g, b);\n        var max_ = max$1(r, g, b);\n        var delta = max_ - min_;\n        var h,s,v;\n        v = max_ / 255.0;\n        if (max_ === 0) {\n            h = Number.NaN;\n            s = 0;\n        } else {\n            s = delta / max_;\n            if (r === max_) { h = (g - b) / delta; }\n            if (g === max_) { h = 2+(b - r) / delta; }\n            if (b === max_) { h = 4+(r - g) / delta; }\n            h *= 60;\n            if (h < 0) { h += 360; }\n        }\n        return [h, s, v]\n    };\n\n    var rgb2hsv = rgb2hsl$1;\n\n    var unpack$i = utils.unpack;\n    var floor$1 = Math.floor;\n\n    var hsv2rgb = function () {\n        var assign, assign$1, assign$2, assign$3, assign$4, assign$5;\n\n        var args = [], len = arguments.length;\n        while ( len-- ) args[ len ] = arguments[ len ];\n        args = unpack$i(args, 'hsv');\n        var h = args[0];\n        var s = args[1];\n        var v = args[2];\n        var r,g,b;\n        v *= 255;\n        if (s === 0) {\n            r = g = b = v;\n        } else {\n            if (h === 360) { h = 0; }\n            if (h > 360) { h -= 360; }\n            if (h < 0) { h += 360; }\n            h /= 60;\n\n            var i = floor$1(h);\n            var f = h - i;\n            var p = v * (1 - s);\n            var q = v * (1 - s * f);\n            var t = v * (1 - s * (1 - f));\n\n            switch (i) {\n                case 0: (assign = [v, t, p], r = assign[0], g = assign[1], b = assign[2]); break\n                case 1: (assign$1 = [q, v, p], r = assign$1[0], g = assign$1[1], b = assign$1[2]); break\n                case 2: (assign$2 = [p, v, t], r = assign$2[0], g = assign$2[1], b = assign$2[2]); break\n                case 3: (assign$3 = [p, q, v], r = assign$3[0], g = assign$3[1], b = assign$3[2]); break\n                case 4: (assign$4 = [t, p, v], r = assign$4[0], g = assign$4[1], b = assign$4[2]); break\n                case 5: (assign$5 = [v, p, q], r = assign$5[0], g = assign$5[1], b = assign$5[2]); break\n            }\n        }\n        return [r,g,b,args.length > 3?args[3]:1];\n    };\n\n    var hsv2rgb_1 = hsv2rgb;\n\n    var unpack$j = utils.unpack;\n    var type$8 = utils.type;\n\n\n\n\n\n\n    Color_1.prototype.hsv = function() {\n        return rgb2hsv(this._rgb);\n    };\n\n    chroma_1.hsv = function () {\n        var args = [], len = arguments.length;\n        while ( len-- ) args[ len ] = arguments[ len ];\n\n        return new (Function.prototype.bind.apply( Color_1, [ null ].concat( args, ['hsv']) ));\n    };\n\n    input.format.hsv = hsv2rgb_1;\n\n    input.autodetect.push({\n        p: 2,\n        test: function () {\n            var args = [], len = arguments.length;\n            while ( len-- ) args[ len ] = arguments[ len ];\n\n            args = unpack$j(args, 'hsv');\n            if (type$8(args) === 'array' && args.length === 3) {\n                return 'hsv';\n            }\n        }\n    });\n\n    var labConstants = {\n        // Corresponds roughly to RGB brighter/darker\n        Kn: 18,\n\n        // D65 standard referent\n        Xn: 0.950470,\n        Yn: 1,\n        Zn: 1.088830,\n\n        t0: 0.137931034,  // 4 / 29\n        t1: 0.206896552,  // 6 / 29\n        t2: 0.12841855,   // 3 * t1 * t1\n        t3: 0.008856452,  // t1 * t1 * t1\n    };\n\n    var unpack$k = utils.unpack;\n    var pow = Math.pow;\n\n    var rgb2lab = function () {\n        var args = [], len = arguments.length;\n        while ( len-- ) args[ len ] = arguments[ len ];\n\n        var ref = unpack$k(args, 'rgb');\n        var r = ref[0];\n        var g = ref[1];\n        var b = ref[2];\n        var ref$1 = rgb2xyz(r,g,b);\n        var x = ref$1[0];\n        var y = ref$1[1];\n        var z = ref$1[2];\n        var l = 116 * y - 16;\n        return [l < 0 ? 0 : l, 500 * (x - y), 200 * (y - z)];\n    };\n\n    var rgb_xyz = function (r) {\n        if ((r /= 255) <= 0.04045) { return r / 12.92; }\n        return pow((r + 0.055) / 1.055, 2.4);\n    };\n\n    var xyz_lab = function (t) {\n        if (t > labConstants.t3) { return pow(t, 1 / 3); }\n        return t / labConstants.t2 + labConstants.t0;\n    };\n\n    var rgb2xyz = function (r,g,b) {\n        r = rgb_xyz(r);\n        g = rgb_xyz(g);\n        b = rgb_xyz(b);\n        var x = xyz_lab((0.4124564 * r + 0.3575761 * g + 0.1804375 * b) / labConstants.Xn);\n        var y = xyz_lab((0.2126729 * r + 0.7151522 * g + 0.0721750 * b) / labConstants.Yn);\n        var z = xyz_lab((0.0193339 * r + 0.1191920 * g + 0.9503041 * b) / labConstants.Zn);\n        return [x,y,z];\n    };\n\n    var rgb2lab_1 = rgb2lab;\n\n    var unpack$l = utils.unpack;\n    var pow$1 = Math.pow;\n\n    /*\n     * L* [0..100]\n     * a [-100..100]\n     * b [-100..100]\n     */\n    var lab2rgb = function () {\n        var args = [], len = arguments.length;\n        while ( len-- ) args[ len ] = arguments[ len ];\n\n        args = unpack$l(args, 'lab');\n        var l = args[0];\n        var a = args[1];\n        var b = args[2];\n        var x,y,z, r,g,b_;\n\n        y = (l + 16) / 116;\n        x = isNaN(a) ? y : y + a / 500;\n        z = isNaN(b) ? y : y - b / 200;\n\n        y = labConstants.Yn * lab_xyz(y);\n        x = labConstants.Xn * lab_xyz(x);\n        z = labConstants.Zn * lab_xyz(z);\n\n        r = xyz_rgb(3.2404542 * x - 1.5371385 * y - 0.4985314 * z);  // D65 -> sRGB\n        g = xyz_rgb(-0.9692660 * x + 1.8760108 * y + 0.0415560 * z);\n        b_ = xyz_rgb(0.0556434 * x - 0.2040259 * y + 1.0572252 * z);\n\n        return [r,g,b_,args.length > 3 ? args[3] : 1];\n    };\n\n    var xyz_rgb = function (r) {\n        return 255 * (r <= 0.00304 ? 12.92 * r : 1.055 * pow$1(r, 1 / 2.4) - 0.055)\n    };\n\n    var lab_xyz = function (t) {\n        return t > labConstants.t1 ? t * t * t : labConstants.t2 * (t - labConstants.t0)\n    };\n\n    var lab2rgb_1 = lab2rgb;\n\n    var unpack$m = utils.unpack;\n    var type$9 = utils.type;\n\n\n\n\n\n\n    Color_1.prototype.lab = function() {\n        return rgb2lab_1(this._rgb);\n    };\n\n    chroma_1.lab = function () {\n        var args = [], len = arguments.length;\n        while ( len-- ) args[ len ] = arguments[ len ];\n\n        return new (Function.prototype.bind.apply( Color_1, [ null ].concat( args, ['lab']) ));\n    };\n\n    input.format.lab = lab2rgb_1;\n\n    input.autodetect.push({\n        p: 2,\n        test: function () {\n            var args = [], len = arguments.length;\n            while ( len-- ) args[ len ] = arguments[ len ];\n\n            args = unpack$m(args, 'lab');\n            if (type$9(args) === 'array' && args.length === 3) {\n                return 'lab';\n            }\n        }\n    });\n\n    var unpack$n = utils.unpack;\n    var RAD2DEG = utils.RAD2DEG;\n    var sqrt$1 = Math.sqrt;\n    var atan2 = Math.atan2;\n    var round$4 = Math.round;\n\n    var lab2lch = function () {\n        var args = [], len = arguments.length;\n        while ( len-- ) args[ len ] = arguments[ len ];\n\n        var ref = unpack$n(args, 'lab');\n        var l = ref[0];\n        var a = ref[1];\n        var b = ref[2];\n        var c = sqrt$1(a * a + b * b);\n        var h = (atan2(b, a) * RAD2DEG + 360) % 360;\n        if (round$4(c*10000) === 0) { h = Number.NaN; }\n        return [l, c, h];\n    };\n\n    var lab2lch_1 = lab2lch;\n\n    var unpack$o = utils.unpack;\n\n\n\n    var rgb2lch = function () {\n        var args = [], len = arguments.length;\n        while ( len-- ) args[ len ] = arguments[ len ];\n\n        var ref = unpack$o(args, 'rgb');\n        var r = ref[0];\n        var g = ref[1];\n        var b = ref[2];\n        var ref$1 = rgb2lab_1(r,g,b);\n        var l = ref$1[0];\n        var a = ref$1[1];\n        var b_ = ref$1[2];\n        return lab2lch_1(l,a,b_);\n    };\n\n    var rgb2lch_1 = rgb2lch;\n\n    var unpack$p = utils.unpack;\n    var DEG2RAD = utils.DEG2RAD;\n    var sin = Math.sin;\n    var cos$1 = Math.cos;\n\n    var lch2lab = function () {\n        var args = [], len = arguments.length;\n        while ( len-- ) args[ len ] = arguments[ len ];\n\n        /*\n        Convert from a qualitative parameter h and a quantitative parameter l to a 24-bit pixel.\n        These formulas were invented by David Dalrymple to obtain maximum contrast without going\n        out of gamut if the parameters are in the range 0-1.\n\n        A saturation multiplier was added by Gregor Aisch\n        */\n        var ref = unpack$p(args, 'lch');\n        var l = ref[0];\n        var c = ref[1];\n        var h = ref[2];\n        if (isNaN(h)) { h = 0; }\n        h = h * DEG2RAD;\n        return [l, cos$1(h) * c, sin(h) * c]\n    };\n\n    var lch2lab_1 = lch2lab;\n\n    var unpack$q = utils.unpack;\n\n\n\n    var lch2rgb = function () {\n        var args = [], len = arguments.length;\n        while ( len-- ) args[ len ] = arguments[ len ];\n\n        args = unpack$q(args, 'lch');\n        var l = args[0];\n        var c = args[1];\n        var h = args[2];\n        var ref = lch2lab_1 (l,c,h);\n        var L = ref[0];\n        var a = ref[1];\n        var b_ = ref[2];\n        var ref$1 = lab2rgb_1 (L,a,b_);\n        var r = ref$1[0];\n        var g = ref$1[1];\n        var b = ref$1[2];\n        return [r, g, b, args.length > 3 ? args[3] : 1];\n    };\n\n    var lch2rgb_1 = lch2rgb;\n\n    var unpack$r = utils.unpack;\n\n\n    var hcl2rgb = function () {\n        var args = [], len = arguments.length;\n        while ( len-- ) args[ len ] = arguments[ len ];\n\n        var hcl = unpack$r(args, 'hcl').reverse();\n        return lch2rgb_1.apply(void 0, hcl);\n    };\n\n    var hcl2rgb_1 = hcl2rgb;\n\n    var unpack$s = utils.unpack;\n    var type$a = utils.type;\n\n\n\n\n\n\n    Color_1.prototype.lch = function() { return rgb2lch_1(this._rgb); };\n    Color_1.prototype.hcl = function() { return rgb2lch_1(this._rgb).reverse(); };\n\n    chroma_1.lch = function () {\n        var args = [], len = arguments.length;\n        while ( len-- ) args[ len ] = arguments[ len ];\n\n        return new (Function.prototype.bind.apply( Color_1, [ null ].concat( args, ['lch']) ));\n    };\n    chroma_1.hcl = function () {\n        var args = [], len = arguments.length;\n        while ( len-- ) args[ len ] = arguments[ len ];\n\n        return new (Function.prototype.bind.apply( Color_1, [ null ].concat( args, ['hcl']) ));\n    };\n\n    input.format.lch = lch2rgb_1;\n    input.format.hcl = hcl2rgb_1;\n\n    ['lch','hcl'].forEach(function (m) { return input.autodetect.push({\n        p: 2,\n        test: function () {\n            var args = [], len = arguments.length;\n            while ( len-- ) args[ len ] = arguments[ len ];\n\n            args = unpack$s(args, m);\n            if (type$a(args) === 'array' && args.length === 3) {\n                return m;\n            }\n        }\n    }); });\n\n    /**\n    \tX11 color names\n\n    \thttp://www.w3.org/TR/css3-color/#svg-color\n    */\n\n    var w3cx11 = {\n        aliceblue: '#f0f8ff',\n        antiquewhite: '#faebd7',\n        aqua: '#00ffff',\n        aquamarine: '#7fffd4',\n        azure: '#f0ffff',\n        beige: '#f5f5dc',\n        bisque: '#ffe4c4',\n        black: '#000000',\n        blanchedalmond: '#ffebcd',\n        blue: '#0000ff',\n        blueviolet: '#8a2be2',\n        brown: '#a52a2a',\n        burlywood: '#deb887',\n        cadetblue: '#5f9ea0',\n        chartreuse: '#7fff00',\n        chocolate: '#d2691e',\n        coral: '#ff7f50',\n        cornflower: '#6495ed',\n        cornflowerblue: '#6495ed',\n        cornsilk: '#fff8dc',\n        crimson: '#dc143c',\n        cyan: '#00ffff',\n        darkblue: '#00008b',\n        darkcyan: '#008b8b',\n        darkgoldenrod: '#b8860b',\n        darkgray: '#a9a9a9',\n        darkgreen: '#006400',\n        darkgrey: '#a9a9a9',\n        darkkhaki: '#bdb76b',\n        darkmagenta: '#8b008b',\n        darkolivegreen: '#556b2f',\n        darkorange: '#ff8c00',\n        darkorchid: '#9932cc',\n        darkred: '#8b0000',\n        darksalmon: '#e9967a',\n        darkseagreen: '#8fbc8f',\n        darkslateblue: '#483d8b',\n        darkslategray: '#2f4f4f',\n        darkslategrey: '#2f4f4f',\n        darkturquoise: '#00ced1',\n        darkviolet: '#9400d3',\n        deeppink: '#ff1493',\n        deepskyblue: '#00bfff',\n        dimgray: '#696969',\n        dimgrey: '#696969',\n        dodgerblue: '#1e90ff',\n        firebrick: '#b22222',\n        floralwhite: '#fffaf0',\n        forestgreen: '#228b22',\n        fuchsia: '#ff00ff',\n        gainsboro: '#dcdcdc',\n        ghostwhite: '#f8f8ff',\n        gold: '#ffd700',\n        goldenrod: '#daa520',\n        gray: '#808080',\n        green: '#008000',\n        greenyellow: '#adff2f',\n        grey: '#808080',\n        honeydew: '#f0fff0',\n        hotpink: '#ff69b4',\n        indianred: '#cd5c5c',\n        indigo: '#4b0082',\n        ivory: '#fffff0',\n        khaki: '#f0e68c',\n        laserlemon: '#ffff54',\n        lavender: '#e6e6fa',\n        lavenderblush: '#fff0f5',\n        lawngreen: '#7cfc00',\n        lemonchiffon: '#fffacd',\n        lightblue: '#add8e6',\n        lightcoral: '#f08080',\n        lightcyan: '#e0ffff',\n        lightgoldenrod: '#fafad2',\n        lightgoldenrodyellow: '#fafad2',\n        lightgray: '#d3d3d3',\n        lightgreen: '#90ee90',\n        lightgrey: '#d3d3d3',\n        lightpink: '#ffb6c1',\n        lightsalmon: '#ffa07a',\n        lightseagreen: '#20b2aa',\n        lightskyblue: '#87cefa',\n        lightslategray: '#778899',\n        lightslategrey: '#778899',\n        lightsteelblue: '#b0c4de',\n        lightyellow: '#ffffe0',\n        lime: '#00ff00',\n        limegreen: '#32cd32',\n        linen: '#faf0e6',\n        magenta: '#ff00ff',\n        maroon: '#800000',\n        maroon2: '#7f0000',\n        maroon3: '#b03060',\n        mediumaquamarine: '#66cdaa',\n        mediumblue: '#0000cd',\n        mediumorchid: '#ba55d3',\n        mediumpurple: '#9370db',\n        mediumseagreen: '#3cb371',\n        mediumslateblue: '#7b68ee',\n        mediumspringgreen: '#00fa9a',\n        mediumturquoise: '#48d1cc',\n        mediumvioletred: '#c71585',\n        midnightblue: '#191970',\n        mintcream: '#f5fffa',\n        mistyrose: '#ffe4e1',\n        moccasin: '#ffe4b5',\n        navajowhite: '#ffdead',\n        navy: '#000080',\n        oldlace: '#fdf5e6',\n        olive: '#808000',\n        olivedrab: '#6b8e23',\n        orange: '#ffa500',\n        orangered: '#ff4500',\n        orchid: '#da70d6',\n        palegoldenrod: '#eee8aa',\n        palegreen: '#98fb98',\n        paleturquoise: '#afeeee',\n        palevioletred: '#db7093',\n        papayawhip: '#ffefd5',\n        peachpuff: '#ffdab9',\n        peru: '#cd853f',\n        pink: '#ffc0cb',\n        plum: '#dda0dd',\n        powderblue: '#b0e0e6',\n        purple: '#800080',\n        purple2: '#7f007f',\n        purple3: '#a020f0',\n        rebeccapurple: '#663399',\n        red: '#ff0000',\n        rosybrown: '#bc8f8f',\n        royalblue: '#4169e1',\n        saddlebrown: '#8b4513',\n        salmon: '#fa8072',\n        sandybrown: '#f4a460',\n        seagreen: '#2e8b57',\n        seashell: '#fff5ee',\n        sienna: '#a0522d',\n        silver: '#c0c0c0',\n        skyblue: '#87ceeb',\n        slateblue: '#6a5acd',\n        slategray: '#708090',\n        slategrey: '#708090',\n        snow: '#fffafa',\n        springgreen: '#00ff7f',\n        steelblue: '#4682b4',\n        tan: '#d2b48c',\n        teal: '#008080',\n        thistle: '#d8bfd8',\n        tomato: '#ff6347',\n        turquoise: '#40e0d0',\n        violet: '#ee82ee',\n        wheat: '#f5deb3',\n        white: '#ffffff',\n        whitesmoke: '#f5f5f5',\n        yellow: '#ffff00',\n        yellowgreen: '#9acd32'\n    };\n\n    var w3cx11_1 = w3cx11;\n\n    var type$b = utils.type;\n\n\n\n\n\n    Color_1.prototype.name = function() {\n        var hex = rgb2hex_1(this._rgb, 'rgb');\n        for (var i = 0, list = Object.keys(w3cx11_1); i < list.length; i += 1) {\n            var n = list[i];\n\n            if (w3cx11_1[n] === hex) { return n.toLowerCase(); }\n        }\n        return hex;\n    };\n\n    input.format.named = function (name) {\n        name = name.toLowerCase();\n        if (w3cx11_1[name]) { return hex2rgb_1(w3cx11_1[name]); }\n        throw new Error('unknown color name: '+name);\n    };\n\n    input.autodetect.push({\n        p: 5,\n        test: function (h) {\n            var rest = [], len = arguments.length - 1;\n            while ( len-- > 0 ) rest[ len ] = arguments[ len + 1 ];\n\n            if (!rest.length && type$b(h) === 'string' && w3cx11_1[h.toLowerCase()]) {\n                return 'named';\n            }\n        }\n    });\n\n    var unpack$t = utils.unpack;\n\n    var rgb2num = function () {\n        var args = [], len = arguments.length;\n        while ( len-- ) args[ len ] = arguments[ len ];\n\n        var ref = unpack$t(args, 'rgb');\n        var r = ref[0];\n        var g = ref[1];\n        var b = ref[2];\n        return (r << 16) + (g << 8) + b;\n    };\n\n    var rgb2num_1 = rgb2num;\n\n    var type$c = utils.type;\n\n    var num2rgb = function (num) {\n        if (type$c(num) == \"number\" && num >= 0 && num <= 0xFFFFFF) {\n            var r = num >> 16;\n            var g = (num >> 8) & 0xFF;\n            var b = num & 0xFF;\n            return [r,g,b,1];\n        }\n        throw new Error(\"unknown num color: \"+num);\n    };\n\n    var num2rgb_1 = num2rgb;\n\n    var type$d = utils.type;\n\n\n\n    Color_1.prototype.num = function() {\n        return rgb2num_1(this._rgb);\n    };\n\n    chroma_1.num = function () {\n        var args = [], len = arguments.length;\n        while ( len-- ) args[ len ] = arguments[ len ];\n\n        return new (Function.prototype.bind.apply( Color_1, [ null ].concat( args, ['num']) ));\n    };\n\n    input.format.num = num2rgb_1;\n\n    input.autodetect.push({\n        p: 5,\n        test: function () {\n            var args = [], len = arguments.length;\n            while ( len-- ) args[ len ] = arguments[ len ];\n\n            if (args.length === 1 && type$d(args[0]) === 'number' && args[0] >= 0 && args[0] <= 0xFFFFFF) {\n                return 'num';\n            }\n        }\n    });\n\n    var unpack$u = utils.unpack;\n    var type$e = utils.type;\n    var round$5 = Math.round;\n\n    Color_1.prototype.rgb = function(rnd) {\n        if ( rnd === void 0 ) rnd=true;\n\n        if (rnd === false) { return this._rgb.slice(0,3); }\n        return this._rgb.slice(0,3).map(round$5);\n    };\n\n    Color_1.prototype.rgba = function(rnd) {\n        if ( rnd === void 0 ) rnd=true;\n\n        return this._rgb.slice(0,4).map(function (v,i) {\n            return i<3 ? (rnd === false ? v : round$5(v)) : v;\n        });\n    };\n\n    chroma_1.rgb = function () {\n        var args = [], len = arguments.length;\n        while ( len-- ) args[ len ] = arguments[ len ];\n\n        return new (Function.prototype.bind.apply( Color_1, [ null ].concat( args, ['rgb']) ));\n    };\n\n    input.format.rgb = function () {\n        var args = [], len = arguments.length;\n        while ( len-- ) args[ len ] = arguments[ len ];\n\n        var rgba = unpack$u(args, 'rgba');\n        if (rgba[3] === undefined) { rgba[3] = 1; }\n        return rgba;\n    };\n\n    input.autodetect.push({\n        p: 3,\n        test: function () {\n            var args = [], len = arguments.length;\n            while ( len-- ) args[ len ] = arguments[ len ];\n\n            args = unpack$u(args, 'rgba');\n            if (type$e(args) === 'array' && (args.length === 3 ||\n                args.length === 4 && type$e(args[3]) == 'number' && args[3] >= 0 && args[3] <= 1)) {\n                return 'rgb';\n            }\n        }\n    });\n\n    /*\n     * Based on implementation by Neil Bartlett\n     * https://github.com/neilbartlett/color-temperature\n     */\n\n    var log = Math.log;\n\n    var temperature2rgb = function (kelvin) {\n        var temp = kelvin / 100;\n        var r,g,b;\n        if (temp < 66) {\n            r = 255;\n            g = -155.25485562709179 - 0.44596950469579133 * (g = temp-2) + 104.49216199393888 * log(g);\n            b = temp < 20 ? 0 : -254.76935184120902 + 0.8274096064007395 * (b = temp-10) + 115.67994401066147 * log(b);\n        } else {\n            r = 351.97690566805693 + 0.114206453784165 * (r = temp-55) - 40.25366309332127 * log(r);\n            g = 325.4494125711974 + 0.07943456536662342 * (g = temp-50) - 28.0852963507957 * log(g);\n            b = 255;\n        }\n        return [r,g,b,1];\n    };\n\n    var temperature2rgb_1 = temperature2rgb;\n\n    /*\n     * Based on implementation by Neil Bartlett\n     * https://github.com/neilbartlett/color-temperature\n     **/\n\n\n    var unpack$v = utils.unpack;\n    var round$6 = Math.round;\n\n    var rgb2temperature = function () {\n        var args = [], len = arguments.length;\n        while ( len-- ) args[ len ] = arguments[ len ];\n\n        var rgb = unpack$v(args, 'rgb');\n        var r = rgb[0], b = rgb[2];\n        var minTemp = 1000;\n        var maxTemp = 40000;\n        var eps = 0.4;\n        var temp;\n        while (maxTemp - minTemp > eps) {\n            temp = (maxTemp + minTemp) * 0.5;\n            var rgb$1 = temperature2rgb_1(temp);\n            if ((rgb$1[2] / rgb$1[0]) >= (b / r)) {\n                maxTemp = temp;\n            } else {\n                minTemp = temp;\n            }\n        }\n        return round$6(temp);\n    };\n\n    var rgb2temperature_1 = rgb2temperature;\n\n    Color_1.prototype.temp =\n    Color_1.prototype.kelvin =\n    Color_1.prototype.temperature = function() {\n        return rgb2temperature_1(this._rgb);\n    };\n\n    chroma_1.temp =\n    chroma_1.kelvin =\n    chroma_1.temperature = function () {\n        var args = [], len = arguments.length;\n        while ( len-- ) args[ len ] = arguments[ len ];\n\n        return new (Function.prototype.bind.apply( Color_1, [ null ].concat( args, ['temp']) ));\n    };\n\n    input.format.temp =\n    input.format.kelvin =\n    input.format.temperature = temperature2rgb_1;\n\n    var type$f = utils.type;\n\n    Color_1.prototype.alpha = function(a, mutate) {\n        if ( mutate === void 0 ) mutate=false;\n\n        if (a !== undefined && type$f(a) === 'number') {\n            if (mutate) {\n                this._rgb[3] = a;\n                return this;\n            }\n            return new Color_1([this._rgb[0], this._rgb[1], this._rgb[2], a], 'rgb');\n        }\n        return this._rgb[3];\n    };\n\n    Color_1.prototype.clipped = function() {\n        return this._rgb._clipped || false;\n    };\n\n    Color_1.prototype.darken = function(amount) {\n    \tif ( amount === void 0 ) amount=1;\n\n    \tvar me = this;\n    \tvar lab = me.lab();\n    \tlab[0] -= labConstants.Kn * amount;\n    \treturn new Color_1(lab, 'lab').alpha(me.alpha(), true);\n    };\n\n    Color_1.prototype.brighten = function(amount) {\n    \tif ( amount === void 0 ) amount=1;\n\n    \treturn this.darken(-amount);\n    };\n\n    Color_1.prototype.darker = Color_1.prototype.darken;\n    Color_1.prototype.brighter = Color_1.prototype.brighten;\n\n    Color_1.prototype.get = function(mc) {\n        var ref = mc.split('.');\n        var mode = ref[0];\n        var channel = ref[1];\n        var src = this[mode]();\n        if (channel) {\n            var i = mode.indexOf(channel);\n            if (i > -1) { return src[i]; }\n            throw new Error((\"unknown channel \" + channel + \" in mode \" + mode));\n        } else {\n            return src;\n        }\n    };\n\n    var type$g = utils.type;\n    var pow$2 = Math.pow;\n\n    var EPS = 1e-7;\n    var MAX_ITER = 20;\n\n    Color_1.prototype.luminance = function(lum) {\n        if (lum !== undefined && type$g(lum) === 'number') {\n            if (lum === 0) {\n                // return pure black\n                return new Color_1([0,0,0,this._rgb[3]], 'rgb');\n            }\n            if (lum === 1) {\n                // return pure white\n                return new Color_1([255,255,255,this._rgb[3]], 'rgb');\n            }\n            // compute new color using...\n            var cur_lum = this.luminance();\n            var mode = 'rgb';\n            var max_iter = MAX_ITER;\n\n            var test = function (low, high) {\n                var mid = low.interpolate(high, 0.5, mode);\n                var lm = mid.luminance();\n                if (Math.abs(lum - lm) < EPS || !max_iter--) {\n                    // close enough\n                    return mid;\n                }\n                return lm > lum ? test(low, mid) : test(mid, high);\n            };\n\n            var rgb = (cur_lum > lum ? test(new Color_1([0,0,0]), this) : test(this, new Color_1([255,255,255]))).rgb();\n            return new Color_1(rgb.concat( [this._rgb[3]]));\n        }\n        return rgb2luminance.apply(void 0, (this._rgb).slice(0,3));\n    };\n\n\n    var rgb2luminance = function (r,g,b) {\n        // relative luminance\n        // see http://www.w3.org/TR/2008/REC-WCAG20-20081211/#relativeluminancedef\n        r = luminance_x(r);\n        g = luminance_x(g);\n        b = luminance_x(b);\n        return 0.2126 * r + 0.7152 * g + 0.0722 * b;\n    };\n\n    var luminance_x = function (x) {\n        x /= 255;\n        return x <= 0.03928 ? x/12.92 : pow$2((x+0.055)/1.055, 2.4);\n    };\n\n    var interpolator = {};\n\n    var type$h = utils.type;\n\n\n    var mix = function (col1, col2, f) {\n        if ( f === void 0 ) f=0.5;\n        var rest = [], len = arguments.length - 3;\n        while ( len-- > 0 ) rest[ len ] = arguments[ len + 3 ];\n\n        var mode = rest[0] || 'lrgb';\n        if (!interpolator[mode] && !rest.length) {\n            // fall back to the first supported mode\n            mode = Object.keys(interpolator)[0];\n        }\n        if (!interpolator[mode]) {\n            throw new Error((\"interpolation mode \" + mode + \" is not defined\"));\n        }\n        if (type$h(col1) !== 'object') { col1 = new Color_1(col1); }\n        if (type$h(col2) !== 'object') { col2 = new Color_1(col2); }\n        return interpolator[mode](col1, col2, f)\n            .alpha(col1.alpha() + f * (col2.alpha() - col1.alpha()));\n    };\n\n    Color_1.prototype.mix =\n    Color_1.prototype.interpolate = function(col2, f) {\n    \tif ( f === void 0 ) f=0.5;\n    \tvar rest = [], len = arguments.length - 2;\n    \twhile ( len-- > 0 ) rest[ len ] = arguments[ len + 2 ];\n\n    \treturn mix.apply(void 0, [ this, col2, f ].concat( rest ));\n    };\n\n    Color_1.prototype.premultiply = function(mutate) {\n    \tif ( mutate === void 0 ) mutate=false;\n\n    \tvar rgb = this._rgb;\n    \tvar a = rgb[3];\n    \tif (mutate) {\n    \t\tthis._rgb = [rgb[0]*a, rgb[1]*a, rgb[2]*a, a];\n    \t\treturn this;\n    \t} else {\n    \t\treturn new Color_1([rgb[0]*a, rgb[1]*a, rgb[2]*a, a], 'rgb');\n    \t}\n    };\n\n    Color_1.prototype.saturate = function(amount) {\n    \tif ( amount === void 0 ) amount=1;\n\n    \tvar me = this;\n    \tvar lch = me.lch();\n    \tlch[1] += labConstants.Kn * amount;\n    \tif (lch[1] < 0) { lch[1] = 0; }\n    \treturn new Color_1(lch, 'lch').alpha(me.alpha(), true);\n    };\n\n    Color_1.prototype.desaturate = function(amount) {\n    \tif ( amount === void 0 ) amount=1;\n\n    \treturn this.saturate(-amount);\n    };\n\n    var type$i = utils.type;\n\n    Color_1.prototype.set = function(mc, value, mutate) {\n        if ( mutate === void 0 ) mutate=false;\n\n        var ref = mc.split('.');\n        var mode = ref[0];\n        var channel = ref[1];\n        var src = this[mode]();\n        if (channel) {\n            var i = mode.indexOf(channel);\n            if (i > -1) {\n                if (type$i(value) == 'string') {\n                    switch(value.charAt(0)) {\n                        case '+': src[i] += +value; break;\n                        case '-': src[i] += +value; break;\n                        case '*': src[i] *= +(value.substr(1)); break;\n                        case '/': src[i] /= +(value.substr(1)); break;\n                        default: src[i] = +value;\n                    }\n                } else if (type$i(value) === 'number') {\n                    src[i] = value;\n                } else {\n                    throw new Error(\"unsupported value for Color.set\");\n                }\n                var out = new Color_1(src, mode);\n                if (mutate) {\n                    this._rgb = out._rgb;\n                    return this;\n                }\n                return out;\n            }\n            throw new Error((\"unknown channel \" + channel + \" in mode \" + mode));\n        } else {\n            return src;\n        }\n    };\n\n    var rgb$1 = function (col1, col2, f) {\n        var xyz0 = col1._rgb;\n        var xyz1 = col2._rgb;\n        return new Color_1(\n            xyz0[0] + f * (xyz1[0]-xyz0[0]),\n            xyz0[1] + f * (xyz1[1]-xyz0[1]),\n            xyz0[2] + f * (xyz1[2]-xyz0[2]),\n            'rgb'\n        )\n    };\n\n    // register interpolator\n    interpolator.rgb = rgb$1;\n\n    var sqrt$2 = Math.sqrt;\n    var pow$3 = Math.pow;\n\n    var lrgb = function (col1, col2, f) {\n        var ref = col1._rgb;\n        var x1 = ref[0];\n        var y1 = ref[1];\n        var z1 = ref[2];\n        var ref$1 = col2._rgb;\n        var x2 = ref$1[0];\n        var y2 = ref$1[1];\n        var z2 = ref$1[2];\n        return new Color_1(\n            sqrt$2(pow$3(x1,2) * (1-f) + pow$3(x2,2) * f),\n            sqrt$2(pow$3(y1,2) * (1-f) + pow$3(y2,2) * f),\n            sqrt$2(pow$3(z1,2) * (1-f) + pow$3(z2,2) * f),\n            'rgb'\n        )\n    };\n\n    // register interpolator\n    interpolator.lrgb = lrgb;\n\n    var lab$1 = function (col1, col2, f) {\n        var xyz0 = col1.lab();\n        var xyz1 = col2.lab();\n        return new Color_1(\n            xyz0[0] + f * (xyz1[0]-xyz0[0]),\n            xyz0[1] + f * (xyz1[1]-xyz0[1]),\n            xyz0[2] + f * (xyz1[2]-xyz0[2]),\n            'lab'\n        )\n    };\n\n    // register interpolator\n    interpolator.lab = lab$1;\n\n    var _hsx = function (col1, col2, f, m) {\n        var assign, assign$1;\n\n        var xyz0, xyz1;\n        if (m === 'hsl') {\n            xyz0 = col1.hsl();\n            xyz1 = col2.hsl();\n        } else if (m === 'hsv') {\n            xyz0 = col1.hsv();\n            xyz1 = col2.hsv();\n        } else if (m === 'hcg') {\n            xyz0 = col1.hcg();\n            xyz1 = col2.hcg();\n        } else if (m === 'hsi') {\n            xyz0 = col1.hsi();\n            xyz1 = col2.hsi();\n        } else if (m === 'lch' || m === 'hcl') {\n            m = 'hcl';\n            xyz0 = col1.hcl();\n            xyz1 = col2.hcl();\n        }\n\n        var hue0, hue1, sat0, sat1, lbv0, lbv1;\n        if (m.substr(0, 1) === 'h') {\n            (assign = xyz0, hue0 = assign[0], sat0 = assign[1], lbv0 = assign[2]);\n            (assign$1 = xyz1, hue1 = assign$1[0], sat1 = assign$1[1], lbv1 = assign$1[2]);\n        }\n\n        var sat, hue, lbv, dh;\n\n        if (!isNaN(hue0) && !isNaN(hue1)) {\n            // both colors have hue\n            if (hue1 > hue0 && hue1 - hue0 > 180) {\n                dh = hue1-(hue0+360);\n            } else if (hue1 < hue0 && hue0 - hue1 > 180) {\n                dh = hue1+360-hue0;\n            } else{\n                dh = hue1 - hue0;\n            }\n            hue = hue0 + f * dh;\n        } else if (!isNaN(hue0)) {\n            hue = hue0;\n            if ((lbv1 == 1 || lbv1 == 0) && m != 'hsv') { sat = sat0; }\n        } else if (!isNaN(hue1)) {\n            hue = hue1;\n            if ((lbv0 == 1 || lbv0 == 0) && m != 'hsv') { sat = sat1; }\n        } else {\n            hue = Number.NaN;\n        }\n\n        if (sat === undefined) { sat = sat0 + f * (sat1 - sat0); }\n        lbv = lbv0 + f * (lbv1-lbv0);\n        return new Color_1([hue, sat, lbv], m);\n    };\n\n    var lch$1 = function (col1, col2, f) {\n    \treturn _hsx(col1, col2, f, 'lch');\n    };\n\n    // register interpolator\n    interpolator.lch = lch$1;\n    interpolator.hcl = lch$1;\n\n    var num$1 = function (col1, col2, f) {\n        var c1 = col1.num();\n        var c2 = col2.num();\n        return new Color_1(c1 + f * (c2-c1), 'num')\n    };\n\n    // register interpolator\n    interpolator.num = num$1;\n\n    var hcg$1 = function (col1, col2, f) {\n    \treturn _hsx(col1, col2, f, 'hcg');\n    };\n\n    // register interpolator\n    interpolator.hcg = hcg$1;\n\n    var hsi$1 = function (col1, col2, f) {\n    \treturn _hsx(col1, col2, f, 'hsi');\n    };\n\n    // register interpolator\n    interpolator.hsi = hsi$1;\n\n    var hsl$1 = function (col1, col2, f) {\n    \treturn _hsx(col1, col2, f, 'hsl');\n    };\n\n    // register interpolator\n    interpolator.hsl = hsl$1;\n\n    var hsv$1 = function (col1, col2, f) {\n    \treturn _hsx(col1, col2, f, 'hsv');\n    };\n\n    // register interpolator\n    interpolator.hsv = hsv$1;\n\n    var clip_rgb$2 = utils.clip_rgb;\n    var pow$4 = Math.pow;\n    var sqrt$3 = Math.sqrt;\n    var PI$1 = Math.PI;\n    var cos$2 = Math.cos;\n    var sin$1 = Math.sin;\n    var atan2$1 = Math.atan2;\n\n    var average = function (colors, mode, weights) {\n        if ( mode === void 0 ) mode='lrgb';\n        if ( weights === void 0 ) weights=null;\n\n        var l = colors.length;\n        if (!weights) { weights = Array.from(new Array(l)).map(function () { return 1; }); }\n        // normalize weights\n        var k = l / weights.reduce(function(a, b) { return a + b; });\n        weights.forEach(function (w,i) { weights[i] *= k; });\n        // convert colors to Color objects\n        colors = colors.map(function (c) { return new Color_1(c); });\n        if (mode === 'lrgb') {\n            return _average_lrgb(colors, weights)\n        }\n        var first = colors.shift();\n        var xyz = first.get(mode);\n        var cnt = [];\n        var dx = 0;\n        var dy = 0;\n        // initial color\n        for (var i=0; i<xyz.length; i++) {\n            xyz[i] = (xyz[i] || 0) * weights[0];\n            cnt.push(isNaN(xyz[i]) ? 0 : weights[0]);\n            if (mode.charAt(i) === 'h' && !isNaN(xyz[i])) {\n                var A = xyz[i] / 180 * PI$1;\n                dx += cos$2(A) * weights[0];\n                dy += sin$1(A) * weights[0];\n            }\n        }\n\n        var alpha = first.alpha() * weights[0];\n        colors.forEach(function (c,ci) {\n            var xyz2 = c.get(mode);\n            alpha += c.alpha() * weights[ci+1];\n            for (var i=0; i<xyz.length; i++) {\n                if (!isNaN(xyz2[i])) {\n                    cnt[i] += weights[ci+1];\n                    if (mode.charAt(i) === 'h') {\n                        var A = xyz2[i] / 180 * PI$1;\n                        dx += cos$2(A) * weights[ci+1];\n                        dy += sin$1(A) * weights[ci+1];\n                    } else {\n                        xyz[i] += xyz2[i] * weights[ci+1];\n                    }\n                }\n            }\n        });\n\n        for (var i$1=0; i$1<xyz.length; i$1++) {\n            if (mode.charAt(i$1) === 'h') {\n                var A$1 = atan2$1(dy / cnt[i$1], dx / cnt[i$1]) / PI$1 * 180;\n                while (A$1 < 0) { A$1 += 360; }\n                while (A$1 >= 360) { A$1 -= 360; }\n                xyz[i$1] = A$1;\n            } else {\n                xyz[i$1] = xyz[i$1]/cnt[i$1];\n            }\n        }\n        alpha /= l;\n        return (new Color_1(xyz, mode)).alpha(alpha > 0.99999 ? 1 : alpha, true);\n    };\n\n\n    var _average_lrgb = function (colors, weights) {\n        var l = colors.length;\n        var xyz = [0,0,0,0];\n        for (var i=0; i < colors.length; i++) {\n            var col = colors[i];\n            var f = weights[i] / l;\n            var rgb = col._rgb;\n            xyz[0] += pow$4(rgb[0],2) * f;\n            xyz[1] += pow$4(rgb[1],2) * f;\n            xyz[2] += pow$4(rgb[2],2) * f;\n            xyz[3] += rgb[3] * f;\n        }\n        xyz[0] = sqrt$3(xyz[0]);\n        xyz[1] = sqrt$3(xyz[1]);\n        xyz[2] = sqrt$3(xyz[2]);\n        if (xyz[3] > 0.9999999) { xyz[3] = 1; }\n        return new Color_1(clip_rgb$2(xyz));\n    };\n\n    // minimal multi-purpose interface\n\n    // @requires utils color analyze\n\n\n    var type$j = utils.type;\n\n    var pow$5 = Math.pow;\n\n    var scale = function(colors) {\n\n        // constructor\n        var _mode = 'rgb';\n        var _nacol = chroma_1('#ccc');\n        var _spread = 0;\n        // const _fixed = false;\n        var _domain = [0, 1];\n        var _pos = [];\n        var _padding = [0,0];\n        var _classes = false;\n        var _colors = [];\n        var _out = false;\n        var _min = 0;\n        var _max = 1;\n        var _correctLightness = false;\n        var _colorCache = {};\n        var _useCache = true;\n        var _gamma = 1;\n\n        // private methods\n\n        var setColors = function(colors) {\n            colors = colors || ['#fff', '#000'];\n            if (colors && type$j(colors) === 'string' && chroma_1.brewer &&\n                chroma_1.brewer[colors.toLowerCase()]) {\n                colors = chroma_1.brewer[colors.toLowerCase()];\n            }\n            if (type$j(colors) === 'array') {\n                // handle single color\n                if (colors.length === 1) {\n                    colors = [colors[0], colors[0]];\n                }\n                // make a copy of the colors\n                colors = colors.slice(0);\n                // convert to chroma classes\n                for (var c=0; c<colors.length; c++) {\n                    colors[c] = chroma_1(colors[c]);\n                }\n                // auto-fill color position\n                _pos.length = 0;\n                for (var c$1=0; c$1<colors.length; c$1++) {\n                    _pos.push(c$1/(colors.length-1));\n                }\n            }\n            resetCache();\n            return _colors = colors;\n        };\n\n        var getClass = function(value) {\n            if (_classes != null) {\n                var n = _classes.length-1;\n                var i = 0;\n                while (i < n && value >= _classes[i]) {\n                    i++;\n                }\n                return i-1;\n            }\n            return 0;\n        };\n\n        var tMapLightness = function (t) { return t; };\n        var tMapDomain = function (t) { return t; };\n\n        // const classifyValue = function(value) {\n        //     let val = value;\n        //     if (_classes.length > 2) {\n        //         const n = _classes.length-1;\n        //         const i = getClass(value);\n        //         const minc = _classes[0] + ((_classes[1]-_classes[0]) * (0 + (_spread * 0.5)));  // center of 1st class\n        //         const maxc = _classes[n-1] + ((_classes[n]-_classes[n-1]) * (1 - (_spread * 0.5)));  // center of last class\n        //         val = _min + ((((_classes[i] + ((_classes[i+1] - _classes[i]) * 0.5)) - minc) / (maxc-minc)) * (_max - _min));\n        //     }\n        //     return val;\n        // };\n\n        var getColor = function(val, bypassMap) {\n            var col, t;\n            if (bypassMap == null) { bypassMap = false; }\n            if (isNaN(val) || (val === null)) { return _nacol; }\n            if (!bypassMap) {\n                if (_classes && (_classes.length > 2)) {\n                    // find the class\n                    var c = getClass(val);\n                    t = c / (_classes.length-2);\n                } else if (_max !== _min) {\n                    // just interpolate between min/max\n                    t = (val - _min) / (_max - _min);\n                } else {\n                    t = 1;\n                }\n            } else {\n                t = val;\n            }\n\n            // domain map\n            t = tMapDomain(t);\n\n            if (!bypassMap) {\n                t = tMapLightness(t);  // lightness correction\n            }\n\n            if (_gamma !== 1) { t = pow$5(t, _gamma); }\n\n            t = _padding[0] + (t * (1 - _padding[0] - _padding[1]));\n\n            t = Math.min(1, Math.max(0, t));\n\n            var k = Math.floor(t * 10000);\n\n            if (_useCache && _colorCache[k]) {\n                col = _colorCache[k];\n            } else {\n                if (type$j(_colors) === 'array') {\n                    //for i in [0.._pos.length-1]\n                    for (var i=0; i<_pos.length; i++) {\n                        var p = _pos[i];\n                        if (t <= p) {\n                            col = _colors[i];\n                            break;\n                        }\n                        if ((t >= p) && (i === (_pos.length-1))) {\n                            col = _colors[i];\n                            break;\n                        }\n                        if (t > p && t < _pos[i+1]) {\n                            t = (t-p)/(_pos[i+1]-p);\n                            col = chroma_1.interpolate(_colors[i], _colors[i+1], t, _mode);\n                            break;\n                        }\n                    }\n                } else if (type$j(_colors) === 'function') {\n                    col = _colors(t);\n                }\n                if (_useCache) { _colorCache[k] = col; }\n            }\n            return col;\n        };\n\n        var resetCache = function () { return _colorCache = {}; };\n\n        setColors(colors);\n\n        // public interface\n\n        var f = function(v) {\n            var c = chroma_1(getColor(v));\n            if (_out && c[_out]) { return c[_out](); } else { return c; }\n        };\n\n        f.classes = function(classes) {\n            if (classes != null) {\n                if (type$j(classes) === 'array') {\n                    _classes = classes;\n                    _domain = [classes[0], classes[classes.length-1]];\n                } else {\n                    var d = chroma_1.analyze(_domain);\n                    if (classes === 0) {\n                        _classes = [d.min, d.max];\n                    } else {\n                        _classes = chroma_1.limits(d, 'e', classes);\n                    }\n                }\n                return f;\n            }\n            return _classes;\n        };\n\n\n        f.domain = function(domain) {\n            if (!arguments.length) {\n                return _domain;\n            }\n            _min = domain[0];\n            _max = domain[domain.length-1];\n            _pos = [];\n            var k = _colors.length;\n            if ((domain.length === k) && (_min !== _max)) {\n                // update positions\n                for (var i = 0, list = Array.from(domain); i < list.length; i += 1) {\n                    var d = list[i];\n\n                  _pos.push((d-_min) / (_max-_min));\n                }\n            } else {\n                for (var c=0; c<k; c++) {\n                    _pos.push(c/(k-1));\n                }\n                if (domain.length > 2) {\n                    // set domain map\n                    var tOut = domain.map(function (d,i) { return i/(domain.length-1); });\n                    var tBreaks = domain.map(function (d) { return (d - _min) / (_max - _min); });\n                    if (!tBreaks.every(function (val, i) { return tOut[i] === val; })) {\n                        tMapDomain = function (t) {\n                            if (t <= 0 || t >= 1) { return t; }\n                            var i = 0;\n                            while (t >= tBreaks[i+1]) { i++; }\n                            var f = (t - tBreaks[i]) / (tBreaks[i+1] - tBreaks[i]);\n                            var out = tOut[i] + f * (tOut[i+1] - tOut[i]);\n                            return out;\n                        };\n                    }\n\n                }\n            }\n            _domain = [_min, _max];\n            return f;\n        };\n\n        f.mode = function(_m) {\n            if (!arguments.length) {\n                return _mode;\n            }\n            _mode = _m;\n            resetCache();\n            return f;\n        };\n\n        f.range = function(colors, _pos) {\n            setColors(colors, _pos);\n            return f;\n        };\n\n        f.out = function(_o) {\n            _out = _o;\n            return f;\n        };\n\n        f.spread = function(val) {\n            if (!arguments.length) {\n                return _spread;\n            }\n            _spread = val;\n            return f;\n        };\n\n        f.correctLightness = function(v) {\n            if (v == null) { v = true; }\n            _correctLightness = v;\n            resetCache();\n            if (_correctLightness) {\n                tMapLightness = function(t) {\n                    var L0 = getColor(0, true).lab()[0];\n                    var L1 = getColor(1, true).lab()[0];\n                    var pol = L0 > L1;\n                    var L_actual = getColor(t, true).lab()[0];\n                    var L_ideal = L0 + ((L1 - L0) * t);\n                    var L_diff = L_actual - L_ideal;\n                    var t0 = 0;\n                    var t1 = 1;\n                    var max_iter = 20;\n                    while ((Math.abs(L_diff) > 1e-2) && (max_iter-- > 0)) {\n                        (function() {\n                            if (pol) { L_diff *= -1; }\n                            if (L_diff < 0) {\n                                t0 = t;\n                                t += (t1 - t) * 0.5;\n                            } else {\n                                t1 = t;\n                                t += (t0 - t) * 0.5;\n                            }\n                            L_actual = getColor(t, true).lab()[0];\n                            return L_diff = L_actual - L_ideal;\n                        })();\n                    }\n                    return t;\n                };\n            } else {\n                tMapLightness = function (t) { return t; };\n            }\n            return f;\n        };\n\n        f.padding = function(p) {\n            if (p != null) {\n                if (type$j(p) === 'number') {\n                    p = [p,p];\n                }\n                _padding = p;\n                return f;\n            } else {\n                return _padding;\n            }\n        };\n\n        f.colors = function(numColors, out) {\n            // If no arguments are given, return the original colors that were provided\n            if (arguments.length < 2) { out = 'hex'; }\n            var result = [];\n\n            if (arguments.length === 0) {\n                result = _colors.slice(0);\n\n            } else if (numColors === 1) {\n                result = [f(0.5)];\n\n            } else if (numColors > 1) {\n                var dm = _domain[0];\n                var dd = _domain[1] - dm;\n                result = __range__(0, numColors, false).map(function (i) { return f( dm + ((i/(numColors-1)) * dd) ); });\n\n            } else { // returns all colors based on the defined classes\n                colors = [];\n                var samples = [];\n                if (_classes && (_classes.length > 2)) {\n                    for (var i = 1, end = _classes.length, asc = 1 <= end; asc ? i < end : i > end; asc ? i++ : i--) {\n                        samples.push((_classes[i-1]+_classes[i])*0.5);\n                    }\n                } else {\n                    samples = _domain;\n                }\n                result = samples.map(function (v) { return f(v); });\n            }\n\n            if (chroma_1[out]) {\n                result = result.map(function (c) { return c[out](); });\n            }\n            return result;\n        };\n\n        f.cache = function(c) {\n            if (c != null) {\n                _useCache = c;\n                return f;\n            } else {\n                return _useCache;\n            }\n        };\n\n        f.gamma = function(g) {\n            if (g != null) {\n                _gamma = g;\n                return f;\n            } else {\n                return _gamma;\n            }\n        };\n\n        f.nodata = function(d) {\n            if (d != null) {\n                _nacol = chroma_1(d);\n                return f;\n            } else {\n                return _nacol;\n            }\n        };\n\n        return f;\n    };\n\n    function __range__(left, right, inclusive) {\n      var range = [];\n      var ascending = left < right;\n      var end = !inclusive ? right : ascending ? right + 1 : right - 1;\n      for (var i = left; ascending ? i < end : i > end; ascending ? i++ : i--) {\n        range.push(i);\n      }\n      return range;\n    }\n\n    //\n    // interpolates between a set of colors uzing a bezier spline\n    //\n\n    // @requires utils lab\n\n\n\n\n    var bezier = function(colors) {\n        var assign, assign$1, assign$2;\n\n        var I, lab0, lab1, lab2;\n        colors = colors.map(function (c) { return new Color_1(c); });\n        if (colors.length === 2) {\n            // linear interpolation\n            (assign = colors.map(function (c) { return c.lab(); }), lab0 = assign[0], lab1 = assign[1]);\n            I = function(t) {\n                var lab = ([0, 1, 2].map(function (i) { return lab0[i] + (t * (lab1[i] - lab0[i])); }));\n                return new Color_1(lab, 'lab');\n            };\n        } else if (colors.length === 3) {\n            // quadratic bezier interpolation\n            (assign$1 = colors.map(function (c) { return c.lab(); }), lab0 = assign$1[0], lab1 = assign$1[1], lab2 = assign$1[2]);\n            I = function(t) {\n                var lab = ([0, 1, 2].map(function (i) { return ((1-t)*(1-t) * lab0[i]) + (2 * (1-t) * t * lab1[i]) + (t * t * lab2[i]); }));\n                return new Color_1(lab, 'lab');\n            };\n        } else if (colors.length === 4) {\n            // cubic bezier interpolation\n            var lab3;\n            (assign$2 = colors.map(function (c) { return c.lab(); }), lab0 = assign$2[0], lab1 = assign$2[1], lab2 = assign$2[2], lab3 = assign$2[3]);\n            I = function(t) {\n                var lab = ([0, 1, 2].map(function (i) { return ((1-t)*(1-t)*(1-t) * lab0[i]) + (3 * (1-t) * (1-t) * t * lab1[i]) + (3 * (1-t) * t * t * lab2[i]) + (t*t*t * lab3[i]); }));\n                return new Color_1(lab, 'lab');\n            };\n        } else if (colors.length === 5) {\n            var I0 = bezier(colors.slice(0, 3));\n            var I1 = bezier(colors.slice(2, 5));\n            I = function(t) {\n                if (t < 0.5) {\n                    return I0(t*2);\n                } else {\n                    return I1((t-0.5)*2);\n                }\n            };\n        }\n        return I;\n    };\n\n    var bezier_1 = function (colors) {\n        var f = bezier(colors);\n        f.scale = function () { return scale(f); };\n        return f;\n    };\n\n    /*\n     * interpolates between a set of colors uzing a bezier spline\n     * blend mode formulas taken from http://www.venture-ware.com/kevin/coding/lets-learn-math-photoshop-blend-modes/\n     */\n\n\n\n\n    var blend = function (bottom, top, mode) {\n        if (!blend[mode]) {\n            throw new Error('unknown blend mode ' + mode);\n        }\n        return blend[mode](bottom, top);\n    };\n\n    var blend_f = function (f) { return function (bottom,top) {\n            var c0 = chroma_1(top).rgb();\n            var c1 = chroma_1(bottom).rgb();\n            return chroma_1.rgb(f(c0, c1));\n        }; };\n\n    var each = function (f) { return function (c0, c1) {\n            var out = [];\n            out[0] = f(c0[0], c1[0]);\n            out[1] = f(c0[1], c1[1]);\n            out[2] = f(c0[2], c1[2]);\n            return out;\n        }; };\n\n    var normal = function (a) { return a; };\n    var multiply = function (a,b) { return a * b / 255; };\n    var darken$1 = function (a,b) { return a > b ? b : a; };\n    var lighten = function (a,b) { return a > b ? a : b; };\n    var screen = function (a,b) { return 255 * (1 - (1-a/255) * (1-b/255)); };\n    var overlay = function (a,b) { return b < 128 ? 2 * a * b / 255 : 255 * (1 - 2 * (1 - a / 255 ) * ( 1 - b / 255 )); };\n    var burn = function (a,b) { return 255 * (1 - (1 - b / 255) / (a/255)); };\n    var dodge = function (a,b) {\n        if (a === 255) { return 255; }\n        a = 255 * (b / 255) / (1 - a / 255);\n        return a > 255 ? 255 : a\n    };\n\n    // # add = (a,b) ->\n    // #     if (a + b > 255) then 255 else a + b\n\n    blend.normal = blend_f(each(normal));\n    blend.multiply = blend_f(each(multiply));\n    blend.screen = blend_f(each(screen));\n    blend.overlay = blend_f(each(overlay));\n    blend.darken = blend_f(each(darken$1));\n    blend.lighten = blend_f(each(lighten));\n    blend.dodge = blend_f(each(dodge));\n    blend.burn = blend_f(each(burn));\n    // blend.add = blend_f(each(add));\n\n    var blend_1 = blend;\n\n    // cubehelix interpolation\n    // based on D.A. Green \"A colour scheme for the display of astronomical intensity images\"\n    // http://astron-soc.in/bulletin/11June/289392011.pdf\n\n    var type$k = utils.type;\n    var clip_rgb$3 = utils.clip_rgb;\n    var TWOPI$2 = utils.TWOPI;\n    var pow$6 = Math.pow;\n    var sin$2 = Math.sin;\n    var cos$3 = Math.cos;\n\n\n    var cubehelix = function(start, rotations, hue, gamma, lightness) {\n        if ( start === void 0 ) start=300;\n        if ( rotations === void 0 ) rotations=-1.5;\n        if ( hue === void 0 ) hue=1;\n        if ( gamma === void 0 ) gamma=1;\n        if ( lightness === void 0 ) lightness=[0,1];\n\n        var dh = 0, dl;\n        if (type$k(lightness) === 'array') {\n            dl = lightness[1] - lightness[0];\n        } else {\n            dl = 0;\n            lightness = [lightness, lightness];\n        }\n\n        var f = function(fract) {\n            var a = TWOPI$2 * (((start+120)/360) + (rotations * fract));\n            var l = pow$6(lightness[0] + (dl * fract), gamma);\n            var h = dh !== 0 ? hue[0] + (fract * dh) : hue;\n            var amp = (h * l * (1-l)) / 2;\n            var cos_a = cos$3(a);\n            var sin_a = sin$2(a);\n            var r = l + (amp * ((-0.14861 * cos_a) + (1.78277* sin_a)));\n            var g = l + (amp * ((-0.29227 * cos_a) - (0.90649* sin_a)));\n            var b = l + (amp * (+1.97294 * cos_a));\n            return chroma_1(clip_rgb$3([r*255,g*255,b*255,1]));\n        };\n\n        f.start = function(s) {\n            if ((s == null)) { return start; }\n            start = s;\n            return f;\n        };\n\n        f.rotations = function(r) {\n            if ((r == null)) { return rotations; }\n            rotations = r;\n            return f;\n        };\n\n        f.gamma = function(g) {\n            if ((g == null)) { return gamma; }\n            gamma = g;\n            return f;\n        };\n\n        f.hue = function(h) {\n            if ((h == null)) { return hue; }\n            hue = h;\n            if (type$k(hue) === 'array') {\n                dh = hue[1] - hue[0];\n                if (dh === 0) { hue = hue[1]; }\n            } else {\n                dh = 0;\n            }\n            return f;\n        };\n\n        f.lightness = function(h) {\n            if ((h == null)) { return lightness; }\n            if (type$k(h) === 'array') {\n                lightness = h;\n                dl = h[1] - h[0];\n            } else {\n                lightness = [h,h];\n                dl = 0;\n            }\n            return f;\n        };\n\n        f.scale = function () { return chroma_1.scale(f); };\n\n        f.hue(hue);\n\n        return f;\n    };\n\n    var digits = '0123456789abcdef';\n\n    var floor$2 = Math.floor;\n    var random = Math.random;\n\n    var random_1 = function () {\n        var code = '#';\n        for (var i=0; i<6; i++) {\n            code += digits.charAt(floor$2(random() * 16));\n        }\n        return new Color_1(code, 'hex');\n    };\n\n    var log$1 = Math.log;\n    var pow$7 = Math.pow;\n    var floor$3 = Math.floor;\n    var abs = Math.abs;\n\n\n    var analyze = function (data, key) {\n        if ( key === void 0 ) key=null;\n\n        var r = {\n            min: Number.MAX_VALUE,\n            max: Number.MAX_VALUE*-1,\n            sum: 0,\n            values: [],\n            count: 0\n        };\n        if (type(data) === 'object') {\n            data = Object.values(data);\n        }\n        data.forEach(function (val) {\n            if (key && type(val) === 'object') { val = val[key]; }\n            if (val !== undefined && val !== null && !isNaN(val)) {\n                r.values.push(val);\n                r.sum += val;\n                if (val < r.min) { r.min = val; }\n                if (val > r.max) { r.max = val; }\n                r.count += 1;\n            }\n        });\n\n        r.domain = [r.min, r.max];\n\n        r.limits = function (mode, num) { return limits(r, mode, num); };\n\n        return r;\n    };\n\n\n    var limits = function (data, mode, num) {\n        if ( mode === void 0 ) mode='equal';\n        if ( num === void 0 ) num=7;\n\n        if (type(data) == 'array') {\n            data = analyze(data);\n        }\n        var min = data.min;\n        var max = data.max;\n        var values = data.values.sort(function (a,b) { return a-b; });\n\n        if (num === 1) { return [min,max]; }\n\n        var limits = [];\n\n        if (mode.substr(0,1) === 'c') { // continuous\n            limits.push(min);\n            limits.push(max);\n        }\n\n        if (mode.substr(0,1) === 'e') { // equal interval\n            limits.push(min);\n            for (var i=1; i<num; i++) {\n                limits.push(min+((i/num)*(max-min)));\n            }\n            limits.push(max);\n        }\n\n        else if (mode.substr(0,1) === 'l') { // log scale\n            if (min <= 0) {\n                throw new Error('Logarithmic scales are only possible for values > 0');\n            }\n            var min_log = Math.LOG10E * log$1(min);\n            var max_log = Math.LOG10E * log$1(max);\n            limits.push(min);\n            for (var i$1=1; i$1<num; i$1++) {\n                limits.push(pow$7(10, min_log + ((i$1/num) * (max_log - min_log))));\n            }\n            limits.push(max);\n        }\n\n        else if (mode.substr(0,1) === 'q') { // quantile scale\n            limits.push(min);\n            for (var i$2=1; i$2<num; i$2++) {\n                var p = ((values.length-1) * i$2)/num;\n                var pb = floor$3(p);\n                if (pb === p) {\n                    limits.push(values[pb]);\n                } else { // p > pb\n                    var pr = p - pb;\n                    limits.push((values[pb]*(1-pr)) + (values[pb+1]*pr));\n                }\n            }\n            limits.push(max);\n\n        }\n\n        else if (mode.substr(0,1) === 'k') { // k-means clustering\n            /*\n            implementation based on\n            http://code.google.com/p/figue/source/browse/trunk/figue.js#336\n            simplified for 1-d input values\n            */\n            var cluster;\n            var n = values.length;\n            var assignments = new Array(n);\n            var clusterSizes = new Array(num);\n            var repeat = true;\n            var nb_iters = 0;\n            var centroids = null;\n\n            // get seed values\n            centroids = [];\n            centroids.push(min);\n            for (var i$3=1; i$3<num; i$3++) {\n                centroids.push(min + ((i$3/num) * (max-min)));\n            }\n            centroids.push(max);\n\n            while (repeat) {\n                // assignment step\n                for (var j=0; j<num; j++) {\n                    clusterSizes[j] = 0;\n                }\n                for (var i$4=0; i$4<n; i$4++) {\n                    var value = values[i$4];\n                    var mindist = Number.MAX_VALUE;\n                    var best = (void 0);\n                    for (var j$1=0; j$1<num; j$1++) {\n                        var dist = abs(centroids[j$1]-value);\n                        if (dist < mindist) {\n                            mindist = dist;\n                            best = j$1;\n                        }\n                        clusterSizes[best]++;\n                        assignments[i$4] = best;\n                    }\n                }\n\n                // update centroids step\n                var newCentroids = new Array(num);\n                for (var j$2=0; j$2<num; j$2++) {\n                    newCentroids[j$2] = null;\n                }\n                for (var i$5=0; i$5<n; i$5++) {\n                    cluster = assignments[i$5];\n                    if (newCentroids[cluster] === null) {\n                        newCentroids[cluster] = values[i$5];\n                    } else {\n                        newCentroids[cluster] += values[i$5];\n                    }\n                }\n                for (var j$3=0; j$3<num; j$3++) {\n                    newCentroids[j$3] *= 1/clusterSizes[j$3];\n                }\n\n                // check convergence\n                repeat = false;\n                for (var j$4=0; j$4<num; j$4++) {\n                    if (newCentroids[j$4] !== centroids[j$4]) {\n                        repeat = true;\n                        break;\n                    }\n                }\n\n                centroids = newCentroids;\n                nb_iters++;\n\n                if (nb_iters > 200) {\n                    repeat = false;\n                }\n            }\n\n            // finished k-means clustering\n            // the next part is borrowed from gabrielflor.it\n            var kClusters = {};\n            for (var j$5=0; j$5<num; j$5++) {\n                kClusters[j$5] = [];\n            }\n            for (var i$6=0; i$6<n; i$6++) {\n                cluster = assignments[i$6];\n                kClusters[cluster].push(values[i$6]);\n            }\n            var tmpKMeansBreaks = [];\n            for (var j$6=0; j$6<num; j$6++) {\n                tmpKMeansBreaks.push(kClusters[j$6][0]);\n                tmpKMeansBreaks.push(kClusters[j$6][kClusters[j$6].length-1]);\n            }\n            tmpKMeansBreaks = tmpKMeansBreaks.sort(function (a,b){ return a-b; });\n            limits.push(tmpKMeansBreaks[0]);\n            for (var i$7=1; i$7 < tmpKMeansBreaks.length; i$7+= 2) {\n                var v = tmpKMeansBreaks[i$7];\n                if (!isNaN(v) && (limits.indexOf(v) === -1)) {\n                    limits.push(v);\n                }\n            }\n        }\n        return limits;\n    };\n\n    var analyze_1 = {analyze: analyze, limits: limits};\n\n    var contrast = function (a, b) {\n        // WCAG contrast ratio\n        // see http://www.w3.org/TR/2008/REC-WCAG20-20081211/#contrast-ratiodef\n        a = new Color_1(a);\n        b = new Color_1(b);\n        var l1 = a.luminance();\n        var l2 = b.luminance();\n        return l1 > l2 ? (l1 + 0.05) / (l2 + 0.05) : (l2 + 0.05) / (l1 + 0.05);\n    };\n\n    var sqrt$4 = Math.sqrt;\n    var atan2$2 = Math.atan2;\n    var abs$1 = Math.abs;\n    var cos$4 = Math.cos;\n    var PI$2 = Math.PI;\n\n    var deltaE = function(a, b, L, C) {\n        if ( L === void 0 ) L=1;\n        if ( C === void 0 ) C=1;\n\n        // Delta E (CMC)\n        // see http://www.brucelindbloom.com/index.html?Eqn_DeltaE_CMC.html\n        a = new Color_1(a);\n        b = new Color_1(b);\n        var ref = Array.from(a.lab());\n        var L1 = ref[0];\n        var a1 = ref[1];\n        var b1 = ref[2];\n        var ref$1 = Array.from(b.lab());\n        var L2 = ref$1[0];\n        var a2 = ref$1[1];\n        var b2 = ref$1[2];\n        var c1 = sqrt$4((a1 * a1) + (b1 * b1));\n        var c2 = sqrt$4((a2 * a2) + (b2 * b2));\n        var sl = L1 < 16.0 ? 0.511 : (0.040975 * L1) / (1.0 + (0.01765 * L1));\n        var sc = ((0.0638 * c1) / (1.0 + (0.0131 * c1))) + 0.638;\n        var h1 = c1 < 0.000001 ? 0.0 : (atan2$2(b1, a1) * 180.0) / PI$2;\n        while (h1 < 0) { h1 += 360; }\n        while (h1 >= 360) { h1 -= 360; }\n        var t = (h1 >= 164.0) && (h1 <= 345.0) ? (0.56 + abs$1(0.2 * cos$4((PI$2 * (h1 + 168.0)) / 180.0))) : (0.36 + abs$1(0.4 * cos$4((PI$2 * (h1 + 35.0)) / 180.0)));\n        var c4 = c1 * c1 * c1 * c1;\n        var f = sqrt$4(c4 / (c4 + 1900.0));\n        var sh = sc * (((f * t) + 1.0) - f);\n        var delL = L1 - L2;\n        var delC = c1 - c2;\n        var delA = a1 - a2;\n        var delB = b1 - b2;\n        var dH2 = ((delA * delA) + (delB * delB)) - (delC * delC);\n        var v1 = delL / (L * sl);\n        var v2 = delC / (C * sc);\n        var v3 = sh;\n        return sqrt$4((v1 * v1) + (v2 * v2) + (dH2 / (v3 * v3)));\n    };\n\n    // simple Euclidean distance\n    var distance = function(a, b, mode) {\n        if ( mode === void 0 ) mode='lab';\n\n        // Delta E (CIE 1976)\n        // see http://www.brucelindbloom.com/index.html?Equations.html\n        a = new Color_1(a);\n        b = new Color_1(b);\n        var l1 = a.get(mode);\n        var l2 = b.get(mode);\n        var sum_sq = 0;\n        for (var i in l1) {\n            var d = (l1[i] || 0) - (l2[i] || 0);\n            sum_sq += d*d;\n        }\n        return Math.sqrt(sum_sq);\n    };\n\n    var valid = function () {\n        var args = [], len = arguments.length;\n        while ( len-- ) args[ len ] = arguments[ len ];\n\n        try {\n            new (Function.prototype.bind.apply( Color_1, [ null ].concat( args) ));\n            return true;\n        } catch (e) {\n            return false;\n        }\n    };\n\n    // some pre-defined color scales:\n\n\n\n\n    var scales = {\n    \tcool: function cool() { return scale([chroma_1.hsl(180,1,.9), chroma_1.hsl(250,.7,.4)]) },\n    \thot: function hot() { return scale(['#000','#f00','#ff0','#fff'], [0,.25,.75,1]).mode('rgb') }\n    };\n\n    /**\n        ColorBrewer colors for chroma.js\n\n        Copyright (c) 2002 Cynthia Brewer, Mark Harrower, and The\n        Pennsylvania State University.\n\n        Licensed under the Apache License, Version 2.0 (the \"License\");\n        you may not use this file except in compliance with the License.\n        You may obtain a copy of the License at\n        http://www.apache.org/licenses/LICENSE-2.0\n\n        Unless required by applicable law or agreed to in writing, software distributed\n        under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR\n        CONDITIONS OF ANY KIND, either express or implied. See the License for the\n        specific language governing permissions and limitations under the License.\n    */\n\n    var colorbrewer = {\n        // sequential\n        OrRd: ['#fff7ec', '#fee8c8', '#fdd49e', '#fdbb84', '#fc8d59', '#ef6548', '#d7301f', '#b30000', '#7f0000'],\n        PuBu: ['#fff7fb', '#ece7f2', '#d0d1e6', '#a6bddb', '#74a9cf', '#3690c0', '#0570b0', '#045a8d', '#023858'],\n        BuPu: ['#f7fcfd', '#e0ecf4', '#bfd3e6', '#9ebcda', '#8c96c6', '#8c6bb1', '#88419d', '#810f7c', '#4d004b'],\n        Oranges: ['#fff5eb', '#fee6ce', '#fdd0a2', '#fdae6b', '#fd8d3c', '#f16913', '#d94801', '#a63603', '#7f2704'],\n        BuGn: ['#f7fcfd', '#e5f5f9', '#ccece6', '#99d8c9', '#66c2a4', '#41ae76', '#238b45', '#006d2c', '#00441b'],\n        YlOrBr: ['#ffffe5', '#fff7bc', '#fee391', '#fec44f', '#fe9929', '#ec7014', '#cc4c02', '#993404', '#662506'],\n        YlGn: ['#ffffe5', '#f7fcb9', '#d9f0a3', '#addd8e', '#78c679', '#41ab5d', '#238443', '#006837', '#004529'],\n        Reds: ['#fff5f0', '#fee0d2', '#fcbba1', '#fc9272', '#fb6a4a', '#ef3b2c', '#cb181d', '#a50f15', '#67000d'],\n        RdPu: ['#fff7f3', '#fde0dd', '#fcc5c0', '#fa9fb5', '#f768a1', '#dd3497', '#ae017e', '#7a0177', '#49006a'],\n        Greens: ['#f7fcf5', '#e5f5e0', '#c7e9c0', '#a1d99b', '#74c476', '#41ab5d', '#238b45', '#006d2c', '#00441b'],\n        YlGnBu: ['#ffffd9', '#edf8b1', '#c7e9b4', '#7fcdbb', '#41b6c4', '#1d91c0', '#225ea8', '#253494', '#081d58'],\n        Purples: ['#fcfbfd', '#efedf5', '#dadaeb', '#bcbddc', '#9e9ac8', '#807dba', '#6a51a3', '#54278f', '#3f007d'],\n        GnBu: ['#f7fcf0', '#e0f3db', '#ccebc5', '#a8ddb5', '#7bccc4', '#4eb3d3', '#2b8cbe', '#0868ac', '#084081'],\n        Greys: ['#ffffff', '#f0f0f0', '#d9d9d9', '#bdbdbd', '#969696', '#737373', '#525252', '#252525', '#000000'],\n        YlOrRd: ['#ffffcc', '#ffeda0', '#fed976', '#feb24c', '#fd8d3c', '#fc4e2a', '#e31a1c', '#bd0026', '#800026'],\n        PuRd: ['#f7f4f9', '#e7e1ef', '#d4b9da', '#c994c7', '#df65b0', '#e7298a', '#ce1256', '#980043', '#67001f'],\n        Blues: ['#f7fbff', '#deebf7', '#c6dbef', '#9ecae1', '#6baed6', '#4292c6', '#2171b5', '#08519c', '#08306b'],\n        PuBuGn: ['#fff7fb', '#ece2f0', '#d0d1e6', '#a6bddb', '#67a9cf', '#3690c0', '#02818a', '#016c59', '#014636'],\n        Viridis: ['#440154', '#482777', '#3f4a8a', '#31678e', '#26838f', '#1f9d8a', '#6cce5a', '#b6de2b', '#fee825'],\n\n        // diverging\n\n        Spectral: ['#9e0142', '#d53e4f', '#f46d43', '#fdae61', '#fee08b', '#ffffbf', '#e6f598', '#abdda4', '#66c2a5', '#3288bd', '#5e4fa2'],\n        RdYlGn: ['#a50026', '#d73027', '#f46d43', '#fdae61', '#fee08b', '#ffffbf', '#d9ef8b', '#a6d96a', '#66bd63', '#1a9850', '#006837'],\n        RdBu: ['#67001f', '#b2182b', '#d6604d', '#f4a582', '#fddbc7', '#f7f7f7', '#d1e5f0', '#92c5de', '#4393c3', '#2166ac', '#053061'],\n        PiYG: ['#8e0152', '#c51b7d', '#de77ae', '#f1b6da', '#fde0ef', '#f7f7f7', '#e6f5d0', '#b8e186', '#7fbc41', '#4d9221', '#276419'],\n        PRGn: ['#40004b', '#762a83', '#9970ab', '#c2a5cf', '#e7d4e8', '#f7f7f7', '#d9f0d3', '#a6dba0', '#5aae61', '#1b7837', '#00441b'],\n        RdYlBu: ['#a50026', '#d73027', '#f46d43', '#fdae61', '#fee090', '#ffffbf', '#e0f3f8', '#abd9e9', '#74add1', '#4575b4', '#313695'],\n        BrBG: ['#543005', '#8c510a', '#bf812d', '#dfc27d', '#f6e8c3', '#f5f5f5', '#c7eae5', '#80cdc1', '#35978f', '#01665e', '#003c30'],\n        RdGy: ['#67001f', '#b2182b', '#d6604d', '#f4a582', '#fddbc7', '#ffffff', '#e0e0e0', '#bababa', '#878787', '#4d4d4d', '#1a1a1a'],\n        PuOr: ['#7f3b08', '#b35806', '#e08214', '#fdb863', '#fee0b6', '#f7f7f7', '#d8daeb', '#b2abd2', '#8073ac', '#542788', '#2d004b'],\n\n        // qualitative\n\n        Set2: ['#66c2a5', '#fc8d62', '#8da0cb', '#e78ac3', '#a6d854', '#ffd92f', '#e5c494', '#b3b3b3'],\n        Accent: ['#7fc97f', '#beaed4', '#fdc086', '#ffff99', '#386cb0', '#f0027f', '#bf5b17', '#666666'],\n        Set1: ['#e41a1c', '#377eb8', '#4daf4a', '#984ea3', '#ff7f00', '#ffff33', '#a65628', '#f781bf', '#999999'],\n        Set3: ['#8dd3c7', '#ffffb3', '#bebada', '#fb8072', '#80b1d3', '#fdb462', '#b3de69', '#fccde5', '#d9d9d9', '#bc80bd', '#ccebc5', '#ffed6f'],\n        Dark2: ['#1b9e77', '#d95f02', '#7570b3', '#e7298a', '#66a61e', '#e6ab02', '#a6761d', '#666666'],\n        Paired: ['#a6cee3', '#1f78b4', '#b2df8a', '#33a02c', '#fb9a99', '#e31a1c', '#fdbf6f', '#ff7f00', '#cab2d6', '#6a3d9a', '#ffff99', '#b15928'],\n        Pastel2: ['#b3e2cd', '#fdcdac', '#cbd5e8', '#f4cae4', '#e6f5c9', '#fff2ae', '#f1e2cc', '#cccccc'],\n        Pastel1: ['#fbb4ae', '#b3cde3', '#ccebc5', '#decbe4', '#fed9a6', '#ffffcc', '#e5d8bd', '#fddaec', '#f2f2f2'],\n    };\n\n    // add lowercase aliases for case-insensitive matches\n    for (var i$1 = 0, list$1 = Object.keys(colorbrewer); i$1 < list$1.length; i$1 += 1) {\n        var key = list$1[i$1];\n\n        colorbrewer[key.toLowerCase()] = colorbrewer[key];\n    }\n\n    var colorbrewer_1 = colorbrewer;\n\n    // feel free to comment out anything to rollup\n    // a smaller chroma.js built\n\n    // io --\x3e convert colors\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    // operators --\x3e modify existing Colors\n\n\n\n\n\n\n\n\n\n\n    // interpolators\n\n\n\n\n\n\n\n\n\n\n    // generators -- > create new colors\n    chroma_1.average = average;\n    chroma_1.bezier = bezier_1;\n    chroma_1.blend = blend_1;\n    chroma_1.cubehelix = cubehelix;\n    chroma_1.mix = chroma_1.interpolate = mix;\n    chroma_1.random = random_1;\n    chroma_1.scale = scale;\n\n    // other utility methods\n    chroma_1.analyze = analyze_1.analyze;\n    chroma_1.contrast = contrast;\n    chroma_1.deltaE = deltaE;\n    chroma_1.distance = distance;\n    chroma_1.limits = analyze_1.limits;\n    chroma_1.valid = valid;\n\n    // scale\n    chroma_1.scales = scales;\n\n    // colors\n    chroma_1.colors = w3cx11_1;\n    chroma_1.brewer = colorbrewer_1;\n\n    var chroma_js = chroma_1;\n\n    return chroma_js;\n\n})));\n\n\n//# sourceURL=webpack://ColorRick/./node_modules/chroma-js/chroma.js?")
            }
        };
        var __webpack_module_cache__ = {};

        function __webpack_require__(e) {
            var t = __webpack_module_cache__[e];
            if (t !== undefined) {
                return t.exports
            }
            var n = __webpack_module_cache__[e] = {
                exports: {}
            };
            __webpack_modules__[e].call(n.exports, n, n.exports, __webpack_require__);
            return n.exports
        }
        var __webpack_exports__ = __webpack_require__("./index.js");
        return __webpack_exports__
    })()
});
(() => {
    "use strict";
    CGL.ShaderModifier = class {
        constructor(e, t, n) {
            this._cgl = e, this._name = t, this._origShaders = {}, this._uniforms = [], this._structUniforms = [], this._definesToggled = {}, this._defines = {}, this._mods = [], this._textures = [], this._boundShader = null, this._changedDefines = !0, this._changedUniforms = !0, this._modulesChanged = !1, this.needsTexturePush = !1, this._lastShader = null, this._attributes = [], 1 == this._cgl.glVersion && (this._cgl.enableExtension("OES_texture_float"), this._cgl.enableExtension("OES_texture_float_linear"), this._cgl.enableExtension("OES_texture_half_float"), this._cgl.enableExtension("OES_texture_half_float_linear"))
        }
        bind(t, n) {
            const i = t || this._cgl.getShader();
            if (!i) return;
            this._boundShader = this._origShaders[i.id];
            let s = !1;
            if (this._boundShader && this._lastShader != this._boundShader.shader && (this._boundShader.shader.hasModule(this._mods[0].id) || (s = !0)), (s || !this._boundShader || i.lastCompile != this._boundShader.lastCompile || this._modulesChanged || i._needsRecompile) && (this._boundShader && this._boundShader.shader.dispose(), i._needsRecompile && i.compile(), this._boundShader = this._origShaders[i.id] = {
                    lastCompile: i.lastCompile,
                    orig: i,
                    shader: i.copy()
                }, 1 == this._cgl.glVersion && (this._boundShader.shader.enableExtension("GL_OES_standard_derivatives"), this._boundShader.shader.enableExtension("GL_OES_texture_float"), this._boundShader.shader.enableExtension("GL_OES_texture_float_linear"), this._boundShader.shader.enableExtension("GL_OES_texture_half_float"), this._boundShader.shader.enableExtension("GL_OES_texture_half_float_linear")), this._addModulesToShader(this._boundShader.shader), this._updateDefinesShader(this._boundShader.shader), this._updateUniformsShader(this._boundShader.shader)), this._boundShader.wireframe = i.wireframe, this._changedDefines && this._updateDefines(), this._changedUniforms && this._updateUniforms(), !1 !== n && this._cgl.pushShader(this._boundShader.shader), this._boundShader.shader.copyUniformValues(this._boundShader.orig), this.needsTexturePush) {
                for (let e = 0; e < this._textures.length; e += 1) {
                    const n = this._textures[e][0],
                        i = this._textures[e][1],
                        s = this._textures[e][2];
                    if (this._getUniform(n)) {
                        const t = this.getPrefixedName(n),
                            r = this._boundShader.shader.getUniform(t);
                        r && this._boundShader.shader.pushTexture(r, i, s)
                    }
                }
                this.needsTexturePush = !1, this._textures.length = 0
            }
            return this._modulesChanged = !1, this._boundShader.shader.fromMod = this, this.onBind && this.onBind(this._boundShader.shader), this._boundShader.shader
        }
        unbind(e) {
            this._boundShader && !1 !== e && this._cgl.popShader(), this._boundShader = null
        }
        _addModulesToShader(t) {
            let n;
            this._mods.length > 1 && (n = this._mods[0]);
            for (let e = 0; e < this._mods.length; e++) t.addModule(this._mods[e], n)
        }
        _removeModulesFromShader(e) {
            for (const t in this._origShaders) this._origShaders[t].shader.removeModule(e)
        }
        addModule(e) {
            this._mods.push(e), this._modulesChanged = !0
        }
        removeModule(t) {
            const n = [];
            let i = !1;
            for (let e = 0; e < this._mods.length; e++) this._mods[e].title == t && (i = !0, this._removeModulesFromShader(this._mods[e]), n.push(e));
            for (let e = n.length - 1; e >= 0; e -= 1) this._mods.splice(n[e], 1);
            this._modulesChanged = !0
        }
        _updateUniformsShader(i) {
            for (let e = 0; e < this._uniforms.length; e++) {
                const s = this._uniforms[e],
                    t = this.getPrefixedName(s.name);
                if (!i.hasUniform(t) && !s.structName) {
                    let e = null;
                    "both" === s.shaderType ? (e = i.addUniformBoth(s.type, t, s.v1, s.v2, s.v3, s.v4), e.comment = "mod: " + this._name) : "frag" === s.shaderType ? (e = i.addUniformFrag(s.type, t, s.v1, s.v2, s.v3, s.v4), e.comment = "mod: " + this._name) : "vert" === s.shaderType && (e = i.addUniformVert(s.type, t, s.v1, s.v2, s.v3, s.v4), e.comment = "mod: " + this._name)
                }
            }
            for (let n = 0; n < this._structUniforms.length; n += 1) {
                const s = this._structUniforms[n];
                let e = s.uniformName,
                    t = s.structName;
                const r = s.members;
                e = this.getPrefixedName(s.uniformName), t = this.getPrefixedName(s.structName), "frag" === s.shaderType && i.addUniformStructFrag(t, e, r), "vert" === s.shaderType && i.addUniformStructVert(t, e, r), "both" === s.shaderType && i.addUniformStructBoth(t, e, r)
            }
        }
        _updateUniforms() {
            for (const e in this._origShaders) this._updateUniformsShader(this._origShaders[e].shader);
            this._changedUniforms = !1
        }
        _setUniformValue(e, t, n) {
            const i = e.getUniform(t);
            i && i.setValue(n)
        }
        setUniformValue(e, t) {
            if (!this._getUniform(e)) return;
            const n = this.getPrefixedName(e);
            for (const e in this._origShaders) this._setUniformValue(this._origShaders[e].shader, n, t)
        }
        hasUniform(e) {
            return this._getUniform(e)
        }
        _getUniform(t) {
            for (let e = 0; e < this._uniforms.length; e++) {
                if (this._uniforms[e].name == t) return this._uniforms[e];
                if (this._uniforms[e].structName && this._uniforms[e].propertyName == t) return this._uniforms[e]
            }
            return !1
        }
        _getStructUniform(t) {
            for (let e = 0; e < this._structUniforms.length; e += 1)
                if (this._structUniforms[e].uniformName === t) return this._structUniforms[e];
            return null
        }
        _isStructUniform(t) {
            for (let e = 0; e < this._uniforms.length; e++) {
                if (this._uniforms[e].name == t) return !1;
                if (this._uniforms[e].structName && this._uniforms[e].propertyName == t) return !0
            }
            return !1
        }
        addUniform(t, n, i, s, r, a, o, l, h, c) {
            if (!this._getUniform(n)) {
                let e = "both";
                c && (e = c), this._uniforms.push({
                    type: t,
                    name: n,
                    v1: i,
                    v2: s,
                    v3: r,
                    v4: a,
                    structUniformName: o,
                    structName: l,
                    propertyName: h,
                    shaderType: e
                }), this._changedUniforms = !0
            }
        }
        addUniformFrag(e, t, n, i, s, r) {
            this.addUniform(e, t, n, i, s, r, null, null, null, "frag"), this._changedUniforms = !0
        }
        addUniformVert(e, t, n, i, s, r) {
            this.addUniform(e, t, n, i, s, r, null, null, null, "vert"), this._changedUniforms = !0
        }
        addUniformBoth(e, t, n, i, s, r) {
            this.addUniform(e, t, n, i, s, r, null, null, null, "both"), this._changedUniforms = !0
        }
        addUniformStruct(t, n, i, s) {
            for (let e = 0; e < i.length; e += 1) {
                const r = i[e];
                "2i" !== r.type && "i" !== r.type && "3i" !== r.type || "both" !== s || console.error("Adding an integer struct member to both shaders can potentially error. Please use different structs for each shader. Error occured in struct:", t, " with member:", r.name, " of type:", r.type, "."), this._getUniform(n + "." + r.name) || this.addUniform(r.type, n + "." + r.name, r.v1, r.v2, r.v3, r.v4, n, t, r.name, s)
            }
            this._getStructUniform(n) || this._structUniforms.push({
                structName: t,
                uniformName: n,
                members: i,
                shaderType: s
            })
        }
        addUniformStructVert(e, t, n) {
            this.addUniformStruct(e, t, n, "vert")
        }
        addUniformStructFrag(e, t, n) {
            this.addUniformStruct(e, t, n, "frag")
        }
        addUniformStructBoth(e, t, n) {
            this.addUniformStruct(e, t, n, "both")
        }
        addAttribute(t) {
            for (let e = 0; e < this._attributes.length; e++)
                if (this._attributes[e].name == t.name && this._attributes[e].nameFrag == t.nameFrag) return;
            this._attributes.push(t)
        }
        pushTexture(e, t, n) {
            if (!t) throw new Error("no texture given to texturestack");
            this._textures.push([e, t, n]), this.needsTexturePush = !0
        }
        _removeUniformFromShader(e, t) {
            t.hasUniform(e) && t.removeUniform(e)
        }
        removeUniform(t) {
            if (this._getUniform(t)) {
                for (let e = this._uniforms.length - 1; e >= 0; e -= 1) {
                    const n = t;
                    if (this._uniforms[e].name == t && !this._uniforms[e].structName) {
                        for (const t in this._origShaders) this._removeUniformFromShader(this.getPrefixedName(n), this._origShaders[t].shader);
                        this._uniforms.splice(e, 1)
                    }
                }
                this._changedUniforms = !0
            }
        }
        removeUniformStruct(t) {
            if (this._getStructUniform(t)) {
                for (let e = this._structUniforms.length - 1; e >= 0; e -= 1) {
                    const n = this._structUniforms[e];
                    if (n.uniformName === t) {
                        for (const t in this._origShaders)
                            for (let e = 0; e < n.members.length; e += 1) {
                                const i = n.members[e];
                                this._removeUniformFromShader(this.getPrefixedName(i.name), this._origShaders[t].shader)
                            }
                        this._structUniforms.splice(e, 1)
                    }
                }
                this._changedUniforms = !0
            }
        }
        getPrefixedName(e) {
            const t = this._mods[0].group;
            if (void 0 !== t) return 0 == e.indexOf("MOD_") && (e = "mod" + t + "_" + (e = e.substr("MOD_".length))), e
        }
        _updateDefinesShader(e) {
            for (const t in this._defines) {
                const n = this.getPrefixedName(t);
                null !== this._defines[t] && void 0 !== this._defines[t] ? e.define(n, this._defines[t]) : e.removeDefine(n)
            }
            for (const t in this._definesToggled) {
                const n = this.getPrefixedName(t);
                e.toggleDefine(n, this._definesToggled[t])
            }
        }
        _updateDefines() {
            for (const e in this._origShaders) this._updateDefinesShader(this._origShaders[e].shader);
            this._changedDefines = !1
        }
        define(e, t) {
            void 0 === t && (t = !0), this._defines[e] = t, this._changedDefines = !0
        }
        removeDefine(e) {
            this._defines[e] = null, this._changedDefines = !0
        }
        hasDefine(e) {
            return null !== this._defines[e] && void 0 !== this._defines[e]
        }
        toggleDefine(e, t) {
            this._changedDefines = !0, this._definesToggled[e] = t
        }
        currentShader() {
            return this._boundShader ? this._boundShader.shader : null
        }
        dispose() {}
    }, ((this.CGL = this.CGL || {}).COREMODULES = this.CGL.COREMODULES || {}).Shadermodifier = {}.Shadermodifier
})();
(() => {
    "use strict";
    const s = {
            EASINGS: ["linear", "absolute", "smoothstep", "smootherstep", "Cubic In", "Cubic Out", "Cubic In Out", "Expo In", "Expo Out", "Expo In Out", "Sin In", "Sin Out", "Sin In Out", "Quart In", "Quart Out", "Quart In Out", "Quint In", "Quint Out", "Quint In Out", "Back In", "Back Out", "Back In Out", "Elastic In", "Elastic Out", "Bounce In", "Bounce Out"],
            EASING_LINEAR: 0,
            EASING_ABSOLUTE: 1,
            EASING_SMOOTHSTEP: 2,
            EASING_SMOOTHERSTEP: 3,
            EASING_CUBICSPLINE: 4,
            EASING_CUBIC_IN: 5,
            EASING_CUBIC_OUT: 6,
            EASING_CUBIC_INOUT: 7,
            EASING_EXPO_IN: 8,
            EASING_EXPO_OUT: 9,
            EASING_EXPO_INOUT: 10,
            EASING_SIN_IN: 11,
            EASING_SIN_OUT: 12,
            EASING_SIN_INOUT: 13,
            EASING_BACK_IN: 14,
            EASING_BACK_OUT: 15,
            EASING_BACK_INOUT: 16,
            EASING_ELASTIC_IN: 17,
            EASING_ELASTIC_OUT: 18,
            EASING_BOUNCE_IN: 19,
            EASING_BOUNCE_OUT: 21,
            EASING_QUART_IN: 22,
            EASING_QUART_OUT: 23,
            EASING_QUART_INOUT: 24,
            EASING_QUINT_IN: 25,
            EASING_QUINT_OUT: 26,
            EASING_QUINT_INOUT: 27
        },
        r = 0,
        n = 1,
        i = 2,
        t = 2,
        a = 3,
        o = 4,
        l = 5,
        h = 0,
        c = 1,
        e = {
            float32Concat: function(e, t) {
                e instanceof Float32Array || (e = new Float32Array(e)), t instanceof Float32Array || (t = new Float32Array(t));
                const n = new Float32Array(e.length + t.length);
                return n.set(e), n.set(t, e.length), n
            }
        };
    Math.randomSeed = 1, Math.seededRandom = function(e, t) {
        return 0 === Math.randomSeed && (Math.randomSeed = 999 * Math.random()), e = e || 1, t = t || 0, Math.randomSeed = (9301 * Math.randomSeed + 49297) % 233280, t + Math.randomSeed / 233280 * (e - t)
    }, e.arrayWriteToEnd = function(t, e) {
        for (let e = 1; e < t.length; e++) t[e - 1] = t[e];
        t[t.length - 1] = e
    }, e.isNumeric = function(e) {
        return !isNaN(parseFloat(e)) && isFinite(e)
    }, e.isArray = function(e) {
        return "[object Array]" === Object.prototype.toString.call(e)
    }, String.prototype.endl = function() {
        return this + "\n"
    }, String.prototype.startsWith = function(e) {
        return 0 === this.indexOf(e)
    }, String.prototype.endsWith = String.prototype.endsWith || function(e) {
        return this.match(e + "$") == e
    }, window.performance = window.performance || {
        offset: Date.now(),
        now: function() {
            return Date.now() - this.offset
        }
    };
    const u = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
        d = new Uint8Array(256);
    for (let e = 0; e < u.length; e++) d[u.charCodeAt(e)] = e;
    const g = d,
        m = function(e) {
            let t, n, i, s, r, a = .75 * e.length,
                o = e.length,
                l = 0;
            "=" === e[e.length - 1] && (a--, "=" === e[e.length - 2] && a--);
            let h = new ArrayBuffer(a),
                c = new Uint8Array(h);
            for (t = 0; t < o; t += 4) n = g[e.charCodeAt(t)], i = g[e.charCodeAt(t + 1)], s = g[e.charCodeAt(t + 2)], r = g[e.charCodeAt(t + 3)], c[l++] = n << 2 | i >> 4, c[l++] = (15 & i) << 4 | s >> 2, c[l++] = (3 & s) << 6 | 63 & r;
            return h
        };
    class f {
        constructor(e) {
            this._init(), this._first = !0, this._wireMesh = null, e && this.apply(e)
        }
        _init() {
            this._max = [-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE], this._min = [Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE], this._center = [0, 0, 0], this._size = [0, 0, 0], this._maxAxis = 0, this._first = !0
        }
        get maxAxis() {
            return this._maxAxis || 1
        }
        get size() {
            return this._size
        }
        get center() {
            return this._center
        }
        get x() {
            return this._center[0]
        }
        get y() {
            return this._center[1]
        }
        get z() {
            return this._center[2]
        }
        get minX() {
            return this._min[0]
        }
        get minY() {
            return this._min[1]
        }
        get minZ() {
            return this._min[2]
        }
        get maxX() {
            return this._max[0]
        }
        get maxY() {
            return this._max[1]
        }
        get maxZ() {
            return this._max[2]
        }
        apply(t, e) {
            if (t) {
                if (t instanceof f) {
                    const e = t;
                    this.applyPos(e.maxX, e.maxY, e.maxZ), this.applyPos(e.minX, e.minY, e.minZ)
                } else
                    for (let e = 0; e < t.vertices.length; e += 3) this.applyPos(t.vertices[e], t.vertices[e + 1], t.vertices[e + 2]);
                this.calcCenterSize()
            }
        }
        copy() {
            return new f(this)
        }
        get changed() {
            return !(this._max[0] == -Number.MAX_VALUE && this._max[1] == -Number.MAX_VALUE && this._max[2] == -Number.MAX_VALUE)
        }
        applyPos(e, t, n) {
            if (e != Number.MAX_VALUE && e != -Number.MAX_VALUE && t != Number.MAX_VALUE && t != -Number.MAX_VALUE && n != Number.MAX_VALUE && n != -Number.MAX_VALUE && CABLES.UTILS.isNumeric(e) && CABLES.UTILS.isNumeric(t) && CABLES.UTILS.isNumeric(n)) {
                if (this._first) return this._max[0] = e, this._max[1] = t, this._max[2] = n, this._min[0] = e, this._min[1] = t, this._min[2] = n, void(this._first = !1);
                this._max[0] = Math.max(this._max[0], e), this._max[1] = Math.max(this._max[1], t), this._max[2] = Math.max(this._max[2], n), this._min[0] = Math.min(this._min[0], e), this._min[1] = Math.min(this._min[1], t), this._min[2] = Math.min(this._min[2], n)
            }
        }
        calcCenterSize() {
            this._first || (this._size[0] = this._max[0] - this._min[0], this._size[1] = this._max[1] - this._min[1], this._size[2] = this._max[2] - this._min[2], this._center[0] = (this._min[0] + this._max[0]) / 2, this._center[1] = (this._min[1] + this._max[1]) / 2, this._center[2] = (this._min[2] + this._max[2]) / 2, this._maxAxis = Math.max(this._size[2], Math.max(this._size[0], this._size[1])))
        }
        mulMat4(e) {
            this._first && (this._max[0] = 0, this._max[1] = 0, this._max[2] = 0, this._min[0] = 0, this._min[1] = 0, this._min[2] = 0, this._first = !1), vec3.transformMat4(this._max, this._max, e), vec3.transformMat4(this._min, this._min, e), this.calcCenterSize()
        }
        render(e, t) {
            this._wireMesh || (this._wireMesh = new CGL.WireCube(e)), e.pushModelMatrix(), mat4.translate(e.mMatrix, e.mMatrix, this._center), this._wireMesh.render(e, this._size[0] / 2, this._size[1] / 2, this._size[2] / 2), e.popModelMatrix()
        }
    }
    class p {
        constructor(e) {
            this._logs = [], this.initiator = e
        }
        stack(e) {
            console.info("[" + this.initiator + "] ", e), console.log((new Error).stack)
        }
        groupCollapsed(e) {
            console.groupCollapsed("[" + this.initiator + "] " + e)
        }
        table(e) {
            console.table(e)
        }
        groupEnd() {
            console.groupEnd()
        }
        error(e) {
            console.error("[" + this.initiator + "]", ...arguments), window.gui && window.gui.emitEvent("coreLogEvent", this.initiator, "error", arguments)
        }
        info(e) {
            console.error("[" + this.initiator + "]", ...arguments), window.gui && window.gui.emitEvent("coreLogEvent", this.initiator, "info", arguments)
        }
        warn(e) {
            console.warn("[" + this.initiator + "]", ...arguments), window.gui && window.gui.emitEvent("coreLogEvent", this.initiator, "warn", arguments)
        }
        verbose() {
            (CABLES.UI && CABLES.UI.logFilter.shouldPrint(this.initiator, ...arguments) || !CABLES.logSilent) && console.log("[" + this.initiator + "]", ...arguments), window.gui && window.gui.emitEvent("coreLogEvent", this.initiator, "verbose", arguments)
        }
        log(e) {
            (CABLES.UI && CABLES.UI.logFilter.shouldPrint(this.initiator, ...arguments) || !CABLES.logSilent) && console.log("[" + this.initiator + "]", ...arguments), window.gui && window.gui.emitEvent("coreLogEvent", this.initiator, "log", arguments)
        }
        userInteraction(e) {}
    }
    const b = function(e) {
        this.name = e || "unknown", this._log = new p("cgl_geometry"), this.faceVertCount = 3, this.glPrimitive = null, this._attributes = {}, this._vertices = [], this.verticesIndices = [], this.isGeometry = !0, this.morphTargets = [], Object.defineProperty(this, "vertices", {
            get() {
                return this._vertices
            },
            set(e) {
                this.setVertices(e)
            }
        }), Object.defineProperty(this, "texCoords", {
            get() {
                const e = this.getAttribute("texCoords");
                return e ? e.data : []
            },
            set(e) {
                this.setAttribute("texCoords", e, 2)
            }
        }), Object.defineProperty(this, "vertexNormals", {
            get() {
                const e = this.getAttribute("vertexNormals");
                return e ? e.data : []
            },
            set(e) {
                this.setAttribute("vertexNormals", e, 3)
            }
        }), Object.defineProperty(this, "tangents", {
            get() {
                const e = this.getAttribute("tangents");
                return e ? e.data : []
            },
            set(e) {
                this.setAttribute("tangents", e, 3)
            }
        }), Object.defineProperty(this, "biTangents", {
            get() {
                const e = this.getAttribute("biTangents");
                return e ? e.data : []
            },
            set(e) {
                this.setAttribute("biTangents", e, 3)
            }
        }), Object.defineProperty(this, "vertexColors", {
            get() {
                const e = this.getAttribute("vertexColors");
                return e ? e.data : []
            },
            set(e) {
                this.setAttribute("vertexColors", e, 4)
            }
        })
    };
    b.prototype.clear = function() {
        this._vertices = new Float32Array([]), this.verticesIndices = [], this.texCoords = new Float32Array([]), this.vertexNormals = new Float32Array([]), this.tangents = [], this.biTangents = [], this._attributes = {}
    }, b.prototype.getAttributes = function() {
        return this._attributes
    }, b.prototype.getAttribute = function(t) {
        for (const e in this._attributes)
            if (this._attributes[e].name == t) return this._attributes[e];
        return null
    }, b.prototype.setAttribute = function(e, t, n) {
        let i = "";
        (!n || n > 4) && (console.log("itemsize wrong?", n, e), this._log.stack("itemsize"), n = 3), 1 == n ? i = "float" : 2 == n ? i = "vec2" : 3 == n ? i = "vec3" : 4 == n && (i = "vec4");
        const s = {
            name: e,
            data: t,
            itemSize: n,
            type: i
        };
        this._attributes[e] = s
    }, b.prototype.copyAttribute = function(e, t) {
        const n = this.getAttribute(e);
        t.setAttribute(e, new Float32Array(n.data), n.itemSize)
    }, b.prototype.setVertices = function(e) {
        e instanceof Float32Array ? this._vertices = e : this._vertices = new Float32Array(e)
    }, b.prototype.setTexCoords = function(e) {
        e instanceof Float32Array ? this.texCoords = e : this.texCoords = new Float32Array(e)
    }, b.prototype.calcNormals = function(e) {
        const t = {
            smooth: e
        };
        this.calculateNormals(t)
    }, b.prototype.flipNormals = function(t, n, i) {
        let s = vec3.create();
        null == t && (t = 1), null == n && (n = 1), null == i && (i = 1);
        for (let e = 0; e < this.vertexNormals.length; e += 3) vec3.set(s, this.vertexNormals[e + 0], this.vertexNormals[e + 1], this.vertexNormals[e + 2]), s[0] *= -t, s[1] *= -n, s[2] *= -i, vec3.normalize(s, s), this.vertexNormals[e + 0] = s[0], this.vertexNormals[e + 1] = s[1], this.vertexNormals[e + 2] = s[2]
    }, b.prototype.getNumTriangles = function() {
        return this.verticesIndices && this.verticesIndices.length ? this.verticesIndices.length / 3 : this.vertices.length / 3
    }, b.prototype.flipVertDir = function() {
        const t = [];
        t.length = this.verticesIndices.length;
        for (let e = 0; e < this.verticesIndices.length; e += 3) t[e] = this.verticesIndices[e + 2], t[e + 1] = this.verticesIndices[e + 1], t[e + 2] = this.verticesIndices[e];
        this.verticesIndices = t
    }, b.prototype.setPointVertices = function(t) {
        if (t.length % 3 == 0) {
            t instanceof Float32Array ? this.vertices = t : this.vertices = new Float32Array(t), this.texCoords instanceof Float32Array || (this.texCoords = new Float32Array(t.length / 3 * 2)), this.verticesIndices.length = t.length / 3;
            for (let e = 0; e < t.length / 3; e++) this.verticesIndices[e] = e, this.texCoords[2 * e] = 0, this.texCoords[2 * e + 1] = 0
        } else this._log.error("SetPointVertices: Array must be multiple of three.")
    }, b.prototype.merge = function(t) {
        if (!t) return;
        if (this.isIndexed() != t.isIndexed() && (this.isIndexed() && this.unIndex(!1, !0), t.isIndexed())) {
            const n = t.copy();
            n.unIndex(!1, !0), t = n
        }
        const n = this.verticesIndices.length,
            i = this._vertices.length / 3;
        this.verticesIndices.length = this.verticesIndices.length + t.verticesIndices.length;
        for (let e = 0; e < t.verticesIndices.length; e++) this.verticesIndices[n + e] = t.verticesIndices[e] + i;
        this.vertices = e.float32Concat(this._vertices, t.vertices), this.texCoords = e.float32Concat(this.texCoords, t.texCoords), this.vertexNormals = e.float32Concat(this.vertexNormals, t.vertexNormals), this.tangents = e.float32Concat(this.tangents, t.tangents), this.biTangents = e.float32Concat(this.biTangents, t.biTangents)
    }, b.prototype.copy = function() {
        const t = new b(this.name + " copy");
        if (t.faceVertCount = this.faceVertCount, t.glPrimitive = this.glPrimitive, t.setVertices(this._vertices.slice(0)), this.verticesIndices) {
            t.verticesIndices.length = this.verticesIndices.length;
            for (let e = 0; e < this.verticesIndices.length; e++) t.verticesIndices[e] = this.verticesIndices[e]
        }
        for (let e in this._attributes) this.copyAttribute(e, t);
        t.morphTargets.length = this.morphTargets.length;
        for (let e = 0; e < this.morphTargets.length; e++) t.morphTargets[e] = this.morphTargets[e];
        return t
    }, b.prototype.calculateNormals = function(t) {
        !1 === (t = t || {}).smooth && this.unIndex();
        const n = vec3.create(),
            i = vec3.create(),
            s = vec3.create();

        function r(e) {
            return vec3.subtract(n, e[0], e[1]), vec3.subtract(i, e[0], e[2]), vec3.cross(s, n, i), vec3.normalize(s, s), t && t.forceZUp && s[2] < 0 && (s[0] *= -1, s[1] *= -1, s[2] *= -1), s
        }
        this.getVertexVec = function(e) {
            const t = [0, 0, 0];
            return t[0] = this.vertices[3 * e + 0], t[1] = this.vertices[3 * e + 1], t[2] = this.vertices[3 * e + 2], t
        }, this.vertexNormals instanceof Float32Array && this.vertexNormals.length == this.vertices.length || (this.vertexNormals = new Float32Array(this.vertices.length));
        for (let e = 0; e < this.vertices.length; e++) this.vertexNormals[e] = 0;
        if (this.isIndexed()) {
            const t = [];
            t.length = Math.floor(this.verticesIndices.length / 3);
            for (let e = 0; e < this.verticesIndices.length; e += 3) {
                const i = [this.getVertexVec(this.verticesIndices[e + 0]), this.getVertexVec(this.verticesIndices[e + 1]), this.getVertexVec(this.verticesIndices[e + 2])];
                t[e / 3] = r(i), this.vertexNormals[3 * this.verticesIndices[e + 0] + 0] += t[e / 3][0], this.vertexNormals[3 * this.verticesIndices[e + 0] + 1] += t[e / 3][1], this.vertexNormals[3 * this.verticesIndices[e + 0] + 2] += t[e / 3][2], this.vertexNormals[3 * this.verticesIndices[e + 1] + 0] += t[e / 3][0], this.vertexNormals[3 * this.verticesIndices[e + 1] + 1] += t[e / 3][1], this.vertexNormals[3 * this.verticesIndices[e + 1] + 2] += t[e / 3][2], this.vertexNormals[3 * this.verticesIndices[e + 2] + 0] += t[e / 3][0], this.vertexNormals[3 * this.verticesIndices[e + 2] + 1] += t[e / 3][1], this.vertexNormals[3 * this.verticesIndices[e + 2] + 2] += t[e / 3][2]
            }
            for (let t = 0; t < this.verticesIndices.length; t += 3)
                for (let e = 0; e < 3; e++) {
                    const i = [this.vertexNormals[3 * this.verticesIndices[t + e] + 0], this.vertexNormals[3 * this.verticesIndices[t + e] + 1], this.vertexNormals[3 * this.verticesIndices[t + e] + 2]];
                    vec3.normalize(i, i), this.vertexNormals[3 * this.verticesIndices[t + e] + 0] = i[0], this.vertexNormals[3 * this.verticesIndices[t + e] + 1] = i[1], this.vertexNormals[3 * this.verticesIndices[t + e] + 2] = i[2]
                }
        } else {
            const t = [];
            for (let e = 0; e < this.vertices.length; e += 9) {
                const i = r([
                    [this.vertices[e + 0], this.vertices[e + 1], this.vertices[e + 2]],
                    [this.vertices[e + 3], this.vertices[e + 4], this.vertices[e + 5]],
                    [this.vertices[e + 6], this.vertices[e + 7], this.vertices[e + 8]]
                ]);
                t.push(i[0], i[1], i[2], i[0], i[1], i[2], i[0], i[1], i[2])
            }
            this.vertexNormals = t
        }
    }, b.prototype.calcTangentsBitangents = function() {
        if (!this.vertices.length) return;
        if (!this.vertexNormals.length) return;
        if (!this.texCoords.length) {
            const o = this.vertices.length / 3 * 2;
            this.texCoords = new Float32Array(o);
            for (let e = 0; e < o; e += 1) this.texCoords[e] = 0
        }
        if (!this.verticesIndices || !this.verticesIndices.length) return;
        if (this.verticesIndices.length % 3 != 0) return void this._log.error("Vertex indices mismatch!");
        const o = this.verticesIndices.length / 3,
            l = this.vertices.length / 3;
        this.tangents = new Float32Array(this.vertexNormals.length), this.biTangents = new Float32Array(this.vertexNormals.length);
        const h = [];
        h.length = 2 * l;
        const c = vec3.create(),
            u = vec3.create(),
            d = vec3.create(),
            g = vec2.create(),
            m = vec2.create(),
            f = vec2.create(),
            p = vec3.create(),
            b = vec3.create();
        for (let a = 0; a < o; a += 1) {
            const o = this.verticesIndices[3 * a],
                _ = this.verticesIndices[3 * a + 1],
                v = this.verticesIndices[3 * a + 2];
            vec3.set(c, this.vertices[3 * o], this.vertices[3 * o + 1], this.vertices[3 * o + 2]), vec3.set(u, this.vertices[3 * _], this.vertices[3 * _ + 1], this.vertices[3 * _ + 2]), vec3.set(d, this.vertices[3 * v], this.vertices[3 * v + 1], this.vertices[3 * v + 2]), vec2.set(g, this.texCoords[2 * o], this.texCoords[2 * o + 1]), vec2.set(m, this.texCoords[2 * _], this.texCoords[2 * _ + 1]), vec2.set(f, this.texCoords[2 * v], this.texCoords[2 * v + 1]);
            const x = u[0] - c[0],
                y = d[0] - c[0],
                C = u[1] - c[1],
                S = d[1] - c[1],
                A = u[2] - c[2],
                e = d[2] - c[2],
                t = m[0] - g[0],
                n = f[0] - g[0],
                i = m[1] - g[1],
                s = f[1] - g[1],
                r = 1 / (t * s - n * i);
            vec3.set(p, (s * x - i * y) * r, (s * C - i * S) * r, (s * A - i * e) * r), vec3.set(b, (t * y - n * x) * r, (t * S - n * C) * r, (t * e - n * A) * r), h[o] = p, h[_] = p, h[v] = p, h[o + l] = b, h[_ + l] = b, h[v + l] = b
        }
        const t = vec3.create(),
            _ = vec3.create(),
            v = vec3.create(),
            x = vec3.create(),
            y = vec3.create(),
            C = vec3.create(),
            S = vec3.create(),
            A = vec3.create();
        for (let e = 0; e < l; e += 1) {
            if (!h[e]) continue;
            vec3.set(t, this.vertexNormals[3 * e], this.vertexNormals[3 * e + 1], this.vertexNormals[3 * e + 2]), vec3.set(_, h[e][0], h[e][1], h[e][2]);
            const c = vec3.dot(t, _);
            vec3.scale(y, t, c), vec3.subtract(C, _, y), vec3.normalize(A, C), vec3.cross(S, t, _), vec3.dot(S, h[e + l]);
            const u = 1;
            vec3.scale(v, A, 1 / u), vec3.cross(x, t, v), this.tangents[3 * e + 0] = v[0], this.tangents[3 * e + 1] = v[1], this.tangents[3 * e + 2] = v[2], this.biTangents[3 * e + 0] = x[0], this.biTangents[3 * e + 1] = x[1], this.biTangents[3 * e + 2] = x[2]
        }
    }, b.prototype.isIndexed = function() {
        return 0 == this._vertices.length || 0 != this.verticesIndices.length
    }, b.prototype.unIndex = function(e, i) {
        const t = [],
            n = [];
        let s = 0;
        for (let e in this._attributes) {
            const i = this._attributes[e];
            let n = [];
            for (let t = 0; t < this.verticesIndices.length; t += 3)
                for (let e = 0; e < 3; e++) 3 == i.itemSize ? n.push(i.data[3 * this.verticesIndices[t + e] + 0], i.data[3 * this.verticesIndices[t + e] + 1], i.data[3 * this.verticesIndices[t + e] + 2]) : 4 == i.itemSize ? n.push(i.data[4 * this.verticesIndices[t + e] + 0], i.data[4 * this.verticesIndices[t + e] + 1], i.data[4 * this.verticesIndices[t + e] + 2], i.data[4 * this.verticesIndices[t + e] + 3]) : 2 == i.itemSize ? n.push(i.data[2 * this.verticesIndices[t + e] + 0], i.data[2 * this.verticesIndices[t + e] + 1]) : 1 == i.itemSize ? n.push(i.data[this.verticesIndices[t + e]]) : console.log("unknown attr", i);
            this.setAttribute(i.name, n, i.itemSize)
        }
        for (let e = 0; e < this.verticesIndices.length; e += 3) t.push(this.vertices[3 * this.verticesIndices[e + 0] + 0], this.vertices[3 * this.verticesIndices[e + 0] + 1], this.vertices[3 * this.verticesIndices[e + 0] + 2]), n.push(s), s++, t.push(this.vertices[3 * this.verticesIndices[e + 1] + 0], this.vertices[3 * this.verticesIndices[e + 1] + 1], this.vertices[3 * this.verticesIndices[e + 1] + 2]), n.push(s), s++, t.push(this.vertices[3 * this.verticesIndices[e + 2] + 0], this.vertices[3 * this.verticesIndices[e + 2] + 1], this.vertices[3 * this.verticesIndices[e + 2] + 2]), n.push(s), s++;
        this.vertices = t, this.verticesIndices = [], e && (this.verticesIndices = n), i || this.calculateNormals()
    }, b.prototype.calcBarycentric = function() {
        let t = [];
        t.length = this.vertices.length;
        for (let e = 0; e < this.vertices.length; e++) t[e] = 0;
        let n = 0;
        for (let e = 0; e < this.vertices.length; e += 3) t[e + n] = 1, n++, 3 == n && (n = 0);
        this.setAttribute("attrBarycentric", t, 3)
    }, b.prototype.getBounds = function() {
        return new f(this)
    }, b.prototype.center = function(e, t, n) {
        void 0 === e && (e = !0, t = !0, n = !0);
        let i = 0;
        const s = this.getBounds(),
            r = [s.minX + (s.maxX - s.minX) / 2, s.minY + (s.maxY - s.minY) / 2, s.minZ + (s.maxZ - s.minZ) / 2];
        for (i = 0; i < this.vertices.length; i += 3) this.vertices[i + 0] == this.vertices[i + 0] && (e && (this.vertices[i + 0] -= r[0]), t && (this.vertices[i + 1] -= r[1]), n && (this.vertices[i + 2] -= r[2]));
        return r
    }, b.prototype.mapTexCoords2d = function() {
        const n = this.getBounds(),
            i = this.vertices.length / 3;
        this.texCoords = new Float32Array(2 * i);
        for (let t = 0; t < i; t++) {
            const i = this.vertices[3 * t + 0],
                e = this.vertices[3 * t + 1];
            this.texCoords[2 * t + 0] = i / (n.maxX - n.minX) + .5, this.texCoords[2 * t + 1] = 1 - e / (n.maxY - n.minY) + .5
        }
    }, b.prototype.getInfoOneLine = function() {
        let e = "";
        return 3 == this.faceVertCount && this.verticesIndices ? e += this.verticesIndices.length / 3 : e += 0, e += " tris ", this.vertices ? e += this.vertices.length / 3 : e += 0, e += " verts", e
    }, b.prototype.getInfo = function() {
        const e = {};
        return 3 == this.faceVertCount && this.verticesIndices ? e.numFaces = this.verticesIndices.length / 3 : e.numFaces = 0, this.verticesIndices && this.verticesIndices.length && (e.indices = this.verticesIndices.length), this.vertices ? e.numVerts = this.vertices.length / 3 : e.numVerts = 0, this.vertexNormals ? e.numNormals = this.vertexNormals.length / 3 : e.numNormals = 0, this.texCoords ? e.numTexCoords = this.texCoords.length / 2 : e.numTexCoords = 0, this.tangents ? e.numTangents = this.tangents.length / 3 : e.numTangents = 0, this.biTangents ? e.numBiTangents = this.biTangents.length / 3 : e.numBiTangents = 0, this.biTangents ? e.numBiTangents = this.biTangents.length / 3 : e.numBiTangents = 0, this.vertexColors ? e.numVertexColors = this.vertexColors.length / 4 : e.numVertexColors = 0, this.getAttributes() ? e.numAttribs = Object.keys(this.getAttributes()).length : e.numAttribs = 0, e.isIndexed = this.isIndexed(), e
    }, b.buildFromFaces = function(s, e, r) {
        const a = [],
            o = [];
        for (let e = 0; e < s.length; e += 3) {
            const l = s[e + 0],
                t = s[e + 1],
                n = s[e + 2],
                i = [-1, -1, -1];
            if (r)
                for (let e = 0; e < a.length; e += 3) a[e + 0] == l[0] && a[e + 1] == l[1] && a[e + 2] == l[2] && (i[0] = e / 3), a[e + 0] == t[0] && a[e + 1] == t[1] && a[e + 2] == t[2] && (i[1] = e / 3), a[e + 0] == n[0] && a[e + 1] == n[1] && a[e + 2] == n[2] && (i[2] = e / 3); - 1 == i[0] && (a.push(l[0], l[1], l[2]), i[0] = (a.length - 1) / 3), -1 == i[1] && (a.push(t[0], t[1], t[2]), i[1] = (a.length - 1) / 3), -1 == i[2] && (a.push(n[0], n[1], n[2]), i[2] = (a.length - 1) / 3), o.push(parseInt(i[0], 10)), o.push(parseInt(i[1], 10)), o.push(parseInt(i[2], 10))
        }
        const l = new b(e);
        return l.name = e, l.vertices = a, l.verticesIndices = o, l
    }, b.json2geom = function(t) {
        const n = new b("jsonMeshGeom");
        if (n.verticesIndices = [], n.vertices = t.vertices || [], n.vertexNormals = t.normals || [], n.vertexColors = t.colors || [], n.tangents = t.tangents || [], n.biTangents = t.bitangents || [], t.texturecoords && n.setTexCoords(t.texturecoords[0]), t.vertices_b64 && (n.vertices = new Float32Array(m(t.vertices_b64))), t.normals_b64 && (n.vertexNormals = new Float32Array(m(t.normals_b64))), t.tangents_b64 && (n.tangents = new Float32Array(m(t.tangents_b64))), t.bitangents_b64 && (n.biTangents = new Float32Array(m(t.bitangents_b64))), t.texturecoords_b64 && n.setTexCoords(new Float32Array(m(t.texturecoords_b64[0]))), t.faces_b64) n.verticesIndices = new Uint32Array(m(t.faces_b64));
        else {
            n.verticesIndices.length = 3 * t.faces.length;
            for (let e = 0; e < t.faces.length; e++) n.verticesIndices[3 * e] = t.faces[e][0], n.verticesIndices[3 * e + 1] = t.faces[e][1], n.verticesIndices[3 * e + 2] = t.faces[e][2]
        }
        return n
    };
    const _ = function() {
            this._log = new p("eventtaget"), this._eventCallbacks = {}, this._logName = "", this._logEvents = !1, this._listeners = {}, CABLES.eventTargetProfile = CABLES.eventTargetProfile || {}, this.addEventListener = this.on = function(e, t, n) {
                const i = {
                    id: (n || "") + CABLES.simpleId(),
                    name: e,
                    cb: t
                };
                return this._eventCallbacks[e] ? this._eventCallbacks[e].push(i) : this._eventCallbacks[e] = [i], this._listeners[i.id] = i, i.id
            }, this.hasEventListener = function(e, t) {
                return e && !t ? !!this._listeners[e] : (this._log.warn("old eventtarget function haseventlistener!"), e && t && this._eventCallbacks[e] ? -1 != this._eventCallbacks[e].indexOf(t) : void 0)
            }, this.removeEventListener = this.off = function(i, s) {
                if (null == i) return;
                if (!s) {
                    const s = this._listeners[i];
                    if (!s) return void console.log("could not find event...");
                    let n = !0;
                    for (; n;) {
                        n = !1;
                        let t = -1;
                        for (let e = 0; e < this._eventCallbacks[s.name].length; e++) 0 === this._eventCallbacks[s.name][e].id.indexOf(i) && (n = !0, t = e); - 1 !== t && (this._eventCallbacks[s.name].splice(t, 1), delete this._listeners[i])
                    }
                    return
                }
                this._log.stack(" old function signature: removeEventListener! use listener id");
                let t = null;
                for (let e = 0; e < this._eventCallbacks[i].length; e++) this._eventCallbacks[i][e].cb == s && (t = e);
                null !== t ? delete this._eventCallbacks[t] : this._log.warn("removeEventListener not found " + i)
            }, this.logEvents = function(e, t) {
                this._logEvents = e, this._logName = t
            }, this.emitEvent = function(i, s, r, a, o, l, h) {
                if (this._logEvents && console.log("[event] ", this._logName, i, this._eventCallbacks), this._eventCallbacks[i]) {
                    const n = [];
                    for (let e = 0; e < this._eventCallbacks[i].length; e++) n[i] || (n[i] = []), n[i].push(this._eventCallbacks[i][e]);
                    if (n[i])
                        for (let t = 0; t < n[i].length; t++)
                            if (n[i][t]) {
                                const e = this.constructor.name + " " + i;
                                CABLES.eventTargetProfile[e] = CABLES.eventTargetProfile[e] || {
                                    name: this.constructor.name,
                                    event: i,
                                    count: 0
                                }, CABLES.eventTargetProfile[e].active = this._eventCallbacks[i].length, CABLES.eventTargetProfile[e].count++, n[i][t].cb(s, r, a, o, l, h)
                            }
                } else this._logEvents && console.log("[event] has no event callback", i, this._eventCallbacks)
            }
        },
        v = function(e) {
            this.time = 0, this.value = 0, this.ui = null, this.onChange = null, this._easing = 0, this.bezTangIn = 0, this.bezTangOut = 0, this.cb = null, this.cbTriggered = !1, this.setEasing(s.EASING_LINEAR), this.set(e)
        };
    v.cubicSpline = function(e, t, n) {
        let i = e * e,
            s = i * e;
        return (2 * s - 3 * i + 1) * t.value + (s - 2 * i + e) * t.bezTangOut + (-2 * s + 3 * i) * n.value + (s - i) * n.bezTangIn
    }, v.easeCubicSpline = function(e, t) {
        return v.cubicSpline(e, this, t)
    }, v.linear = function(e, t, n) {
        return parseFloat(t.value) + parseFloat(n.value - t.value) * e
    }, v.easeLinear = function(e, t) {
        return v.linear(e, this, t)
    }, v.easeAbsolute = function(e, t) {
        return this.value
    }, v.easeExpoIn = function(e, t) {
        return e = function(e) {
            return Math.pow(2, 10 * (e - 1))
        }(e), v.linear(e, this, t)
    }, v.easeExpoOut = function(e, t) {
        return e = function(e) {
            return 1 - Math.pow(2, -10 * e)
        }(e), v.linear(e, this, t)
    }, v.easeExpoInOut = function(e, t) {
        return e = function(e) {
            return (e *= 2) < 1 ? e = .5 * Math.pow(2, 10 * (e - 1)) : (e--, e = .5 * (2 - Math.pow(2, -10 * e))), e
        }(e), v.linear(e, this, t)
    }, v.easeSinIn = function(e, t) {
        return e = -1 * Math.cos(e * Math.PI / 2) + 1, v.linear(e, this, t)
    }, v.easeSinOut = function(e, t) {
        return e = Math.sin(e * Math.PI / 2), v.linear(e, this, t)
    }, v.easeSinInOut = function(e, t) {
        return e = -.5 * (Math.cos(Math.PI * e) - 1), v.linear(e, this, t)
    }, v.easeCubicIn = function(e, t) {
        return e = function(e) {
            return e * (e * e)
        }(e), v.linear(e, this, t)
    }, v.easeInQuint = function(e, t) {
        return v.linear(e *= e * e * e * e, this, t)
    }, v.easeOutQuint = function(e, t) {
        return e = (e -= 1) * e * e * e * e + 1, v.linear(e, this, t)
    }, v.easeInOutQuint = function(e, t) {
        return (e /= .5) < 1 ? e *= .5 * e * e * e * e : e = .5 * ((e -= 2) * e * e * e * e + 2), v.linear(e, this, t)
    }, v.easeInQuart = function(e, t) {
        return v.linear(e *= e * e * e, this, t)
    }, v.easeOutQuart = function(e, t) {
        return e = -1 * ((e -= 1) * e * e * e - 1), v.linear(e, this, t)
    }, v.easeInOutQuart = function(e, t) {
        return (e /= .5) < 1 ? e *= .5 * e * e * e : e = -.5 * ((e -= 2) * e * e * e - 2), v.linear(e, this, t)
    }, v.bounce = function(e) {
        return (e /= 1) < 1 / 2.75 ? e *= 7.5625 * e : e = e < 2 / 2.75 ? 7.5625 * (e -= 1.5 / 2.75) * e + .75 : e < 2.5 / 2.75 ? 7.5625 * (e -= 2.25 / 2.75) * e + .9375 : 7.5625 * (e -= 2.625 / 2.75) * e + .984375, e
    }, v.easeInBounce = function(e, t) {
        return v.linear(v.bounce(e), this, t)
    }, v.easeOutBounce = function(e, t) {
        return v.linear(v.bounce(e), this, t)
    }, v.easeInElastic = function(e, t) {
        let n = 1.70158,
            i = 0,
            s = 1;
        return 0 === e ? e = 0 : 1 == (e /= 1) ? e = 1 : (i || (i = .3), s < Math.abs(1) ? (s = 1, n = i / 4) : n = i / (2 * Math.PI) * Math.asin(1 / s), e = -s * Math.pow(2, 10 * (e -= 1)) * Math.sin((1 * e - n) * (2 * Math.PI) / i) + 0), v.linear(e, this, t)
    }, v.easeOutElastic = function(e, t) {
        let n = 1.70158,
            i = 0,
            s = 1;
        return 0 === e ? e = 0 : 1 == (e /= 1) ? e = 1 : (i || (i = .3), s < Math.abs(1) ? (s = 1, n = i / 4) : n = i / (2 * Math.PI) * Math.asin(1 / s), e = s * Math.pow(2, -10 * e) * Math.sin((1 * e - n) * (2 * Math.PI) / i) + 1 + 0), v.linear(e, this, t)
    }, v.easeInBack = function(e, t) {
        const n = 1.70158;
        return v.linear(e = e * e * ((n + 1) * e - n), this, t)
    }, v.easeOutBack = function(e, t) {
        const n = 1.70158;
        return e = (e = e / 1 - 1) * e * ((n + 1) * e + n) + 1, v.linear(e, this, t)
    }, v.easeInOutBack = function(e, t) {
        let n = 1.70158;
        return e = (e /= .5) < 1 ? e * e * ((1 + (n *= 1.525)) * e - n) * .5 : .5 * ((e -= 2) * e * ((1 + (n *= 1.525)) * e + n) + 2), v.linear(e, this, t)
    }, v.easeCubicOut = function(e, t) {
        return e = function(e) {
            return --e * e * e + 1
        }(e), v.linear(e, this, t)
    }, v.easeCubicInOut = function(e, t) {
        return e = function(e) {
            return (e *= 2) < 1 ? e *= .5 * e * e : e = .5 * ((e -= 2) * e * e + 2), e
        }(e), v.linear(e, this, t)
    }, v.easeSmoothStep = function(e, t) {
        const n = Math.max(0, Math.min(1, e));
        return v.linear(e = n * n * (3 - 2 * n), this, t)
    }, v.easeSmootherStep = function(e, t) {
        const n = Math.max(0, Math.min(1, (e - 0) / 1));
        return v.linear(e = n * n * n * (n * (6 * n - 15) + 10), this, t)
    }, v.prototype.setEasing = function(e) {
        this._easing = e, this._easing == s.EASING_LINEAR ? this.ease = v.easeLinear : this._easing == s.EASING_ABSOLUTE ? this.ease = v.easeAbsolute : this._easing == s.EASING_SMOOTHSTEP ? this.ease = v.easeSmoothStep : this._easing == s.EASING_SMOOTHERSTEP ? this.ease = v.easeSmootherStep : this._easing == s.EASING_CUBIC_IN ? this.ease = v.easeCubicIn : this._easing == s.EASING_CUBIC_OUT ? this.ease = v.easeCubicOut : this._easing == s.EASING_CUBIC_INOUT ? this.ease = v.easeCubicInOut : this._easing == s.EASING_EXPO_IN ? this.ease = v.easeExpoIn : this._easing == s.EASING_EXPO_OUT ? this.ease = v.easeExpoOut : this._easing == s.EASING_EXPO_INOUT ? this.ease = v.easeExpoInOut : this._easing == s.EASING_SIN_IN ? this.ease = v.easeSinIn : this._easing == s.EASING_SIN_OUT ? this.ease = v.easeSinOut : this._easing == s.EASING_SIN_INOUT ? this.ease = v.easeSinInOut : this._easing == s.EASING_BACK_OUT ? this.ease = v.easeOutBack : this._easing == s.EASING_BACK_IN ? this.ease = v.easeInBack : this._easing == s.EASING_BACK_INOUT ? this.ease = v.easeInOutBack : this._easing == s.EASING_ELASTIC_IN ? this.ease = v.easeInElastic : this._easing == s.EASING_ELASTIC_OUT ? this.ease = v.easeOutElastic : this._easing == s.EASING_ELASTIC_INOUT ? this.ease = v.easeElasticInOut : this._easing == s.EASING_BOUNCE_IN ? this.ease = v.easeInBounce : this._easing == s.EASING_BOUNCE_OUT ? this.ease = v.easeOutBounce : this._easing == s.EASING_QUART_OUT ? this.ease = v.easeOutQuart : this._easing == s.EASING_QUART_IN ? this.ease = v.easeInQuart : this._easing == s.EASING_QUART_INOUT ? this.ease = v.easeInOutQuart : this._easing == s.EASING_QUINT_OUT ? this.ease = v.easeOutQuint : this._easing == s.EASING_QUINT_IN ? this.ease = v.easeInQuint : this._easing == s.EASING_QUINT_INOUT ? this.ease = v.easeInOutQuint : this._easing == s.EASING_CUBICSPLINE ? this.ease = v.easeCubicSpline : (this._easing = s.EASING_LINEAR, this.ease = v.easeLinear)
    }, v.prototype.trigger = function() {
        this.cb(), this.cbTriggered = !0
    }, v.prototype.setValue = function(e) {
        this.value = e, null !== this.onChange && this.onChange()
    }, v.prototype.set = function(e) {
        e && (e.e && this.setEasing(e.e), e.cb && (this.cb = e.cb, this.cbTriggered = !1), e.b, e.hasOwnProperty("t") && (this.time = e.t), e.hasOwnProperty("time") && (this.time = e.time), e.hasOwnProperty("v") ? this.value = e.v : e.hasOwnProperty("value") && (this.value = e.value)), null !== this.onChange && this.onChange()
    }, v.prototype.getSerialized = function() {
        const e = {};
        return e.t = this.time, e.v = this.value, e.e = this._easing, e
    }, v.prototype.getEasing = function() {
        return this._easing
    };
    const x = function(e) {
        _.apply(this), e = e || {}, this.keys = [], this.onChange = null, this.stayInTimeline = !1, this.loop = !1, this._log = new p("Anim"), this._lastKeyIndex = 0, this._cachedIndex = 0, this.name = e.name || null, this.defaultEasing = e.defaultEasing || s.EASING_LINEAR, this.onLooped = null, this._timesLooped = 0, this._needsSort = !1
    };
    x.prototype.forceChangeCallback = function() {
        null !== this.onChange && this.onChange(), this.emitEvent("onChange", this)
    }, x.prototype.getLoop = function() {
        return this.loop
    }, x.prototype.setLoop = function(e) {
        this.loop = e, this.emitEvent("onChange", this)
    }, x.prototype.hasEnded = function(e) {
        return 0 === this.keys.length || this.keys[this._lastKeyIndex].time <= e
    }, x.prototype.isRising = function(e) {
        if (this.hasEnded(e)) return !1;
        const t = this.getKeyIndex(e);
        return this.keys[t].value < this.keys[t + 1].value
    }, x.prototype.clearBefore = function(e) {
        const t = this.getValue(e),
            n = this.getKeyIndex(e);
        this.setValue(e, t), n > 1 && this.keys.splice(0, n), this._updateLastIndex()
    }, x.prototype.clear = function(e) {
        let t = 0;
        e && (t = this.getValue(e)), this.keys.length = 0, this._updateLastIndex(), e && this.setValue(e, t), null !== this.onChange && this.onChange(), this.emitEvent("onChange", this)
    }, x.prototype.sortKeys = function() {
        this.keys.sort((e, t) => parseFloat(e.time) - parseFloat(t.time)), this._updateLastIndex(), this._needsSort = !1
    }, x.prototype.getLength = function() {
        return 0 === this.keys.length ? 0 : this.keys[this.keys.length - 1].time
    }, x.prototype.getKeyIndex = function(t) {
        let n = 0,
            i = 0;
        this._cachedIndex && this.keys.length > this._cachedIndex && t >= this.keys[this._cachedIndex].time && (i = this._cachedIndex);
        for (let e = i; e < this.keys.length; e++)
            if (t >= this.keys[e].time && (n = e), this.keys[e].time > t) return 0 != t && (this._cachedIndex = n), n;
        return n
    }, x.prototype.setValue = function(t, n, i) {
        let s = null;
        if (0 == this.keys.length || t <= this.keys[this.keys.length - 1].time)
            for (let e = 0; e < this.keys.length; e++)
                if (this.keys[e].time == t) {
                    s = this.keys[e], this.keys[e].setValue(n), this.keys[e].cb = i;
                    break
                } return s || (s = new v({
            time: t,
            value: n,
            e: this.defaultEasing,
            cb: i
        }), this.keys.push(s), this._updateLastIndex()), this.onChange && this.onChange(), this.emitEvent("onChange", this), this._needsSort = !0, s
    }, x.prototype.setKeyEasing = function(e, t) {
        this.keys[e] && (this.keys[e].setEasing(t), this.emitEvent("onChange", this))
    }, x.prototype.getSerialized = function() {
        const t = {
            keys: []
        };
        t.loop = this.loop;
        for (let e = 0; e < this.keys.length; e++) t.keys.push(this.keys[e].getSerialized());
        return t
    }, x.prototype.getKey = function(e) {
        const t = this.getKeyIndex(e);
        return this.keys[t]
    }, x.prototype.getNextKey = function(e) {
        let t = this.getKeyIndex(e) + 1;
        return t >= this.keys.length && (t = this.keys.length - 1), this.keys[t]
    }, x.prototype.isFinished = function(e) {
        return this.keys.length <= 0 || e > this.keys[this.keys.length - 1].time
    }, x.prototype.isStarted = function(e) {
        return !(this.keys.length <= 0) && e >= this.keys[0].time
    }, x.prototype.getValue = function(e) {
        if (0 === this.keys.length) return 0;
        if (this._needsSort && this.sortKeys(), !this.loop && e > this.keys[this._lastKeyIndex].time) return this.keys[this._lastKeyIndex].value;
        if (e < this.keys[0].time) return this.keys[0].value;
        this.loop && e > this.keys[this._lastKeyIndex].time && (e / this.keys[this._lastKeyIndex].time > this._timesLooped && (this._timesLooped++, this.onLooped && this.onLooped()), e = (e - this.keys[0].time) % (this.keys[this._lastKeyIndex].time - this.keys[0].time), e += this.keys[0].time);
        const t = this.getKeyIndex(e);
        if (t >= this._lastKeyIndex) return this.keys[this._lastKeyIndex].cb && !this.keys[this._lastKeyIndex].cbTriggered && this.keys[this._lastKeyIndex].trigger(), this.keys[this._lastKeyIndex].value;
        const n = t + 1,
            i = this.keys[t],
            s = this.keys[n];
        if (i.cb && !i.cbTriggered && i.trigger(), !s) return -1;
        const r = (e - i.time) / (s.time - i.time);
        return i.ease || this.log._warn("has no ease", i, s), i.ease(r, s)
    }, x.prototype._updateLastIndex = function() {
        this._lastKeyIndex = this.keys.length - 1
    }, x.prototype.addKey = function(e) {
        void 0 === e.time ? this.log.warn("key time undefined, ignoring!") : (this.keys.push(e), null !== this.onChange && this.onChange(), this.emitEvent("onChange", this)), this._updateLastIndex()
    }, x.prototype.easingFromString = function(e) {
        return "linear" == e ? s.EASING_LINEAR : "absolute" == e ? s.EASING_ABSOLUTE : "smoothstep" == e ? s.EASING_SMOOTHSTEP : "smootherstep" == e ? s.EASING_SMOOTHERSTEP : "Cubic In" == e ? s.EASING_CUBIC_IN : "Cubic Out" == e ? s.EASING_CUBIC_OUT : "Cubic In Out" == e ? s.EASING_CUBIC_INOUT : "Expo In" == e ? s.EASING_EXPO_IN : "Expo Out" == e ? s.EASING_EXPO_OUT : "Expo In Out" == e ? s.EASING_EXPO_INOUT : "Sin In" == e ? s.EASING_SIN_IN : "Sin Out" == e ? s.EASING_SIN_OUT : "Sin In Out" == e ? s.EASING_SIN_INOUT : "Back In" == e ? s.EASING_BACK_IN : "Back Out" == e ? s.EASING_BACK_OUT : "Back In Out" == e ? s.EASING_BACK_INOUT : "Elastic In" == e ? s.EASING_ELASTIC_IN : "Elastic Out" == e ? s.EASING_ELASTIC_OUT : "Bounce In" == e ? s.EASING_BOUNCE_IN : "Bounce Out" == e ? s.EASING_BOUNCE_OUT : "Quart Out" == e ? s.EASING_QUART_OUT : "Quart In" == e ? s.EASING_QUART_IN : "Quart In Out" == e ? s.EASING_QUART_INOUT : "Quint Out" == e ? s.EASING_QUINT_OUT : "Quint In" == e ? s.EASING_QUINT_IN : "Quint In Out" == e ? s.EASING_QUINT_INOUT : void 0
    }, x.prototype.createPort = function(e, t, n) {
        const i = e.inDropDown(t, s.EASINGS);
        return i.set("linear"), i.defaultValue = "linear", i.onChange = function() {
            this.defaultEasing = this.easingFromString(i.get()), n && n()
        }.bind(this), i
    }, x.slerpQuaternion = function(n, i, s, r, a, o) {
        x.slerpQuaternion.q1 || (x.slerpQuaternion.q1 = quat.create(), x.slerpQuaternion.q2 = quat.create());
        const l = s.getKeyIndex(n);
        let h = l + 1;
        if (h >= s.keys.length && (h = s.keys.length - 1), l == h) quat.set(i, s.keys[l].value, r.keys[l].value, a.keys[l].value, o.keys[l].value);
        else {
            const e = s.keys[l].time,
                t = (n - e) / (s.keys[h].time - e);
            quat.set(x.slerpQuaternion.q1, s.keys[l].value, r.keys[l].value, a.keys[l].value, o.keys[l].value), quat.set(x.slerpQuaternion.q2, s.keys[h].value, r.keys[h].value, a.keys[h].value, o.keys[h].value), quat.slerp(i, x.slerpQuaternion.q1, x.slerpQuaternion.q2, t)
        }
        return i
    };
    const y = v,
        C = function(e, t, n, i) {
            _.apply(this), this.data = {}, this._log = new p("core_port"), this.direction = h, this.id = String(CABLES.simpleId()), this._op = e, this.links = [], this.value = 0, this.name = t, this.type = n || r, this.uiAttribs = i || {}, this.anim = null, this._oldAnimVal = -5711, this.defaultValue = null, this._uiActiveState = !0, this.ignoreValueSerialize = !1, this.onLinkChanged = null, this.crashed = !1, this._valueBeforeLink = null, this._lastAnimFrame = -1, this._animated = !1, this.onValueChanged = null, this.onTriggered = null, this.onUiActiveStateChange = null, this.changeAlways = !1, this.forceRefChange = !1, this._warnedDeprecated = !1, this._useVariableName = null, this.activityCounter = 0, this.apf = 0, this.activityCounterStartFrame = 0, this._tempLastUiValue = null, Object.defineProperty(this, "title", {
                get() {
                    return this.uiAttribs.title || this.name
                }
            }), Object.defineProperty(this, "parent", {
                get() {
                    return this._log.stack("use port.op, not .parent"), this._op
                }
            }), Object.defineProperty(this, "op", {
                get() {
                    return this._op
                }
            }), Object.defineProperty(this, "val", {
                get() {
                    return this._log.warn("val getter deprecated!", this), this._log.stack("val getter deprecated"), this._warnedDeprecated = !0, this.get()
                },
                set(e) {
                    this._log.warn("val setter deprecated!", this), this._log.stack("val setter deprecated"), this.setValue(e), this._warnedDeprecated = !0
                }
            })
        };
    C.prototype.copyLinkedUiAttrib = function(e, t) {
        if (!CABLES.UI) return;
        if (!this.isLinked()) return;
        const n = {};
        n[e] = this.links[0].getOtherPort(this).getUiAttrib(e), t.setUiAttribs(n)
    }, C.prototype.getValueForDisplay = function() {
        let e = this.value;
        return "string" == typeof this.value || this.value instanceof String ? (this.uiAttribs && "boolnum" == this.uiAttribs.display && (e += " - ", this.value ? e += "true" : e += "false"), e = e.replace(/[\u00A0-\u9999<>\&]/g, function(e) {
            return "&#" + e.charCodeAt(0) + ";"
        }), e.length > 100 && (e = e.substring(0, 100))) : e = this.value, e
    }, C.prototype.onAnimToggle = function() {}, C.prototype._onAnimToggle = function() {
        this.onAnimToggle()
    }, C.prototype.remove = function() {
        this.removeLinks(), this._op.removePort(this)
    }, C.prototype.setUiAttribs = function(t) {
        let n = !1;
        this.uiAttribs || (this.uiAttribs = {});
        for (const e in t) this.uiAttribs[e] != t[e] && (n = !0), this.uiAttribs[e] = t[e], "group" == e && this.indexPort && this.indexPort.setUiAttribs({
            group: t[e]
        });
        t.hasOwnProperty("expose") && this._op.patch.emitEvent("subpatchExpose", this._op.uiAttribs.subPatch), n && this.emitEvent("onUiAttrChange", t, this)
    }, C.prototype.getUiAttribs = function() {
        return this.uiAttribs
    }, C.prototype.getUiAttrib = function(e) {
        return this.uiAttribs && this.uiAttribs.hasOwnProperty(e) ? this.uiAttribs[e] : null
    }, C.prototype.get = function() {
        return this._animated && this._lastAnimFrame != this._op.patch.getFrameNum() && (this._lastAnimFrame = this._op.patch.getFrameNum(), this.value = this.anim.getValue(this._op.patch.timer.getTime()), this._oldAnimVal = this.value, this.forceChange()), this.value
    }, C.prototype.setRef = function(e) {
        this.forceRefChange = !0, this.set(e)
    }, C.prototype.set = C.prototype.setValue = function(e) {
        if (void 0 === e && (e = null), this._op.enabled && !this.crashed && (e !== this.value || this.changeAlways || this.type == t || this.type == a)) {
            if (this._animated) this.anim.setValue(this._op.patch.timer.getTime(), e);
            else {
                try {
                    this.value = e, this.forceChange()
                } catch (e) {
                    this.crashed = !0, this.setValue = function(e) {}, this.onTriggered = function() {}, this._log.error("onvaluechanged exception cought", e), this._log.error(e.stack), this._log.warn("exception in: " + this._op.name), this._op.patch.isEditorMode() && gui.showOpCrash(this._op), this._op.patch.emitEvent("exception", e, this._op), this._op.onError && this._op.onError(e)
                }
                this._op && this._op.patch && this._op.patch.isEditorMode() && this.type == t && gui.texturePreview().updateTexturePort(this)
            }
            if (this.direction == c)
                for (let e = 0; e < this.links.length; ++e) this.links[e].setValue()
        }
    }, C.prototype.updateAnim = function() {
        this._animated && (this.value = this.get(), (this._oldAnimVal != this.value || this.changeAlways) && (this._oldAnimVal = this.value, this.forceChange()), this._oldAnimVal = this.value)
    }, C.args = function(e) {
        return (e + "").replace(/[/][/].*$/gm, "").replace(/\s+/g, "").replace(/[/][*][^/*]*[*][/]/g, "").split("){", 1)[0].replace(/^[^(]*[(]/, "").replace(/=[^,]+/g, "").split(",").filter(Boolean)
    }, C.prototype.forceChange = function() {
        this.onValueChanged || this.onChange, this._activity(), this.emitEvent("change", this.value, this), this.onChange ? this.onChange(this, this.value) : this.onValueChanged && this.onValueChanged(this, this.value)
    }, C.prototype.getTypeString = function() {
        return this.type == r ? "Number" : this.type == n ? "Trigger" : this.type == i ? "Object" : this.type == o ? "Dynamic" : this.type == a ? "Array" : this.type == l ? "String" : "Unknown"
    }, C.prototype.deSerializeSettings = function(t) {
        if (t && (t.animated && this.setAnimated(t.animated), t.useVariable && this.setVariableName(t.useVariable), t.title && this.setUiAttribs({
                title: t.title
            }), t.expose && this.setUiAttribs({
                expose: !0
            }), t.anim)) {
            this.anim || (this.anim = new x({
                name: "port " + this.name
            })), this._op._hasAnimPort = !0, this.anim.addEventListener("onChange", () => {
                this._op.patch.emitEvent("portAnimUpdated", this._op, this, this.anim)
            }), t.anim.loop && (this.anim.loop = t.anim.loop);
            for (const e in t.anim.keys) this.anim.keys.push(new y(t.anim.keys[e]));
            this.anim.sortKeys()
        }
    }, C.prototype.getSerialized = function() {
        const t = {};
        if (t.name = this.getName(), this.ignoreValueSerialize || 0 !== this.links.length || this.type == i && this.value && this.value.tex || (t.value = this.value), this._useVariableName && (t.useVariable = this._useVariableName), this._animated && (t.animated = !0), this.anim && (t.anim = this.anim.getSerialized()), "file" == this.uiAttribs.display && (t.display = this.uiAttribs.display), this.uiAttribs.expose && (t.expose = !0), this.uiAttribs.title && (t.title = this.uiAttribs.title), this.direction == c && this.links.length > 0) {
            t.links = [];
            for (const e in this.links) !this.links[e].ignoreInSerialize && this.links[e].portIn && this.links[e].portOut && t.links.push(this.links[e].getSerialized())
        }
        if (this.direction == h && this.links.length > 0)
            for (const e in this.links) this.links[e].portIn && this.links[e].portOut && this.links[e].getOtherPort(this).op.isInBlueprint2() && !this.op.isInBlueprint2() && (t.links = t.links || [], t.links.push(this.links[e].getSerialized()));
        return t
    }, C.prototype.shouldLink = function() {
        return !0
    }, C.prototype.removeLinks = function() {
        let e = 0;
        for (; this.links.length > 0;) {
            if (e++, e > 5e3) {
                this._log.warn("could not delete links... / infinite loop"), this.links.length = 0;
                break
            }
            this.links[0].remove()
        }
    }, C.prototype.removeLink = function(e) {
        for (const r in this.links) this.links[r] == e && this.links.splice(r, 1);
        this.direction == h && (this.type == r ? this.setValue(this._valueBeforeLink || 0) : this.setValue(this._valueBeforeLink || null)), CABLES.UI && this._op.checkLinkTimeWarnings && this._op.checkLinkTimeWarnings(), this.onLinkChanged && this.onLinkChanged(), this.emitEvent("onLinkChanged"), this._op.emitEvent("onLinkChanged")
    }, C.prototype.getName = function() {
        return this.name
    }, C.prototype.addLink = function(e) {
        this._valueBeforeLink = this.value, this.links.push(e), CABLES.UI && this._op.checkLinkTimeWarnings && this._op.checkLinkTimeWarnings(), this.onLinkChanged && this.onLinkChanged(), this.emitEvent("onLinkChanged"), this._op.emitEvent("onLinkChanged")
    }, C.prototype.getLinkTo = function(t) {
        for (const e in this.links)
            if (this.links[e].portIn == t || this.links[e].portOut == t) return this.links[e]
    }, C.prototype.removeLinkTo = function(t) {
        for (const e in this.links)
            if (this.links[e].portIn == t || this.links[e].portOut == t) return this.links[e].remove(), CABLES.UI && this._op.checkLinkTimeWarnings && this._op.checkLinkTimeWarnings(), this.onLinkChanged && this.onLinkChanged(), void this.emitEvent("onLinkChanged")
    }, C.prototype.isLinkedTo = function(t) {
        for (const e in this.links)
            if (this.links[e].portIn == t || this.links[e].portOut == t) return !0;
        return !1
    }, C.prototype._activity = function() {
        this.activityCounter++
    }, C.prototype.trigger = function() {
        const t = this.links.length;
        if (this._activity(), 0 === t) return;
        if (!this._op.enabled) return;
        let n = null;
        try {
            for (let e = 0; e < t; ++e) this.links[e].portIn && (n = this.links[e].portIn, n.op.patch.pushTriggerStack(n), n._onTriggered(), n.op.patch.popTriggerStack()), this.links[e] && this.links[e].activity()
        } catch (t) {
            this._op.enabled = !1, this._op.patch.isEditorMode() && (this._op.patch.emitEvent("exception", t, n.op), this._op.patch.emitEvent("opcrash", n), n.op.onError && n.op.onError(t)), this._log.warn("exception!"), this._log.error("ontriggered exception caught", t), this._log.error(t.stack), this._log.warn("exception in: " + n.op.name)
        }
    }, C.prototype.call = function() {
        this._log.warn("call deprecated - use trigger() "), this.trigger()
    }, C.prototype.execute = function() {
        this._log.warn("### execute port: " + this.getName(), this.goals.length)
    }, C.prototype.setVariableName = function(e) {
        this._useVariableName = e, this._op.patch.on("variableRename", (e, t) => {
            e == this._useVariableName && (this._useVariableName = t)
        })
    }, C.prototype.getVariableName = function() {
        return this._useVariableName
    }, C.prototype.setVariable = function(e) {
        this.setAnimated(!1);
        const t = {
            useVariable: !1
        };
        this._variableIn && this._varChangeListenerId && (this._variableIn.off(this._varChangeListenerId), this._variableIn = null), e ? (this._variableIn = this._op.patch.getVar(e), this._variableIn ? (this.type == i ? this._varChangeListenerId = this._variableIn.on("change", () => {
            this.set(null), this.set(this._variableIn.getValue())
        }) : this._varChangeListenerId = this._variableIn.on("change", this.set.bind(this)), this.set(this._variableIn.getValue())) : this._log.warn("PORT VAR NOT FOUND!!!", e), this._useVariableName = e, t.useVariable = !0, t.variableName = this._useVariableName) : (t.variableName = this._useVariableName = null, t.useVariable = !1), this.setUiAttribs(t), this._op.patch.emitEvent("portSetVariable", this._op, this, e)
    }, C.prototype._handleNoTriggerOpAnimUpdates = function(e) {
        let t = !1;
        for (let e = 0; e < this._op.portsIn.length; e++)
            if (this._op.portsIn.type == n) {
                t = !0;
                break
            } t || (e ? this._notriggerAnimUpdate = this._op.patch.on("onRenderFrame", () => {
            this.updateAnim()
        }) : this._op.patch.removeEventListener(this._notriggerAnimUpdate))
    }, C.prototype.setAnimated = function(e) {
        this._animated != e && (this._animated = e, this._op._hasAnimPort = !0, this._animated && !this.anim && (this.anim = new x({
            name: "port " + this.name
        }), this.anim.addEventListener("onChange", () => {
            this._op.patch.emitEvent("portAnimUpdated", this._op, this, this.anim)
        })), this._onAnimToggle()), this._handleNoTriggerOpAnimUpdates(e), e || (this.anim = null), this.setUiAttribs({
            isAnimated: this._animated
        })
    }, C.prototype.toggleAnim = function() {
        this._animated = !this._animated, this._animated && !this.anim && (this.anim = new x({
            name: "port " + this.name
        }), this.anim.addEventListener("onChange", () => {
            this._op.patch.emitEvent("portAnimUpdated", this._op, this, this.anim)
        })), this.setAnimated(this._animated), this._onAnimToggle(), this.setUiAttribs({
            isAnimated: this._animated
        })
    }, C.prototype.getType = function() {
        return this.type
    }, C.prototype.isLinked = function() {
        return this.links.length > 0 || this._animated || null != this._useVariableName
    }, C.prototype.isBoundToVar = function() {
        const e = null != this._useVariableName;
        return this.uiAttribs.boundToVar = e, e
    }, C.prototype.isAnimated = function() {
        return this._animated
    }, C.prototype.isHidden = function() {
        return this.uiAttribs.hidePort
    }, C.prototype._onTriggered = function(e) {
        this._activity(), this._op.updateAnims(), this._op.enabled && this.onTriggered && this.onTriggered(e)
    }, C.prototype._onSetProfiling = function(e) {
        this._op.patch.profiler.add("port", this), this.setValue(e), this._op.patch.profiler.add("port", null)
    }, C.prototype._onTriggeredProfiling = function() {
        this._op.enabled && this.onTriggered && (this._op.patch.profiler.add("port", this), this.onTriggered(), this._op.patch.profiler.add("port", null))
    }, C.prototype.onValueChange = function(e) {
        this.onChange = e
    }, C.prototype.getUiActiveState = function() {
        return this._uiActiveState
    }, C.prototype.setUiActiveState = function(e) {
        this._uiActiveState = e, this.onUiActiveStateChange && this.onUiActiveStateChange()
    }, C.prototype.hidePort = function() {
        this._log.warn("op.hideport() is deprecated, do not use it!")
    }, C.portTypeNumberToString = function(e) {
        return e == r ? "value" : e == n ? "function" : e == i ? "object" : e == a ? "array" : e == l ? "string" : e == o ? "dynamic" : "unknown"
    };
    const S = class {
        constructor(e, t, n, i, s, r, a, o, l, h) {
            if (this._log = new p("cg_uniform"), this._type = t, this._name = n, this._shader = e, this._value = 1e-5, this._oldValue = null, this._port = null, this._structName = l, this._structUniformName = o, this._propertyName = h, this._shader._addUniform(this), this.needsUpdate = !0, this.shaderType = null, this.comment = null, "f" == t) this.set = this.setValue = this.setValueF.bind(this), this.updateValue = this.updateValueF.bind(this);
            else if ("f[]" == t) this.set = this.setValue = this.setValueArrayF.bind(this), this.updateValue = this.updateValueArrayF.bind(this);
            else if ("2f[]" == t) this.set = this.setValue = this.setValueArray2F.bind(this), this.updateValue = this.updateValueArray2F.bind(this);
            else if ("3f[]" == t) this.set = this.setValue = this.setValueArray3F.bind(this), this.updateValue = this.updateValueArray3F.bind(this);
            else if ("4f[]" == t) this.set = this.setValue = this.setValueArray4F.bind(this), this.updateValue = this.updateValueArray4F.bind(this);
            else if ("i" == t) this.set = this.setValue = this.setValueI.bind(this), this.updateValue = this.updateValueI.bind(this);
            else if ("2i" == t) this.set = this.setValue = this.setValue2I.bind(this), this.updateValue = this.updateValue2I.bind(this);
            else if ("3i" == t) this.set = this.setValue = this.setValue3I.bind(this), this.updateValue = this.updateValue3I.bind(this);
            else if ("4i" == t) this.set = this.setValue = this.setValue4I.bind(this), this.updateValue = this.updateValue4I.bind(this);
            else if ("b" == t) this.set = this.setValue = this.setValueBool.bind(this), this.updateValue = this.updateValueBool.bind(this);
            else if ("4f" == t) this.set = this.setValue = this.setValue4F.bind(this), this.updateValue = this.updateValue4F.bind(this);
            else if ("3f" == t) this.set = this.setValue = this.setValue3F.bind(this), this.updateValue = this.updateValue3F.bind(this);
            else if ("2f" == t) this.set = this.setValue = this.setValue2F.bind(this), this.updateValue = this.updateValue2F.bind(this);
            else if ("t" == t) this.set = this.setValue = this.setValueT.bind(this), this.updateValue = this.updateValueT.bind(this);
            else if ("tc" == t) this.set = this.setValue = this.setValueT.bind(this), this.updateValue = this.updateValueT.bind(this);
            else if ("t[]" == t) this.set = this.setValue = this.setValueArrayT.bind(this), this.updateValue = this.updateValueArrayT.bind(this);
            else {
                if ("m4" != t && "m4[]" != t) throw new Error("Unknown uniform type");
                this.set = this.setValue = this.setValueM4.bind(this), this.updateValue = this.updateValueM4.bind(this)
            }
            "object" == typeof i && i instanceof C ? (this._port = i, this._value = this._port.get(), s && r && a ? (s instanceof C && r instanceof C && a instanceof C || this._log.error("[cgl_uniform] mixed port/value parameter for vec4 ", this._name), this._value = [0, 0, 0, 0], this._port2 = s, this._port3 = r, this._port4 = a, this._port.on("change", this.updateFromPort4f.bind(this)), this._port2.on("change", this.updateFromPort4f.bind(this)), this._port3.on("change", this.updateFromPort4f.bind(this)), this._port4.on("change", this.updateFromPort4f.bind(this)), this.updateFromPort4f()) : s && r ? (s instanceof C && r instanceof C || this._log.error("[cgl_uniform] mixed port/value parameter for vec4 ", this._name), this._value = [0, 0, 0], this._port2 = s, this._port3 = r, this._port.on("change", this.updateFromPort3f.bind(this)), this._port2.on("change", this.updateFromPort3f.bind(this)), this._port3.on("change", this.updateFromPort3f.bind(this)), this.updateFromPort3f()) : s ? (s instanceof C || this._log.error("[cgl_uniform] mixed port/value parameter for vec4 ", this._name), this._value = [0, 0], this._port2 = s, this._port.on("change", this.updateFromPort2f.bind(this)), this._port2.on("change", this.updateFromPort2f.bind(this)), this.updateFromPort2f()) : this._port.on("change", this.updateFromPort.bind(this))) : this._value = i, this.setValue(this._value), this.needsUpdate = !0
        }
        getType() {
            return this._type
        }
        getName() {
            return this._name
        }
        getValue() {
            return this._value
        }
        getShaderType() {
            return this.shaderType
        }
        isStructMember() {
            return !!this._structName
        }
        updateFromPort4f() {
            this._value[0] = this._port.get(), this._value[1] = this._port2.get(), this._value[2] = this._port3.get(), this._value[3] = this._port4.get(), this.setValue(this._value)
        }
        updateFromPort3f() {
            this._value[0] = this._port.get(), this._value[1] = this._port2.get(), this._value[2] = this._port3.get(), this.setValue(this._value)
        }
        updateFromPort2f() {
            this._value[0] = this._port.get(), this._value[1] = this._port2.get(), this.setValue(this._value)
        }
        updateFromPort() {
            this.setValue(this._port.get())
        }
    };
    class A extends S {
        constructor(e, t, n, i, s, r, a, o, l, h) {
            super(e, t, n, i, s, r, a, o, l, h), this._loc = -1, this._cgl = e._cgl
        }
        get name() {
            return this._name
        }
        copy(e) {
            const t = new A(e, this._type, this._name, this._value, this._port2, this._port3, this._port4, this._structUniformName, this._structName, this._propertyName);
            return t.shaderType = this.shaderType, t
        }
        getGlslTypeString() {
            return A.glslTypeString(this._type)
        }
        _isValidLoc() {
            return -1 != this._loc
        }
        resetLoc() {
            this._loc = -1, this.needsUpdate = !0
        }
        bindTextures() {}
        getLoc() {
            return this._loc
        }
        updateFromPort4f() {
            this._value[0] = this._port.get(), this._value[1] = this._port2.get(), this._value[2] = this._port3.get(), this._value[3] = this._port4.get(), this.setValue(this._value)
        }
        updateFromPort3f() {
            this._value[0] = this._port.get(), this._value[1] = this._port2.get(), this._value[2] = this._port3.get(), this.setValue(this._value)
        }
        updateFromPort2f() {
            this._value[0] = this._port.get(), this._value[1] = this._port2.get(), this.setValue(this._value)
        }
        updateFromPort() {
            this.setValue(this._port.get())
        }
        updateValueF() {
            this._isValidLoc() ? this.needsUpdate = !1 : this._loc = this._shader.getCgl().gl.getUniformLocation(this._shader.getProgram(), this._name), this._shader.getCgl().gl.uniform1f(this._loc, this._value), this._cgl.profileData.profileUniformCount++
        }
        setValueF(e) {
            e != this._value && (this.needsUpdate = !0, this._value = e)
        }
        updateValueI() {
            this._isValidLoc() ? this.needsUpdate = !1 : this._loc = this._shader.getCgl().gl.getUniformLocation(this._shader.getProgram(), this._name), this._shader.getCgl().gl.uniform1i(this._loc, this._value), this._cgl.profileData.profileUniformCount++
        }
        updateValue2I() {
            this._value && (this._isValidLoc() || (this._loc = this._shader.getCgl().gl.getUniformLocation(this._shader.getProgram(), this._name), this._cgl.profileData.profileShaderGetUniform++, this._cgl.profileData.profileShaderGetUniformName = this._name), this._shader.getCgl().gl.uniform2i(this._loc, this._value[0], this._value[1]), this.needsUpdate = !1, this._cgl.profileData.profileUniformCount++)
        }
        updateValue3I() {
            this._value && (this._isValidLoc() || (this._loc = this._shader.getCgl().gl.getUniformLocation(this._shader.getProgram(), this._name), this._cgl.profileData.profileShaderGetUniform++, this._cgl.profileData.profileShaderGetUniformName = this._name), this._shader.getCgl().gl.uniform3i(this._loc, this._value[0], this._value[1], this._value[2]), this.needsUpdate = !1, this._cgl.profileData.profileUniformCount++)
        }
        updateValue4I() {
            this._isValidLoc() || (this._loc = this._shader.getCgl().gl.getUniformLocation(this._shader.getProgram(), this._name), this._cgl.profileData.profileShaderGetUniform++, this._cgl.profileData.profileShaderGetUniformName = this._name), this._shader.getCgl().gl.uniform4i(this._loc, this._value[0], this._value[1], this._value[2], this._value[3]), this._cgl.profileData.profileUniformCount++
        }
        setValueI(e) {
            e != this._value && (this.needsUpdate = !0, this._value = e)
        }
        setValue2I(e) {
            e && (this._oldValue ? e[0] == this._oldValue[0] && e[1] == this._oldValue[1] || (this._oldValue[0] = e[0], this._oldValue[1] = e[1], this.needsUpdate = !0) : (this._oldValue = [e[0] - 1, 1], this.needsUpdate = !0), this._value = e)
        }
        setValue3I(e) {
            e && (this._oldValue ? e[0] == this._oldValue[0] && e[1] == this._oldValue[1] && e[2] == this._oldValue[2] || (this._oldValue[0] = e[0], this._oldValue[1] = e[1], this._oldValue[2] = e[2], this.needsUpdate = !0) : (this._oldValue = [e[0] - 1, 1, 2], this.needsUpdate = !0), this._value = e)
        }
        setValue4I(e) {
            this.needsUpdate = !0, this._value = e || vec4.create()
        }
        updateValueBool() {
            this._isValidLoc() ? this.needsUpdate = !1 : this._loc = this._shader.getCgl().gl.getUniformLocation(this._shader.getProgram(), this._name), this._shader.getCgl().gl.uniform1i(this._loc, this._value ? 1 : 0), this._cgl.profileData.profileUniformCount++
        }
        setValueBool(e) {
            e != this._value && (this.needsUpdate = !0, this._value = e)
        }
        setValueArray4F(e) {
            this.needsUpdate = !0, this._value = e
        }
        updateValueArray4F() {
            this._isValidLoc() ? this.needsUpdate = !1 : this._loc = this._shader.getCgl().gl.getUniformLocation(this._shader.getProgram(), this._name), this._value && (this._shader.getCgl().gl.uniform4fv(this._loc, this._value), this._cgl.profileData.profileUniformCount++)
        }
        setValueArray3F(e) {
            this.needsUpdate = !0, this._value = e
        }
        updateValueArray3F() {
            this._isValidLoc() ? this.needsUpdate = !1 : this._loc = this._shader.getCgl().gl.getUniformLocation(this._shader.getProgram(), this._name), this._value && (this._shader.getCgl().gl.uniform3fv(this._loc, this._value), this._cgl.profileData.profileUniformCount++)
        }
        setValueArray2F(e) {
            this.needsUpdate = !0, this._value = e
        }
        updateValueArray2F() {
            this._isValidLoc() ? this.needsUpdate = !1 : this._loc = this._shader.getCgl().gl.getUniformLocation(this._shader.getProgram(), this._name), this._value && (this._shader.getCgl().gl.uniform2fv(this._loc, this._value), this._cgl.profileData.profileUniformCount++)
        }
        setValueArrayF(e) {
            this.needsUpdate = !0, this._value = e
        }
        updateValueArrayF() {
            this._isValidLoc() ? this.needsUpdate = !1 : this._loc = this._shader.getCgl().gl.getUniformLocation(this._shader.getProgram(), this._name), this._value && (this._shader.getCgl().gl.uniform1fv(this._loc, this._value), this._cgl.profileData.profileUniformCount++)
        }
        setValueArrayT(e) {
            this.needsUpdate = !0, this._value = e
        }
        updateValue3F() {
            this._value && (this._isValidLoc() || (this._loc = this._shader.getCgl().gl.getUniformLocation(this._shader.getProgram(), this._name), this._cgl.profileData.profileShaderGetUniform++, this._cgl.profileData.profileShaderGetUniformName = this._name), this._shader.getCgl().gl.uniform3f(this._loc, this._value[0], this._value[1], this._value[2]), this.needsUpdate = !1, this._cgl.profileData.profileUniformCount++)
        }
        setValue3F(e) {
            e && (this._oldValue ? e[0] == this._oldValue[0] && e[1] == this._oldValue[1] && e[2] == this._oldValue[2] || (this._oldValue[0] = e[0], this._oldValue[1] = e[1], this._oldValue[2] = e[2], this.needsUpdate = !0) : (this._oldValue = [e[0] - 1, 1, 2], this.needsUpdate = !0), this._value = e)
        }
        updateValue2F() {
            this._value && (this._isValidLoc() || (this._loc = this._shader.getCgl().gl.getUniformLocation(this._shader.getProgram(), this._name), this._cgl.profileData.profileShaderGetUniform++, this._cgl.profileData.profileShaderGetUniformName = this._name), this._shader.getCgl().gl.uniform2f(this._loc, this._value[0], this._value[1]), this.needsUpdate = !1, this._cgl.profileData.profileUniformCount++)
        }
        setValue2F(e) {
            e && (this._oldValue ? e[0] == this._oldValue[0] && e[1] == this._oldValue[1] || (this._oldValue[0] = e[0], this._oldValue[1] = e[1], this.needsUpdate = !0) : (this._oldValue = [e[0] - 1, 1], this.needsUpdate = !0), this._value = e)
        }
        updateValue4F() {
            this._isValidLoc() || (this._loc = this._shader.getCgl().gl.getUniformLocation(this._shader.getProgram(), this._name), this._cgl.profileData.profileShaderGetUniform++, this._cgl.profileData.profileShaderGetUniformName = this._name), this._value || (this._log.warn("no value for uniform", this._name, this), this._value = [0, 0, 0, 0]), this.needsUpdate = !1, this._shader.getCgl().gl.uniform4f(this._loc, this._value[0], this._value[1], this._value[2], this._value[3]), this._cgl.profileData.profileUniformCount++
        }
        setValue4F(e) {
            "number" == typeof this.value && (this.value = vec4.create()), e && (this._oldValue ? e[0] == this._oldValue[0] && e[1] == this._oldValue[1] && e[2] == this._oldValue[2] && e[3] == this._oldValue[3] || (this._oldValue[0] = e[0], this._oldValue[1] = e[1], this._oldValue[2] = e[2], this.needsUpdate = !0) : (this._oldValue = [e[0] - 1, 1, 2, 3], this.needsUpdate = !0), this._value = e)
        }
        updateValueM4() {
            if (this._isValidLoc() || (this._loc = this._shader.getCgl().gl.getUniformLocation(this._shader.getProgram(), this._name), this._cgl.profileData.profileShaderGetUniform++, this._cgl.profileData.profileShaderGetUniformName = this._name), !this._value || this._value.length % 16 != 0) return console.log("this.name", this._name, this._value);
            this._shader.getCgl().gl.uniformMatrix4fv(this._loc, !1, this._value), this._cgl.profileData.profileUniformCount++
        }
        setValueM4(e) {
            this.needsUpdate = !0, this._value = e || mat4.create()
        }
        updateValueArrayT() {
            this._isValidLoc() ? this.needsUpdate = !1 : this._loc = this._shader.getCgl().gl.getUniformLocation(this._shader.getProgram(), this._name), this._value && (this._shader.getCgl().gl.uniform1iv(this._loc, this._value), this._cgl.profileData.profileUniformCount++)
        }
        updateValueT() {
            this._isValidLoc() || (this._loc = this._shader.getCgl().gl.getUniformLocation(this._shader.getProgram(), this._name), this._cgl.profileData.profileShaderGetUniform++, this._cgl.profileData.profileShaderGetUniformName = this._name), this._cgl.profileData.profileUniformCount++, this._shader.getCgl().gl.uniform1i(this._loc, this._value), this.needsUpdate = !1
        }
        setValueT(e) {
            this.needsUpdate = !0, this._value = e
        }
    }
    A.glslTypeString = e => "f" == e ? "float" : "b" == e ? "bool" : "i" == e ? "int" : "2i" == e ? "ivec2" : "2f" == e ? "vec2" : "3f" == e ? "vec3" : "4f" == e ? "vec4" : "m4" == e ? "mat4" : "t" == e ? "sampler2D" : "tc" == e ? "samplerCube" : "3f[]" == e || "m4[]" == e || "f[]" == e ? null : void console.warn("[CGL UNIFORM] unknown glsl type string ", e);
    Math.PI;
    const w = (Math.PI, {
            SHADERVAR_VERTEX_POSITION: "vPosition",
            SHADERVAR_VERTEX_NUMBER: "attrVertIndex",
            SHADERVAR_VERTEX_NORMAL: "attrVertNormal",
            SHADERVAR_VERTEX_TEXCOORD: "attrTexCoord",
            SHADERVAR_INSTANCE_MMATRIX: "instMat",
            SHADERVAR_VERTEX_COLOR: "attrVertColor",
            SHADERVAR_INSTANCE_INDEX: "instanceIndex",
            SHADERVAR_UNI_PROJMAT: "projMatrix",
            SHADERVAR_UNI_VIEWMAT: "viewMatrix",
            SHADERVAR_UNI_MODELMAT: "modelMatrix",
            SHADERVAR_UNI_NORMALMAT: "normalMatrix",
            SHADERVAR_UNI_INVVIEWMAT: "inverseViewMatrix",
            SHADERVAR_UNI_INVPROJMAT: "invProjMatrix",
            SHADERVAR_UNI_MATERIALID: "materialId",
            SHADERVAR_UNI_OBJECTID: "objectId",
            SHADERVAR_UNI_VIEWPOS: "camPos"
        }),
        I = {
            lastMesh: null
        },
        T = function(e, t, n) {
            this._cgl = e, this._log = new p("cgl_mesh"), this._bufVertexAttrib = null, this._bufVerticesIndizes = this._cgl.gl.createBuffer(), this._indexType = this._cgl.gl.UNSIGNED_SHORT, this._attributes = [], this._attribLocs = {}, this._geom = null, this._lastShader = null, this._numInstances = 0, this._glPrimitive = n, this._preWireframeGeom = null, this.addVertexNumbers = !1, this._name = "unknown", this.feedBackAttributes = [], this.setGeom(t), this._feedBacks = [], this._feedBacksChanged = !1, this._transformFeedBackLoc = -1, this._lastAttrUpdate = 0, this._cgl.profileData.addHeavyEvent("mesh constructed", this._name), this._queryExt = null, Object.defineProperty(this, "numInstances", {
                get() {
                    return this._numInstances
                },
                set(e) {
                    this.setNumInstances(e)
                }
            })
        };
    T.prototype.updateVertices = function(e) {
            this.setAttribute(w.SHADERVAR_VERTEX_POSITION, e.vertices, 3), this._numVerts = e.vertices.length / 3
        }, T.prototype.setAttributePointer = function(t, n, i, s) {
            for (let e = 0; e < this._attributes.length; e++) this._attributes[e].name == t && (this._attributes[e].pointer || (this._attributes[e].pointer = []), this._attributes[e].pointer.push({
                loc: -1,
                name: n,
                stride: i,
                offset: s,
                instanced: t == w.SHADERVAR_INSTANCE_MMATRIX
            }))
        }, T.prototype.getAttribute = function(t) {
            for (let e = 0; e < this._attributes.length; e++)
                if (this._attributes[e].name == t) return this._attributes[e]
        }, T.prototype.setAttributeRange = function(e, t, n, i) {
            e && (n || i) && (e.name || (console.log(e), this._log.stack("no attrname?!")), this._cgl.gl.bindBuffer(this._cgl.gl.ARRAY_BUFFER, e.buffer), this._cgl.profileData.profileMeshAttributes += i - n || 0, this._cgl.profileData.profileSingleMeshAttribute[this._name] = this._cgl.profileData.profileSingleMeshAttribute[this._name] || 0, this._cgl.profileData.profileSingleMeshAttribute[this._name] += i - n || 0, e.numItems < t.length / e.itemSize && this._resizeAttr(t, e), i >= t.length - 1 && this._log.log(this._cgl.canvas.id + " " + e.name + " buffersubdata out of bounds ?", t.length, i, n, e), 1 == this._cgl.glVersion ? this._cgl.gl.bufferSubData(this._cgl.gl.ARRAY_BUFFER, 0, t) : this._cgl.gl.bufferSubData(this._cgl.gl.ARRAY_BUFFER, 4 * n, t, n, i - n))
        }, T.prototype._resizeAttr = function(e, t) {
            t.buffer && this._cgl.gl.deleteBuffer(t.buffer), t.buffer = this._cgl.gl.createBuffer(), this._cgl.gl.bindBuffer(this._cgl.gl.ARRAY_BUFFER, t.buffer), this._bufferArray(e, t), t.numItems = e.length / t.itemSize
        }, T.prototype._bufferArray = function(e, t) {
            let n = t.floatArray || null;
            e && (this._cgl.debugOneFrame && console.log("_bufferArray", e.length, t.name), e instanceof Float32Array ? n = e : t && n && n.length == e.length ? n.set(e) : (n = new Float32Array(e), this._cgl.debugOneFrame && console.log("_bufferArray create new float32array", e.length, t.name), this._cgl.profileData.profileNonTypedAttrib++, this._cgl.profileData.profileNonTypedAttribNames = "(" + this._name + ":" + t.name + ")"), t.arrayLength = n.length, t.floatArray = n, this._cgl.gl.bufferData(this._cgl.gl.ARRAY_BUFFER, n, this._cgl.gl.DYNAMIC_DRAW))
        }, T.prototype.addAttribute = T.prototype.updateAttribute = T.prototype.setAttribute = function(e, t, n, i) {
            if (!t) throw this._log.error("mesh addAttribute - no array given! " + e), new Error;
            let s = null,
                r = !1,
                a = 0;
            const o = t.length / n;
            for (this._cgl.profileData.profileMeshAttributes += o || 0, "function" == typeof i && (s = i), "object" == typeof i && (i.cb && (s = i.cb), i.instanced && (r = i.instanced)), e == w.SHADERVAR_INSTANCE_MMATRIX && (r = !0), a = 0; a < this._attributes.length; a++) {
                const n = this._attributes[a];
                if (n.name == e) return n.numItems === o || this._resizeAttr(t, n), this._cgl.gl.bindBuffer(this._cgl.gl.ARRAY_BUFFER, n.buffer), this._bufferArray(t, n), n
            }
            const l = this._cgl.gl.createBuffer();
            this._cgl.gl.bindBuffer(this._cgl.gl.ARRAY_BUFFER, l);
            let h = this._cgl.gl.FLOAT;
            i && i.type && (h = i.type);
            const c = {
                buffer: l,
                name: e,
                cb: s,
                itemSize: n,
                numItems: o,
                startItem: 0,
                instanced: r,
                type: h
            };
            return this._bufferArray(t, c), e == w.SHADERVAR_VERTEX_POSITION && (this._bufVertexAttrib = c), this._attributes.push(c), this._attribLocs = {}, c
        }, T.prototype.getAttributes = function() {
            return this._attributes
        }, T.prototype.updateTexCoords = function(t) {
            if (t.texCoords && t.texCoords.length > 0) this.setAttribute(w.SHADERVAR_VERTEX_TEXCOORD, t.texCoords, 2);
            else {
                const e = new Float32Array(Math.round(t.vertices.length / 3 * 2));
                this.setAttribute(w.SHADERVAR_VERTEX_TEXCOORD, e, 2)
            }
        }, T.prototype.updateNormals = function(t) {
            if (t.vertexNormals && t.vertexNormals.length > 0) this.setAttribute(w.SHADERVAR_VERTEX_NORMAL, t.vertexNormals, 3);
            else {
                const e = new Float32Array(Math.round(t.vertices.length));
                this.setAttribute(w.SHADERVAR_VERTEX_NORMAL, e, 3)
            }
        }, T.prototype._setVertexNumbers = function(e) {
            if (!this._verticesNumbers || this._verticesNumbers.length != this._numVerts || e) {
                if (e) this._verticesNumbers = e;
                else {
                    this._verticesNumbers = new Float32Array(this._numVerts);
                    for (let e = 0; e < this._numVerts; e++) this._verticesNumbers[e] = e
                }
                this.setAttribute(w.SHADERVAR_VERTEX_NUMBER, this._verticesNumbers, 1, (e, t, n) => {
                    n.uniformNumVertices || (n.uniformNumVertices = new A(n, "f", "numVertices", this._numVerts)), n.uniformNumVertices.setValue(this._numVerts)
                })
            }
        }, T.prototype.setVertexIndices = function(t) {
            if (this._bufVerticesIndizes)
                if (t.length > 0) {
                    t instanceof Float32Array && this._log.warn("vertIndices float32Array: " + this._name);
                    for (let e = 0; e < t.length; e++)
                        if (t[e] >= this._numVerts) return void this._log.warn("invalid index in " + this._name, e, t[e]);
                    this._cgl.gl.bindBuffer(this._cgl.gl.ELEMENT_ARRAY_BUFFER, this._bufVerticesIndizes), t.length > 65535 ? (this.vertIndicesTyped = new Uint32Array(t), this._indexType = this._cgl.gl.UNSIGNED_INT) : t instanceof Uint32Array ? (this.vertIndicesTyped = t, this._indexType = this._cgl.gl.UNSIGNED_INT) : t instanceof Uint16Array ? this.vertIndicesTyped = t : (this.vertIndicesTyped = new Uint16Array(t), this._indexType = this._cgl.gl.UNSIGNED_SHORT), this._cgl.gl.bufferData(this._cgl.gl.ELEMENT_ARRAY_BUFFER, this.vertIndicesTyped, this._cgl.gl.DYNAMIC_DRAW), this._bufVerticesIndizes.itemSize = 1, this._bufVerticesIndizes.numItems = t.length
                } else this._bufVerticesIndizes.numItems = 0;
            else this._log.warn("no bufVerticesIndizes: " + this._name)
        }, T.prototype.setGeom = function(e, t) {
            this._geom = e, null != e.glPrimitive && (this._glPrimitive = e.glPrimitive), this._geom && this._geom.name && (this._name = "mesh " + this._geom.name), I.lastMesh = null, this._cgl.profileData.profileMeshSetGeom++, this._disposeAttributes(), this.updateVertices(this._geom), this.setVertexIndices(this._geom.verticesIndices), this.addVertexNumbers && this._setVertexNumbers();
            const n = this._geom.getAttributes(),
                i = {
                    texCoords: w.SHADERVAR_VERTEX_TEXCOORD,
                    vertexNormals: w.SHADERVAR_VERTEX_NORMAL,
                    vertexColors: w.SHADERVAR_VERTEX_COLOR,
                    tangents: "attrTangent",
                    biTangents: "attrBiTangent"
                };
            for (const e in n) n[e].data && n[e].data.length && this.setAttribute(i[e] || e, n[e].data, n[e].itemSize);
            t && (this._geom = null)
        }, T.prototype._preBind = function(t) {
            for (let e = 0; e < this._attributes.length; e++) this._attributes[e].cb && this._attributes[e].cb(this._attributes[e], this._geom, t)
        }, T.prototype._checkAttrLengths = function() {
            for (let e = 0; e < this._attributes.length; e++)
                if (this._attributes[e].arrayLength / this._attributes[e].itemSize < this._attributes[0].arrayLength / this._attributes[0].itemSize) {
                    let e = "unknown";
                    this._geom && (e = this._geom.name)
                }
        }, T.prototype._bind = function(i) {
            if (!i.isValid()) return;
            let t = [];
            if (this._attribLocs[i.id] ? t = this._attribLocs[i.id] : this._attribLocs[i.id] = t, this._lastShader = i, i.lastCompile > this._lastAttrUpdate || t.length != this._attributes.length) {
                this._lastAttrUpdate = i.lastCompile;
                for (let e = 0; e < this._attributes.length; e++) t[e] = -1
            }
            for (let e = 0; e < this._attributes.length; e++) {
                const n = this._attributes[e];
                if (-1 == t[e] && n._attrLocationLastShaderTime != i.lastCompile && (n._attrLocationLastShaderTime = i.lastCompile, t[e] = this._cgl.glGetAttribLocation(i.getProgram(), n.name), this._cgl.profileData.profileAttrLoc++), -1 != t[e])
                    if (this._cgl.gl.enableVertexAttribArray(t[e]), this._cgl.gl.bindBuffer(this._cgl.gl.ARRAY_BUFFER, n.buffer), n.instanced)
                        if (n.itemSize <= 4) n.itemSize && 0 != n.itemSize || this._log.warn("instanced attrib itemsize error", this._geom.name, n), this._cgl.gl.vertexAttribPointer(t[e], n.itemSize, n.type, !1, 4 * n.itemSize, 0), this._cgl.gl.vertexAttribDivisor(t[e], 1);
                        else if (16 == n.itemSize) {
                    const i = 64;
                    this._cgl.gl.vertexAttribPointer(t[e], 4, n.type, !1, i, 0), this._cgl.gl.enableVertexAttribArray(t[e] + 1), this._cgl.gl.vertexAttribPointer(t[e] + 1, 4, n.type, !1, i, 16), this._cgl.gl.enableVertexAttribArray(t[e] + 2), this._cgl.gl.vertexAttribPointer(t[e] + 2, 4, n.type, !1, i, 32), this._cgl.gl.enableVertexAttribArray(t[e] + 3), this._cgl.gl.vertexAttribPointer(t[e] + 3, 4, n.type, !1, i, 48), this._cgl.gl.vertexAttribDivisor(t[e], 1), this._cgl.gl.vertexAttribDivisor(t[e] + 1, 1), this._cgl.gl.vertexAttribDivisor(t[e] + 2, 1), this._cgl.gl.vertexAttribDivisor(t[e] + 3, 1)
                } else this._log.warn("unknown instance attrib size", n.name);
                else {
                    if (n.itemSize && 0 != n.itemSize || this._log.warn("attrib itemsize error", this._name, n), this._cgl.gl.vertexAttribPointer(t[e], n.itemSize, n.type, !1, 4 * n.itemSize, 0), n.pointer)
                        for (let t = 0; t < n.pointer.length; t++) {
                            const e = n.pointer[t]; - 1 == e.loc && (e.loc = this._cgl.glGetAttribLocation(i.getProgram(), e.name)), this._cgl.profileData.profileAttrLoc++, this._cgl.gl.enableVertexAttribArray(e.loc), this._cgl.gl.vertexAttribPointer(e.loc, n.itemSize, n.type, !1, e.stride, e.offset)
                        }
                    this.bindFeedback(n)
                }
            }
            this._bufVerticesIndizes && 0 !== this._bufVerticesIndizes.numItems && this._cgl.gl.bindBuffer(this._cgl.gl.ELEMENT_ARRAY_BUFFER, this._bufVerticesIndizes)
        }, T.prototype.unBind = function() {
            const e = this._lastShader;
            if (this._lastShader = null, !e) return;
            let t = [];
            this._attribLocs[e.id] ? t = this._attribLocs[e.id] : this._attribLocs[e.id] = t, I.lastMesh = null;
            for (let e = 0; e < this._attributes.length; e++) this._attributes[e].instanced && (this._attributes[e].itemSize <= 4 ? (-1 != t[e] && this._cgl.gl.vertexAttribDivisor(t[e], 0), t[e] >= 0 && this._cgl.gl.disableVertexAttribArray(t[e])) : (this._cgl.gl.vertexAttribDivisor(t[e], 0), this._cgl.gl.vertexAttribDivisor(t[e] + 1, 0), this._cgl.gl.vertexAttribDivisor(t[e] + 2, 0), this._cgl.gl.vertexAttribDivisor(t[e] + 3, 0), this._cgl.gl.disableVertexAttribArray(t[e] + 1), this._cgl.gl.disableVertexAttribArray(t[e] + 2), this._cgl.gl.disableVertexAttribArray(t[e] + 3))), -1 != t[e] && this._cgl.gl.disableVertexAttribArray(t[e])
        }, T.prototype.meshChanged = function() {
            return this._cgl.lastMesh && this._cgl.lastMesh != this
        }, T.prototype.printDebug = function(e) {
            console.log("--attributes");
            for (let e = 0; e < this._attributes.length; e++) console.log("attribute " + e + " " + this._attributes[e].name)
        }, T.prototype.setNumVertices = function(e) {
            this._bufVertexAttrib.numItems = e
        }, T.prototype.getNumVertices = function() {
            return this._bufVertexAttrib.numItems
        }, T.prototype.render = function(n) {
            if (!n || !n.isValid() || this._cgl.aborted) return;
            if (this._checkAttrLengths(), this._geom && (!this._preWireframeGeom || n.wireframe || this._geom.isIndexed() || (this.setGeom(this._preWireframeGeom), this._preWireframeGeom = null), n.wireframe)) {
                let e = !1;
                this._geom.isIndexed() && (this._preWireframeGeom || (this._preWireframeGeom = this._geom, this._geom = this._geom.copy()), this._geom.unIndex(), e = !0), this._geom.getAttribute("attrBarycentric") || (this._preWireframeGeom || (this._preWireframeGeom = this._geom, this._geom = this._geom.copy()), e = !0, this._geom.calcBarycentric()), e && this.setGeom(this._geom)
            }
            let e = !1;
            if (I.lastMesh != this && (I.lastMesh && I.lastMesh.unBind(), e = !0), e && this._preBind(n), !n.bind()) return;
            this._bind(n), this.addVertexNumbers && this._setVertexNumbers(), I.lastMesh = this;
            let t = this._cgl.gl.TRIANGLES;
            void 0 !== this._glPrimitive && (t = this._glPrimitive), null !== n.glPrimitive && (t = n.glPrimitive);
            let i = 1,
                s = this._cgl.profileData.doProfileGlQuery,
                r = !1;
            if (s) {
                let e = this._name + " - " + n.getName() + " #" + n.id;
                this._numInstances && (e += " instanced " + this._numInstances + "x");
                let t = this._cgl.profileData.glQueryData[e];
                if (t || (t = {
                        id: e,
                        num: 0
                    }), this._cgl.profileData.glQueryData[e] = t, this._queryExt || !1 === this._queryExt || (this._queryExt = this._cgl.enableExtension("EXT_disjoint_timer_query_webgl2") || !1), this._queryExt) {
                    if (t._drawQuery && this._cgl.gl.getQueryParameter(t._drawQuery, this._cgl.gl.QUERY_RESULT_AVAILABLE)) {
                        const n = this._cgl.gl.getQueryParameter(t._drawQuery, this._cgl.gl.QUERY_RESULT) / 1e6;
                        t._times = t._times || 0, t._times += n, t._numcount++, t.when = performance.now(), t._drawQuery = null, t.queryStarted = !1
                    }
                    t.queryStarted || (t._drawQuery = this._cgl.gl.createQuery(), this._cgl.gl.beginQuery(this._queryExt.TIME_ELAPSED_EXT, t._drawQuery), r = t.queryStarted = !0)
                }
            }
            if (this.hasFeedbacks() ? this.drawFeedbacks(n, t) : this._bufVerticesIndizes && 0 !== this._bufVerticesIndizes.numItems ? (t == this._cgl.gl.TRIANGLES && (i = 3), 0 === this._numInstances ? this._cgl.gl.drawElements(t, this._bufVerticesIndizes.numItems, this._indexType, 0) : this._cgl.gl.drawElementsInstanced(t, this._bufVerticesIndizes.numItems, this._indexType, 0, this._numInstances)) : (t == this._cgl.gl.TRIANGLES && (i = 3), 0 === this._numInstances ? this._cgl.gl.drawArrays(t, this._bufVertexAttrib.startItem, this._bufVertexAttrib.numItems - this._bufVertexAttrib.startItem) : this._cgl.gl.drawArraysInstanced(t, this._bufVertexAttrib.startItem, this._bufVertexAttrib.numItems, this._numInstances)), this._cgl.debugOneFrame && this._cgl.gl.getError() != this._cgl.gl.NO_ERROR) {
                this._log.error("mesh draw gl error"), this._log.error("mesh", this), this._log.error("shader", n);
                for (let e = 0; e < this._cgl.gl.getProgramParameter(n.getProgram(), this._cgl.gl.ACTIVE_ATTRIBUTES); e++) {
                    const t = this._cgl.gl.getActiveAttrib(n.getProgram(), e).name;
                    this._log.error("attrib ", t)
                }
            }
            this._cgl.profileData.profileMeshNumElements += this._bufVertexAttrib.numItems / i * (this._numInstances || 1), this._cgl.profileData.profileMeshDraw++, s && r && this._cgl.gl.endQuery(this._queryExt.TIME_ELAPSED_EXT), this._cgl.printError("mesh render " + this._name), this.unBind()
        }, T.prototype.setNumInstances = function(n) {
            if (n = Math.max(0, n), this._numInstances != n) {
                this._numInstances = n;
                const t = new Float32Array(n);
                for (let e = 0; e < n; e++) t[e] = e;
                this.setAttribute(w.SHADERVAR_INSTANCE_INDEX, t, 1, {
                    instanced: !0
                })
            }
        }, T.prototype._disposeAttributes = function() {
            if (this._attributes) {
                for (let e = 0; e < this._attributes.length; e++) this._attributes[e].buffer && (this._cgl.gl.deleteBuffer(this._attributes[e].buffer), this._attributes[e].buffer = null);
                this._attributes.length = 0
            }
        }, T.prototype.dispose = function() {
            this._bufVertexAttrib && this._bufVertexAttrib.buffer && this._cgl.gl.deleteBuffer(this._bufVertexAttrib.buffer), this._bufVerticesIndizes && this._cgl.gl.deleteBuffer(this._bufVerticesIndizes), this._bufVerticesIndizes = null, this._disposeAttributes()
        },
        function(e) {
            e.prototype.hasFeedbacks = function() {
                return this._feedBacks.length > 0
            }, e.prototype.removeFeedbacks = function(e) {
                this._feedbacks && (this._feedbacks.length = 0, this._feedBacksChanged = !0)
            }, e.prototype.setAttributeFeedback = function() {}, e.prototype.setFeedback = function(e, t, n) {
                let i = {
                        nameOut: t
                    },
                    s = !1;
                this.unBindFeedbacks();
                for (let e = 0; e < this._feedBacks.length; e++) this._feedBacks[e].nameOut == t && (i = this._feedBacks[e], s = !0);
                return s || (this._feedBacksChanged = !0), i.initialArr = n, i.attrib = e, i.outBuffer && this._cgl.gl.deleteBuffer(i.outBuffer), i.outBuffer = this._cgl.gl.createBuffer(), this._cgl.gl.bindBuffer(this._cgl.gl.ARRAY_BUFFER, i.outBuffer), this._cgl.gl.bufferData(this._cgl.gl.ARRAY_BUFFER, i.initialArr, this._cgl.gl.STATIC_DRAW), this._cgl.gl.bindBuffer(this._cgl.gl.ARRAY_BUFFER, i.attrib.buffer), this._cgl.gl.bufferData(this._cgl.gl.ARRAY_BUFFER, i.initialArr, this._cgl.gl.STATIC_DRAW), s || this._feedBacks.push(i), i
            }, e.prototype.bindFeedback = function(n) {
                if (!this._feedBacks || 0 === this._feedBacks.length) return; - 1 == this._transformFeedBackLoc && (this._transformFeedBackLoc = this._cgl.gl.createTransformFeedback()), this._cgl.gl.bindTransformFeedback(this._cgl.gl.TRANSFORM_FEEDBACK, this._transformFeedBackLoc);
                let i = !1;
                for (let t = 0; t < this._feedBacks.length; t++) {
                    const e = this._feedBacks[t];
                    e.attrib == n && (i = !0, this._cgl.gl.bindBufferBase(this._cgl.gl.TRANSFORM_FEEDBACK_BUFFER, t, e.outBuffer))
                }
            }, e.prototype.drawFeedbacks = function(e, t) {
                let n = 0;
                if (this._feedBacksChanged) {
                    const t = [];
                    for (this._cgl.gl.bindTransformFeedback(this._cgl.gl.TRANSFORM_FEEDBACK, this._transformFeedBackLoc), n = 0; n < this._feedBacks.length; n++) t.push(this._feedBacks[n].nameOut);
                    return e.setFeedbackNames(t), console.log("feedbacknames", t), e.compile(), this._feedBacksChanged = !1, this._cgl.gl.bindTransformFeedback(this._cgl.gl.TRANSFORM_FEEDBACK, null), void console.log("changed finished")
                }
                this._cgl.gl.beginTransformFeedback(this.glPrimitive), this._cgl.gl.drawArrays(t, 0, this._feedBacks[0].attrib.numItems), this._cgl.gl.endTransformFeedback(), this.unBindFeedbacks(), this.feedBacksSwapBuffers()
            }, e.prototype.unBindFeedbacks = function() {
                for (let e = 0; e < this._feedBacks.length; e++) this._cgl.gl.bindBufferBase(this._cgl.gl.TRANSFORM_FEEDBACK_BUFFER, e, null);
                this._cgl.gl.bindTransformFeedback(this._cgl.gl.TRANSFORM_FEEDBACK, null)
            }, e.prototype.feedBacksSwapBuffers = function() {
                for (let t = 0; t < this._feedBacks.length; t++) {
                    const e = this._feedBacks[t].attrib.buffer;
                    this._feedBacks[t].attrib.buffer = this._feedBacks[t].outBuffer, this._feedBacks[t].outBuffer = e
                }
            }
        }(T);
    const E = function(e, t) {
        const n = new b(t);
        return n.vertices = [1, 1, 0, -1, 1, 0, 1, -1, 0, -1, -1, 0], n.texCoords = [1, 1, 0, 1, 1, 0, 0, 0], n.verticesIndices = [0, 1, 2, 2, 1, 3], n.vertexNormals = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], new T(e, n)
    };
    CGL.CopyTexture = class {
        constructor(e, t, n) {
            this.cgl = e, this._options = n, this.fb = null;
            let i = n.shader;
            if (this._useDefaultShader = !0, n.shader && (this._useDefaultShader = !1), n.numRenderBuffers = n.numRenderBuffers || 1, !i) {
                i = "".endl() + "IN vec2 texCoord;";
                for (let e = 0; e < n.numRenderBuffers; e++) i = i.endl() + "UNI sampler2D tex" + e + ";".endl();
                if (i = i.endl() + "void main()".endl() + "{", 1 == n.numRenderBuffers) i = i.endl() + "    outColor= texture(tex0,texCoord);;".endl();
                else
                    for (let e = 0; e < n.numRenderBuffers; e++) i = i.endl() + "outColor" + e + " = texture(tex" + e + ",texCoord);".endl();
                i = i.endl() + "}"
            }
            const s = n.vertexShader || "".endl() + "IN vec3 vPosition;".endl() + "IN vec2 attrTexCoord;".endl() + "OUT vec2 texCoord;".endl() + "void main()".endl() + "{".endl() + "   texCoord=attrTexCoord;".endl() + "   gl_Position = vec4(vPosition,  1.0);".endl() + "}";
            this.bgShader = new CGL.Shader(e, "corelib copytexture " + t), this.bgShader.setSource(s, i), n.vertexShader || (this.bgShader.ignoreMissingUniforms = !0), new CGL.Uniform(this.bgShader, "t", "tex", 0), new CGL.Uniform(this.bgShader, "t", "tex1", 1), new CGL.Uniform(this.bgShader, "t", "tex2", 2), new CGL.Uniform(this.bgShader, "t", "tex3", 3), this.mesh = E(this.cgl, "texEffectRect")
        }
        setSize(e, t) {
            this._options.width = e, this._options.height = t
        }
        copy(e, t, n, i, s) {
            e || (e = CGL.Texture.getEmptyTexture(this.cgl));
            const r = this._options.width || e.width,
                a = this._options.height || e.height,
                o = this.cgl;
            if (this.fb) this.fb.getWidth() == r && this.fb.getHeight() == a || this.fb.setSize(r, a);
            else {
                let e = CGL.Texture.FILTER_LINEAR,
                    t = CGL.Texture.WRAP_CLAMP_TO_EDGE;
                this._options.isFloatingPointTexture && (e = CGL.Texture.FILTER_NEAREST), this._options.hasOwnProperty("filter") && (e = this._options.filter), this._options.hasOwnProperty("wrap") && (t = this._options.wrap);
                const n = {
                    isFloatingPointTexture: this._options.isFloatingPointTexture,
                    numRenderBuffers: this._options.numRenderBuffers || 1,
                    filter: e,
                    wrap: t
                };
                1 == o.glVersion ? this.fb = new CGL.Framebuffer(o, r, a, n) : this.fb = new CGL.Framebuffer2(o, r, a, n)
            }
            return o.frameStore.renderOffscreen = !0, this.fb.renderStart(o), o.setTexture(0, e.tex), t && o.setTexture(1, t.tex), n && o.setTexture(2, n.tex), i && o.setTexture(3, i.tex), s && o.setTexture(4, s.tex), o.pushShader(this.bgShader), this.mesh.render(this.bgShader), o.popShader(), this.fb.renderEnd(), o.frameStore.renderOffscreen = !1, this.fb.getTextureColor()
        }
        dispose() {
            this.fb && this.fb.dispose(), this.bgShader && this.bgShader.dispose(), this.mesh && this.mesh.dispose()
        }
    }, ((this.CGL = this.CGL || {}).COREMODULES = this.CGL.COREMODULES || {}).Copytexture = {}.Copytexture
})();
